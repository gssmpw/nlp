\section{Methodology}
\label{sec:methodology}



\begin{figure}[t]
    \captionsetup{justification=centering}
    \centering
    \includegraphics[width=\columnwidth]{Figure/sec4/framework-ningyu.pdf}
    \vspace{-0.2in}
    \caption{Workflow and architecture of {\tool}.}
    \vspace{-0.1in}
    \label{fig:workflow}
\end{figure}

To identify attack contracts, we propose {\tool}, whose workflow and architecture are shown in Figure~\ref{fig:workflow}. As we can see, {\tool} is composed of three modules, \textit{i.e.,} \textit{Call Information Extractor} (short as {\sx}), \textit{Token Flow Graph Builder} (short as {\sy}) and \textit{Anomalous Token Flow Detector} (short as {\sz}).
Specifically, {\sx} is built upon Gigahorse~\cite{grech2019gigahorse, grech2022elipmoc}, a well-known tool that can decompile and produce intermediate representation (IR) in three-address code format. {\sx} takes the contract bytecode as input and decompiles it to obtain the IR and control flow information on the function level.
To address \textbf{Challenge 1}, based on the inter-procedural control flow graph, {\sx} firstly constructs a cross-function callsite graph (xFCG) consisting of nodes, each of which encompasses information of the callsite, callee address, and invoked function signature. The generated xFCG will be transmitted to {\sy}, which employs a data-flow-based heuristic arguments recovery algorithm to retrieve arguments' values of invoked functions. By combining the token-flow-related semantics of involved functions, {\sy} further builds a token flow graph (TFG).
To address \textbf{Challenge 2}, {\sz} filters out and traverses those suspicious sensitive paths in the TFG. By adopting a set of formal detecting rules, {\sz} can finally identify price manipulation attack contracts in an effective and efficient manner.



\subsection{Call Information Extractor}
\label{sec:extract}
As illustrated in \S\ref{sec:moti_eg}, invoking functions in both intra- and inter-contract manner is necessary for profiting from conducting price manipulation, making the extraction of call information important.
To achieve this, we leverage Gigahorse~\cite{grech2019gigahorse} and introduce a \textit{Cross-Function Callsite Graph (xFCG)} based on the inter-procedural control flow graph to efficiently depict and extract this information.


\subsubsection{Address \& Function Extraction}
\label{method:extractor:address}
\label{method:extractor:function}
Extracting callee addresses for function calls is the prerequisite for the following analysis.
In Ethereum, callee addresses can be specified in three different data structures: \textit{Calldata}, \textit{Memory}, and \textit{Storage} (see \S{\ref{sec:smart}}).
Since \textit{Calldata} is provided at runtime, which is unpredictable, we assign a placeholder in the form of \texttt{calldata\_0xN}, where \texttt{0xN} corresponds to its offset in \textit{Calldata}. For the other two cases, we leverage the \textit{facts} generated by Gigahorse based on the decompiled code. Specifically, if the callee address is stored in \textit{Memory}, we either directly extract the address (when hard-encoded in bytecode) or assign a placeholder, the same as \textit{Calldata}. Otherwise, \textit{i.e.,} the callee address is stored in \textit{Storage}, we extract the hard-encoded callee address from the facts or retrieve it from a slot number via the \texttt{getStorageAt()} API.
Note that some contracts adopt the proxy design pattern, where the actual function resides in another contract that the proxy points to. Since EIP-1967 is the most widely-adopted proxy standard in Ethereum~\cite{eip1967}, whose \textit{Storage} structure is fixed, we heuristically investigate if the EIP-1967-specific slot exists~\cite{openeip}. If it is, we take the current contract as a proxy and extract the real callee address from the slot.


Instead of the callee address, we also need to identify the invoked function to recover the developers' intent. In Ethereum contract bytecode, each function call consists of the function signature and its arguments.
As shown in Figure~\ref{fig:selector}{\color{purple}(a)}, we leverage the facts generated by Gigahorse to directly extract the 4-byte function signature. However, Gigahorse may fail to generate such facts when branch-dependent \textit{Memory} read and write operations obscure the exact \textit{Memory} layout~\cite{grech2019gigahorse, zhang2023bian}.To address this, we propose a heuristic method: backtracing the control flow to extract the operand of the most recent \texttt{PUSH4} opcode before the function call, treating it as the function signature.
As shown in Figure~\ref{fig:selector}{\color{purple}(b)}, in this case, Gigahorse fails in this MEV bot contract due to frequent branch jumps~\cite{akmev}, whereas our method correctly identifies the callee function as \texttt{swap()}, confirmed by the transaction trace.


\begin{figure}[t] 
\centering
\includegraphics[width=\columnwidth]{Figure/sec4/extractor.pdf} 
\vspace{-0.2in}
\caption{Extract function signature by Gigahorse and our heuristic method.} 
\vspace{-0.1in}
\label{fig:selector} 
\end{figure}


\subsubsection{Cross-Function Callsite Graph Construction}
\label{method:xcsg}
To illustrate relationships among function calls, based on the inter-procedural control flow graph (ICFG), we propose and build the cross-function callsite graph (xFCG).
Specifically, we only consider the basic blocks that contain function calls. We adopt a triplet to refer to each of them, defined as:
$$<callsite,callee\_address,function\_selector>$$
where $callsite$ is the offset of the call-related opcode, and $callee\_address$ and $function\_selector$ refer to the corresponding information extracted in \S\ref{method:extractor:address}.
For those basic blocks without function calls, we directly remove them and link their preceding and successive blocks.
Note that both intra-contract and inter-contract function calls are taken into consideration in building xFCG, \textit{i.e.,} the $callee\_address$ can be the address of the current or another contract.
If an inter-contract function call happens, a recursive inter-contract xFCG build will only happen on those nodes located in suspicious paths, whose selection rules will be detailed in \S\ref{sec:spf}.


\subsection{Token Flow Graph Builder}
\label{sec:tfg_g}
Identifying the value of arguments in function calls can recover the original intents more precisely. Thus, we propose a \textit{data-flow-based heuristic arguments recovery algorithm}.
Moreover, we focus on five types of token-flow related semantics, \textit{e.g.,} swap token and add liquidity, which are combined on nodes in xFCG to construct the \textit{token flow graph} (TFG).


\subsubsection{Argument Recovery}
\label{lab:argu}
The xFCG we built can only reflect the control flow dependency relationships among function calls. To more effectively address \textbf{Challenge 1}, we will also recover data flow dependency relationships, whose very first step is to recover the values or variables associated with arguments in function calls.
In EVM bytecode, call instructions do not explicitly declare them. Instead, it points a piece of bytes in \textit{Memory} through an offset and length.
While we can obtain parameter information through Gigahorse's facts, as introduced in \S\ref{method:extractor:function}, its limitations in handling complex \textit{Memory} operations can result in incomplete or inaccurate extraction~\cite{grech2019gigahorse, zhang2023bian}.

\vspace{-0.1in}
\begin{algorithm}
\small
\captionsetup{font={small}}
\caption{Data-flow-based heuristic arguments recovery}
\label{algo:extract}
\SetAlFnt{\ttfamily} 
\KwIn{\textit{CS}, the callsite of a function call}
\KwOut{\textit{Args}, argument positions and values}
$\textit{PC} \leftarrow \textit{FreeMemPointer(CS)} $

$\textit{base} \leftarrow \textit{GetBase(PC)} $

$\textit{idx} \leftarrow 0, \textit{Args} \leftarrow []$

\For{\textit{pc} from \textit{PC} to \textit{CS}}{
    \If{$\textit{isMSTORE(pc)}$}{
        $\textit{(ptr, Var)} \leftarrow \textit{ParseMSTORE(pc)}$
        
        $\textit{offset} \leftarrow \textit{ptr - base}$
        
        $\textit{value, flag} \leftarrow $ \textit{DataFlowRecover(Var)}

        \If{$!(\textit{offset = 0x4}$ \textbf{and} $\textit{idx = 0})$}{

            \If{$flag = True$}{
                $\textit{err} \leftarrow \textit{TypeCheck(idx, value)}$
                
                \If{$err \ != \emptyset$}{
                    $ReportError(err)$
                    
                    \textbf{continue} 
                }
   
            }

             \Else{
               $\textit{value} \leftarrow $ \textit{GetSymbolicValue()}
            }  
        
            $\textit{Args.append((value, idx))}$ 
        }
        $\textit{idx += 1}$
    } 
}
\Return $\textit{Args}$
\end{algorithm}
\vspace{-0.1in}

To address this, we present a \textit{data-flow-based heuristic arguments recovery algorithm}.
The EVM manages \textit{Memory} using a free memory pointer, typically designating the offset at position \texttt{0x40} as the pointer to the next available memory location~\cite{sollang, pan2023automated}. 
Based on this heuristic, Algorithm~\ref{algo:extract} presents the overview of how we extract arguments from \textit{Memory}.
Specifically, given a function callsite, we backtrace to find the nearest \texttt{MLOAD} instruction that loads a value from \texttt{0x40} (L1) and consider the loaded value as the $base$ for arguments (L2). Then, we traverse all \texttt{MSTORE} instructions between the \texttt{MLOAD} and the callsite and extract the target position ($ptr$) and the to-be-stored variable ($Var$) (L4 -- L6). To this end, we can extract the offset of the variable by subtracting $base$ from $ptr$ (L7), and calculate the concrete value of the variable through data flow analysis (L8). If this step fails due to complex control flow, a unique symbolic value is assigned to the argument to maintain its positional information (L16). However, due to stack operations and untyped \textit{Memory} accesses in the EVM~\cite{li2024varlifter}, the algorithm may violate our assumptions, resulting in mismatches between the recovered values and their expected types. Therefore, we handle errors based on type checking (L11 -- L14), where we compare the recovered argument types at the same index with those declared in the function declaration. For example, if the type of the argument calculated based on the offset is identified as \texttt{address} with the length of \texttt{0x20}, but should be \texttt{uint256} with the length of \texttt{0x32} in the function declaration, the types are considered mismatched. Then an error is reported, and the recovery process for the argument is skipped. 
Consequently, the remaining function arguments are identified by their index positions and returned (L17 and L19). 




\subsubsection{High-Level Semantics Combining} 
\label{lab:semantics}
Current recovered information does not reveal the specific behavior of function calls. To identify attack intentions, we need to incorporate high-level semantics to extract token-related operations within the contract. We propose two complementary approaches, \textit{i.e.,} 1) leveraging function signature templates and 2) utilizing argument positional analysis. 

As for the first approach, we heuristically consider that attackers frequently interact with Flashloan and DEXes to construct attack chains. To identify such interactions, we utilize function signature templates associated with widely adopted token standards, including ERC20~\cite{erc20}, ERC721~\cite{erc721}, and ERC1155~\cite{erc1155}. Moreover, we extract and validate the semantics of functions from commonly used Flashloan and DEXes services based on total value locked (TVL) and transaction volume~\cite{defillama}, \textit{e.g.,} Aave~\cite{aave}, Pancake~\cite{pancakeswap}, and Uniswap~\cite{uniswap}, by referring to their official documentation.



\begin{figure}[t] 
\centering
\includegraphics[width=\columnwidth]{Figure/sec4/arg-swap-ningyu.pdf} 
\vspace{-0.2in}
\caption{Heuristically infer potential token swap actions.} 
\vspace{-0.1in}
\label{fig:pswap} 
\end{figure}


If no templates are matched, we take another heuristic, \textit{i.e.,} the order of involved tokens would be swapped in price manipulation. Therefore, we adopt an \textit{argument positional analysis} to identify potential token swaps for cases where function signature templates are unavailable, as illustrated in Figure~\ref{fig:pswap}.
Specifically, we consider whether the extracted xFCG has the following features.
There exist two nodes with identical callee addresses and function selectors, while the order of any two address-type variables is reversed. The reverse can happen on the intra-variable (case \textbf{\textit{i}}) or inter-variable (case \textbf{\textit{ii}}) level. We heuristically consider these two addresses to be involved in a token swap.
As a rational attacker, confirming whether obtaining profits is necessary.
We heuristically take the invocation to \texttt{balanceOf()} of a swapped address as necessary in the xFCG.
If both above rules meet in the xFCG, we reckon there exists a token swap of the involved two addresses.

Consequently, within all collected templates as well as the identified token swap behaviors, we have summarized five token action related semantics into consideration, \textit{i.e.,} transfer, flashloan, and liquidity-related operations, whose formal definitions are shown in Figure~\ref{fig:syntax-dsl}:

\begin{itemize}
\item \textbf{Transfer (\textit{Tr}).} Transfer a specified amount ($amt$) of a $token$ from one address ($from$) to another one ($to$).
\item \textbf{Swap token (\textit{ST}.}) In a liquidity pool ($pr$), swap an amount of input token ($tk\_in,\ amt\_in$) to output token ($tk\_out,\ amt\_out$), which is sent to an address ($to$).
\item \textbf{Add liquidity (\textit{AL}).} Against a liquidity pool ($pr$), deposit some token ($amt\_in,\ tk\_in$) to mint some LP token ($amt\_out,\ tk\_out$) to an address ($to$).
\item \textbf{Remove liquidity (\textit{RL}).} Against a liquidity pool ($pr$), burn some LP token ($amt\_in,\ tk\_in$) to transfer some token ($amt\_out,\ tk\_out$) to an address ($to$).
\item \textbf{Flashloan (\textit{FL}).} A flashloan $pr$ lends a specific amount ($amt$) of $token$ to an account ($to$).
\end{itemize}

\subsubsection{Token Flow Graph Construction} 

With the identified semantics, we construct the token flow graph (TFG) based on the xFCG to analyze the contract behavior. It helps guide the identification of critical execution paths in attacks. To formally define TFG, we begin by the following notations:
\begin{itemize}
    \item $\mathcal{N}$, the set of nodes in TFG, representing function calls along with their recovered arguments and semantics.
    \item $\mathcal{E}$, the set of edges in TFG, $\mathcal{E}  \subseteq \mathcal{N} \times \mathcal{N} $, corresponding to the control flow or data dependencies among nodes.
    \item $\mathcal{A}$, the token action related semantics label defined in \S\ref{lab:semantics}.
    \item $\mathcal{T}:\mathcal{N} \rightarrow \mathcal{A}$, a mapping function from nodes to the corresponding semantics labels.
\end{itemize}


Token flow graph is defined as $\mathcal{G} = (\mathcal{N}, \mathcal{E}, \mathcal{A}, \mathcal{T})$.
Figure~\ref{fig:tfg4} shows the generated TFG of the \textit{ULME} incident introduced in \S{\ref{sec:moti_eg}}.
As we can see, we retain the control flow dependency relations in the original xFCG and extend nodes with their corresponding token action related semantics. 
Additionally, we parse the data flow dependencies among nodes, as the solid line in Figure~\ref{fig:tfg4}, representing the result of \texttt{balanceOf} is used for swapped amount.
Integrating data flow analysis enables us to precisely track how token-related data propagates, offering insights into the dependencies and effects of each token action. For instance, this allows us to trace whether a user manipulates the liquidity pool with borrowed funds following a Flashloan.

\begin{figure}[t!]
\centering
\resizebox{\columnwidth}{!}{
\begin{minipage}{\columnwidth}
\begin{alignat}{4}
    &  \langle \mathit{addr}   \rangle	\quad 	&&::\!&&= && \quad  \textbf{addresses}  \nonumber\\
    &  \langle \mathit{arg}   \rangle	\quad 	&&::\!&&= && \quad  \textbf{consts} \ | \ \textbf{vars}   \nonumber\\
    &  \mathit{Op}	\quad 	&&::\!&&= && \quad  \mathit{ST} \ | \ \mathit{AL} \ | \ \mathit{RL}  \nonumber\\
	&  \mathit{transfer}  \quad 	&&::\!&&= &&  \quad \mathit{Tr}\ (\text{token:}  \ \langle \mathit{addr}   \rangle, \ \text{from:} \ \langle \mathit{addr}   \rangle, \ \text{to:} \  \langle \mathit{addr}   \rangle,   \nonumber\\ 
    & && && && \quad \quad \text{amt:} \ \langle \mathit{arg} \rangle) \nonumber \\
    &  \mathit{flashloan}  \quad 	&&::\!&&= &&  \quad \mathit{FL}\ (\text{pr:}  \ \langle \mathit{addr}   \rangle, \ \text{token:} \ \langle \mathit{addr}   \rangle, \ \text{amt:} \  \langle \mathit{arg}   \rangle,   \nonumber\\
    & && && && \quad  \quad \text{to:} \ \langle \mathit{addr} \rangle) \nonumber \\
    &  \mathit{liquidity}  \quad 	&&::\!&&= &&  \quad \mathit{Op}\ (\text{pr:}  \ \langle \mathit{addr}   \rangle, \ \text{tk\_in:} \ \langle \mathit{addr}   \rangle, \ \text{tk\_out:} \  \langle \mathit{addr}   \rangle,   \nonumber\\
    & && && && \quad  \quad \text{amt\_in:} \ \langle \mathit{arg} \rangle,\ \text{amt\_out:} \ \langle \mathit{arg} \rangle,\ \text{to:}  \ \langle \mathit{addr} \rangle ) \nonumber
\end{alignat}
\end{minipage}
}
\vspace{-0.1in}
\caption{The definition of token action related semantics.}
\vspace{-0.1in}
\label{fig:syntax-dsl}
\end{figure}





\begin{figure}[t] 
\centering
\includegraphics[width=0.90\columnwidth]{Figure/sec4/tfg_new.pdf} 
\vspace{-0.1in}
\caption{The xFCG and TFG of the attack contract in the \textit{ULME} incident, where AC denotes the attack contract, and the dotted and solid lines refer to control- and data-flow dependencies, respectively.}
\vspace{-0.1in}
\label{fig:tfg4} 
\end{figure}





\subsection{Anomalous Token Flow Detector}
To improve the detection efficiency, we perform cross-contract analysis as necessary. Thus, we propose a \textit{sensitive path filtering} method to avoid getting stuck in those meaningless and recursive paths.
Moreover, we design a set of formal rules to robustly identify both direct and indirect price manipulation behaviors introduced in \S\ref{sec:pm}.



\subsubsection{Sensitive Path Filtering}
\label{sec:spf}
As stated in \textbf{Challenge 2}, performing cross-contract analysis for every external call is highly time-consuming and contradicts the timeliness required for identifying attack contracts. Therefore, we only initiate cross-contract analysis on those \textit{suspicious sensitive paths}.
Based on previous empirical studies and analysis against DeFi attacks~\cite{wu2023defiranger, su2021evil, zhou2023sok}, a DeFi attack typically consists of three stages, \textit{i.e.,} fund preparation, token exchange, and fund transfer. Hence, when traversing TFG, cross-contract analysis will only be conducted on the corresponding nodes.
For a clear illustration, we define the following notations:
\begin{itemize}
    \item \textit{Entry} and \textit{Exit} represent the starting and ending nodes of TFG, respectively, to facilitate analysis.
    \item \textit{p} = ($\textit{N}_{1}$, $\textit{N}_{2}$, ..., $\textit{N}_{\text{k}}$), a $k$-tuple to represent a path in TFG, where $N_{i} \in \mathcal{N}$. For convenience, we adopt $N \in p$ to represent the node $N$ is included in the path $p$. $\textit{N}_{1} \prec \textit{N}_{2}$ indicates that $\textit{N}_{1}$ is a predecessor of $\textit{N}_{2}$ in a path.
\end{itemize}

We use $\mathcal{S}_{\textit{p}}$ to represent the set of sensitive paths and $\sigma$ denotes the sender address or contract address.
Let \textit{p} = ($\textit{N}_{\text{start}}$, ..., $\textit{N}_{\text{end}}$), $\textit{p} \subseteq \mathcal{S}_{\textit{p}}$ once if any the following conditions holds:

\begin{itemize}
    \item Fund preparation: $\mathcal{T}$($\textit{N}_{\text{start}}$) = $\textit{FL}$(\_,\_,\_,$\sigma$)  $\wedge$ $\textit{N}_{\text{end}}$ = \textit{Exit}.

    \item Token exchange: $\mathcal{T}\text{(}\textit{N}_{\text{start}}\text{)}$ = $\textit{ST}$(\_,\_,\_,\_,\_,\_) $\wedge \mathcal{T}\text{(}\textit{N}_{\text{end}}\text{)}$ = $\textit{ST}$(\_,\_,\_,\_,\_,\_).

    \item Fund transfer: $\textit{N}_{\text{start}}$ = \textit{Entry}$\wedge$$\mathcal{T}$($\textit{N}_{\text{end}}$) = \textit{Tr}(\_,\_,$\sigma$,\_).
    
\end{itemize}

The complexity of the naive implementation of identifying sensitive paths is $O(n^2)$. Thus, to improve efficiency, we only keep the \textit{longest path}. That is, if $\forall N\in p, N\in p'$ and $p' \subseteq \mathcal{S}_{\textit{p}}$, only $p'$ will be kept. The cross-contract analysis will be conducted on external calls in $p'$.
For example, because \texttt{buyMiner()} in Figure~\ref{fig:tfg4} lies on both the fund-preparation and token-exchange sensitive paths, we will perform the cross-contract analysis to the ULME contract.

\subsubsection{Detecting Rules}
\label{subsubsec:detecting rules}
According to the definition of price manipulation, as we illustrated in \S\ref{sec:pm}, we can identify the attack behavior based on the following rules.


\noindent
\textbf{Rule 1: Pump-and-Dump.}
We first identify if there are two \textit{ST} actions interacting with an identical liquidity pool and drain and deposit tokens to potentially manipulate the token price. 
As shown in Rule~\ref{rule:st}, we use the predicate $\textit{P}_{\textit{PD}}$ to represent the path $p$ along with the two related \textit{ST} actions that hold this property.
Note that, $a \rightarrow a'$ indicates there is a data flow dependency relationship from $a$ to $a'$.
\begin{small}
\begin{equation}
\label{rule:st}
\frac{
    \begin{array}{c}
    \textit{N}_{1} \in \textit{p}, \textit{N}_{2} \in \textit{p}, \textit{N}_{1} \prec \textit{N}_{2}, \textit{p} \subseteq \mathcal{S}_{\textit{p}} \\
    \text{$\mathcal{T}$($\textit{N}_{1}$) = \textit{ST}(\textit{pr}, \_, \textit{t}, \_, $a$, \_)}, \text{$\mathcal{T}$($\textit{N}_{2}$) = \textit{ST}(\textit{pr}, \textit{t}, \_, $a'$, \_, $\sigma$)} \\
    a \rightarrow a'
    \end{array}
}{
    \text{$\textit{P}_{\textit{PD}}$(\textit{p}, $\textit{N}_{1}$, $\textit{N}_{2}$)}
}
\end{equation}
\end{small}

\noindent
\textbf{Rule 2\&3: Direct Price Manipulation.}
Based on Rule~\ref{rule:st}, we can formally define how direct price manipulation is identified. As shown in Rule~\ref{rule:dpm1}, we adopt the predicate \textit{DPM} to capture the price of tokens ($t$ and $t'$) of which the liquidity pool ($pr$) is manipulated.
Such direct price manipulation should be completed by taking advantage of flashloan services, where the borrowed tokens will be directly used in $N_1$.

\begin{small}
\begin{equation}
\label{rule:dpm1}
\frac{
    \begin{array}{c}
    \text{$\textit{P}_{\textit{PD}}$(\textit{p}, $\textit{N}_{1}$, $N_2$), $\textit{N}_{0}$ $\in$ \textit{p}, $\textit{N}_{0}$ $\prec$ $\textit{N}_{1}$} \\
    \text{$\mathcal{T}$($\textit{N}_{0}$) = \textit{FL}(\textit{t}, \_, $\sigma$, $a$)}, \text{$\mathcal{T}$($\textit{N}_{1}$) = \textit{ST}(\textit{pr}, \textit{t}, \textit{t'}, $a'$, \_, $\sigma$)} \\
    a \rightarrow a'
    \end{array}
}{
    \text{\textit{DPM}(\textit{pr}, \textit{t}, \textit{t'})}
}
\end{equation}
\end{small}

Except for Rule~\ref{rule:dpm1}, Rule~\ref{rule:dpm2} also demonstrates a type of direct price manipulation. Their distinction exists in whether a victim is involved (the entity shown in Figure~\ref{fig:elephant} in \S\ref{sec:dpm}).
If a victim exists, there will be another action between the two in $P_{PD}$. As shown in Rule~\ref{rule:dpm2}, the victim should be involved in a token swap between itself and the pool or add / remove liquidity to / from the pool to manipulate the token price.
Finally, the $DPM$ predicate records the victim address ($vc$) and both involved tokens.
\begin{small}
\begin{equation}
\label{rule:dpm2}
\frac{
    \begin{array}{c}
    \text{$\textit{P}_{\textit{PD}}$(\textit{p}, $\textit{N}_{1}$, $\textit{N}_{3}$), $\textit{N}_{2}$ $\in$ \textit{p}, $\textit{N}_{1}$ $\prec$ $\textit{N}_{2}$ $\prec$ $\textit{N}_{3}$ } \\
    \text{$\mathcal{T}$($\textit{N}_{1}$) = \textit{ST}(\textit{pr}, \textit{t}, \textit{t'}, \_, $a$, \_)} \\
    \text{$\mathcal{T}$($\textit{N}_{2}$)=\textit{Tr}(\textit{t}, \textit{vc}, \textit{pr},\_)$\vee$\textit{AL}(\textit{pr},\textit{t},\_,\_,\_,\textit{vc})$\vee$\textit{RL}(\textit{pr},\_,\textit{t'},\_,\_,\textit{vc})}
    \end{array}
}{
    \text{\textit{DPM}(\textit{vc}, \textit{t}, \textit{t'})}
}
\end{equation}
\end{small}

\noindent
\textbf{Rule 4: Indirect Price Manipulation.}
As for indirect price manipulation, we adopt $IPM$ to capture its characteristics, whose formal definition is shown in Rule~\ref{rule:ipm1}.
As we can see, it looks similar to Rule~\ref{rule:dpm2}. The difference is located on whether the price fluctuation is caused by the victim address ($vc$) or the attacker itself ($\sigma$). 
\begin{small}
\begin{equation}
\label{rule:ipm1}
\frac{
    \begin{array}{c}
    \text{$\textit{P}_{\textit{PD}}$(\textit{p}, $\textit{N}_{1}$, $\textit{N}_{3}$), $\textit{N}_{2}$ $\in$ \textit{p}, $\textit{N}_{1}$ $\prec$ $\textit{N}_{2}$ $\prec$ $\textit{N}_{3}$ } \\
    \text{$\mathcal{T}$($\textit{N}_{1}$) = \textit{ST}(\textit{pr}, \textit{t}, \textit{t'}, \_, $a$, \_)} \\
    \text{$\mathcal{T}$($\textit{N}_{2}$)=\textit{Tr}(\_, \textit{vc}, $\sigma$,\_)$\vee$\textit{AL}(\textit{vc},\textit{t},\_,\_,\_,$\sigma$)$\vee$\textit{RL}(\textit{vc},\_,\textit{t'},\_,\_,$\sigma$)}
    \end{array}
}{
    \text{\textit{IPM}(\textit{vc}, \textit{t}, \textit{t'})}
}
\end{equation}
\end{small}


