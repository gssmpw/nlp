\section{Code implementation of \decomp}
\label{app:code_impl}
\begin{tcolorbox}[colback=white, title=Python implementation of \decomp]
    \begin{lstlisting}
def dynamic_decomposition(problem, model, reward_model, split_str, complete_solution, fraction, solution_budget, split_metric, stop_threshold=-float("inf"), stop_sum_score=1.0, stop_if_solved=False, ):
    """
    Decomposes the solution using a dynamic binary search approach

    Args:
        problem (Problem): The problem to solve
        model (Model): The model to use for generation
        reward_model (function): The reward model to use for scoring
        split_str (function): The function to use for splitting a string
        complete_solution (function): The function to use for completing a solution
        fraction (float): The fraction to split the string
        solution_budget (int): The maximum number of solutions to generate
        split_metric (function): The metric to use for splitting
        stop_threshold (float): The threshold to stop splitting
        stop_sum_score (float): The sum score to stop generating completions
        stop_if_solved (bool): Whether to stop if the problem is solved
    """

    # Initialize results and decomposition steps
    decomp_return = {
        "generated_solutions": [],
        "decomposition": []
    }

    while len(decomp_return["generated_solutions"]) < solution_budget:
        # Combine all previous steps into an intermediate solution
        intermediate_solution = "".join([step["step_str"] for step in decomp_return["decomposition"]])
        new_scores = []
        best_solution = None
        best_completion = None
        best_score = -float("inf")
        sum_score = 0.0

        # 1) Generate completions until we generate enough samples to estimate the split metric
        while sum_score < stop_sum_score:
            proposed_completion = complete_solution(problem, intermediate_solution, model)
            proposed_solution = intermediate_solution + proposed_completion
            decomp_return["generated_solutions"].append(proposed_solution)

            # Update scores
            proposed_score = reward_model(proposed_solution)
            new_scores.append(proposed_score)
            sum_score += proposed_score

            # Track the best solution
            if proposed_score > best_score:
                best_solution = proposed_solution
                best_score = proposed_score
                best_completion = proposed_completion

            # Stop early if problem is solved
            if stop_if_solved and proposed_score >= 1.0:
                decomp_return["decomposition"].append({"step_str": proposed_completion})
                return decomp_return

        new_metric = split_metric(new_scores)
        last_metric = decomp_return["decomposition"][-1]["metric"] if decomp_return["decomposition"] else None

        # Determine the split target. We always split the step with the highest metric
        is_split_new_step = last_metric is None or new_metric >= last_metric
        split_target = decomp_return["decomposition"][-1]["step_str"] if not is_split_new_step else best_completion

        # 3) Attempt to split the target
        split_result = split_str(split_target, fraction)
        if not split_result: # If we can't split the target, we're done
            decomp_return["decomposition"].append({"step_str": best_completion, "metric": new_metric})
            return decomp_return

        # Update decomposition based on split
        part1, part2 = split_result
        if is_split_new_step:
            decomp_return["decomposition"].append({"step_str": part1, "metric": new_metric})
            # Stopping condition based on threshold
            if new_metric < stop_threshold: 
                decomp_return["decomposition"].append({"step_str": part2})
                return decomp_return
        else:
            decomp_return["decomposition"][-1] = {"step_str": part1, "metric": last_metric}

    return decomp_return
\end{lstlisting}
\end{tcolorbox}
