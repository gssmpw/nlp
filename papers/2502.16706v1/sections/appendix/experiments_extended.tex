\section{Experimental results extended}
\subsection{APPS}
\label{sec:apps_extended}
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\linewidth]{graphics/frequency_of_sampling_different_steps.pdf}
    \caption{\textbf{Sampling frequency of each step averaged over the problems on APPS with gpt-4o-mini.} \decomp seems to have a preferences for spending more compute on earlier found steps.}
    \label{fig:sampling_frequency}
\end{figure}

% tofill

\newpage
\subsection{Additional examples}
Below is another computed decomposition for the same problem as the one shown in the main text:

\begin{quote}
    \textcolor{medium}{Let \( x \) be the length and \( y \) be the width of the rectangle. Since the perimeter is 24 inches, we have \( 2x + 2y = 24 \Rightarrow x + y = 12.\)} 
    \textcolor{high}{Therefore,}
    \textcolor{low}{we must maximize the area \( xy \) subject to this constraint.}

    \textcolor{low}{We use the method of Lagrange multipliers. The Lagrangian is}
    \[
    \textcolor{low}{\mathcal{L}(x, y, \lambda) = xy - \lambda(x + y - 12).}
    \]
    \textcolor{low}{We differentiate with respect to \( x, y, \) and \( \lambda \) to obtain}
    \[
    \textcolor{low}{\frac{\partial \mathcal{L}}{\partial x} = y - \lambda = 0, \qquad \frac{\partial \mathcal{L}}{\partial y} = x - \lambda = 0, \qquad \frac{\partial \mathcal{L}}{\partial \lambda} = x + y - 12 = 0.}
    \]
    \textcolor{low}{We find that \( x = y = \lambda \), so \( x = y = \frac{12}{2} = 6. \) Therefore, the maximum area of the rectangle is \( 6 \cdot 6 = \boxed{36}.\)}
\end{quote}

\newpage
\subsection{APPS with self-generated validation tests}
\label{sec:val_tests}
% We include more details on our experiments on APPS with self-generated validation tests below. All methods used the same set of self-generated validation tests to ensure fairness of comparison. Around 5-10 validation tests were generated, with the specific number decided by the LLM. We tested a 100 problem subset of APPS (first 100 problems). Samples were generated until either the sample budget was exhausted or the correct solution was found. We report the token and samples required to encounter the correct solution. Solvers only know how many of the validation tests passed during the solving process. 
We examine \decomp performance on APPS when using self-generated validation tests. All methods utilized the same set of self-generated validation tests to ensure fair comparisons. Each problem received 5-10 validation tests, with the exact number determined dynamically by the LLM. We evaluated a subset of 100 APPS problems, generating samples until the sample budget was exhausted or a correct solution was found.

\Cref{fig:val_token} illustrates the Pass@token scaling curve, showing that \decomp maintains strong scaling performance in this setting, though at a slightly lower rate compared to ground-truth verification.

\Cref{fig:val_actualpart} and \Cref{fig:val_plannedpart} compare actual and planned partition frequencies, respectively. The results indicate that \decomp continues to make structured decompositions even with self-generated validation, preserving its efficiency.

The mean reward per step, shown in \Cref{fig:val_rewardstep}, follows a similar trend as in previous experiments, reinforcing that \decomp effectively allocates compute resources for iterative refinement.

Lastly, \Cref{fig:val_stdstep} demonstrates that \decomp maintains lower standard deviations in performance, indicating stable quality improvements across steps.


\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\linewidth]{graphics/val_token_scaling.pdf}
    \caption{\textbf{Token level comparison of different decomposition methods on APPS with gpt-4o-mini and self-generated validation tests.} \decomp still scales better than other methods in this setting, albeit at a lower rate.}
    \label{fig:val_token}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\linewidth]{graphics/val_actualpart.pdf}
    \caption{\textbf{Actual partition frequency of different decomposition methods on APPS with gpt-4o-mini and self-generated validation tests.}}
    \label{fig:val_actualpart}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\linewidth]{graphics/val_plannedpart.pdf}
    \caption{\textbf{Planned partition frequency of different decomposition methods on APPS with gpt-4o-mini and self-generated validation tests.}}
    \label{fig:val_plannedpart}
\end{figure}


\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\linewidth]{graphics/val_rewardstep.pdf}
    \caption{\textbf{Mean reward per step of different decomposition methods on APPS with gpt-4o-mini and self-generated validation tests.}}
    \label{fig:val_rewardstep}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\linewidth]{graphics/val_stdstep.pdf}
    \caption{\textbf{Mean standard deviation different decomposition methods on APPS with gpt-4o-mini and self-generated validation tests.}}
    \label{fig:val_stdstep}
\end{figure}


\newpage
\subsection{MATH500}
\label{sec:math500_extended}

Completions for MATH500 include both the reasoning steps and the final answer. Since MATH500 contains more problems than APPS200 and MATH problems tend to be relatively easier, solution quality saturates quickly. Therefore, we use a lower sample budget of 10 for these experiments. 

\Cref{fig:math_passk} presents the Pass@k performance for different decomposition methods on MATH500. We observe that all decomposition-based approaches achieve similar Pass@k performance, consistently outperforming BoN. This indicates that the structured nature of MATH problems allows multiple decomposition strategies to be effective.

Despite similar Pass@k results, the true advantage of \decomp lies in its token efficiency, as shown in \Cref{fig:math_token}. \decomp significantly reduces the number of tokens required to reach correct solutions compared to alternative methods, demonstrating its ability to allocate computational effort efficiently in mathematical reasoning tasks.

Additionally, we analyze the partitioning behavior of \decomp on MATH500. \Cref{fig:math_actualpart} illustrates the actual partition frequency for different decomposition methods. The planned partitioning behavior, shown in \Cref{fig:math_plannedpart}, further highlights how \decomp effectively balances exploration and refinement.

Finally, we present the mean standard deviation per step in \Cref{fig:math_stdstep}. Lower variance suggests that \decomp produces more stable and reliable decompositions over multiple runs, reinforcing its robustness in both mathematical and program synthesis domains.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\linewidth]{graphics/math_passk.pdf}
    \caption{\textbf{Pass@k performance comparison for different decomposition methods on MATH500. \decomp consistently outperforms BoN across different sampling budgets.}}
    \label{fig:math_passk}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\linewidth]{graphics/math_actual.pdf}
    \caption{\textbf{Observed partition frequency of different decomposition methods on MATH500. \decomp effectively segments problems into meaningful subcomponents.}}
    \label{fig:math_actualpart}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\linewidth]{graphics/math_planned.pdf}
    \caption{\textbf{Planned partitioning strategy of different decomposition methods on MATH500. \decompâ€™s structured approach leads to more efficient problem breakdowns.}}
    \label{fig:math_plannedpart}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\linewidth]{graphics/math_std.pdf}
    \caption{\textbf{Mean standard deviation per step for different decomposition methods on MATH500. Lower variance in \decomp suggests more stable and reliable problem-solving steps.}}
    \label{fig:math_stdstep}
\end{figure}

% \subsection{MATH500}
% \label{sec:math500_extended}
% Completions for MATH500 include both the reasoning and the final answer. 
% Since MATH500 contains more problems than APPS200, and MATH problems tend to be easier and saturate quickly, we sampled at a lower budget of 10 for math problems. We see from Fig. \ref{fig:math_passk}  that while the pass@k performance of all decomposition methods tends to be similar (and outperforms BoN consistently), the real advantage of \decomp lies it its token efficiency as shown in Fig. \ref{fig:math_token}. 
% \subsection{MATH500}
% \label{sec:math500_extended}

% Completions for MATH500 include both the reasoning steps and the final answer. Since MATH500 contains more problems than APPS200 and MATH problems tend to be relatively easier, solution quality saturates quickly. Therefore, we use a lower sample budget of 10 for these experiments. 

% \Cref{fig:math_passk} presents the Pass@k performance for different decomposition methods on MATH500. We observe that all decomposition-based approaches achieve similar Pass@k performance, consistently outperforming BoN. This indicates that the structured nature of MATH problems allows multiple decomposition strategies to be effective.

% Despite similar Pass@k results, the true advantage of \decomp lies in its token efficiency, as shown in \Cref{fig:math_token}. \decomp significantly reduces the number of tokens required to reach correct solutions compared to alternative methods, demonstrating its ability to allocate computational effort efficiently in mathematical reasoning tasks.

% Additionally, we analyze the partitioning behavior of \decomp on the LiveCodeBench dataset. \Cref{fig:math_actualpart} illustrates the actual partition frequency across different decomposition methods. The planned partitioning behavior, shown in \Cref{fig:math_plannedpart}, further highlights how \decomp effectively balances exploration and refinement.

% Finally, we present the mean standard deviation per step in \Cref{fig:math_stdstep}. Lower variance suggests that \decomp produces more stable and reliable decompositions over multiple runs, reinforcing its robustness in both mathematical and program synthesis domains.


% \begin{figure}[ht]
%     \centering
%     \includegraphics[width=0.5\linewidth]{graphics/math_passk.pdf}
%     \caption{\textbf{Pass@k comparison of different decomposition methods on MATH500 competition level.}}
%     \label{fig:math_passk}
% \end{figure}

% \begin{figure}[ht]
%     \centering
%     \includegraphics[width=0.5\linewidth]{graphics/math_actual.pdf}
%     \caption{\textbf{Actual partition frequency of different decomposition methods on LiveCodeBench with gpt-4o-mini.}}
%     \label{fig:math_actualpart}
% \end{figure}

% \begin{figure}[ht]
%     \centering
%     \includegraphics[width=0.5\linewidth]{graphics/math_planned.pdf}
%     \caption{\textbf{Planned partition frequency of different decomposition methods on LiveCodeBench with gpt-4o-mini.}}
%     \label{fig:math_actualpart}
% \end{figure}

% \begin{figure}[ht]
%     \centering
%     \includegraphics[width=0.5\linewidth]{graphics/math_std.pdf}
%     \caption{\textbf{Mean standard deviation different decomposition methods on LiveCodeBench with gpt-4o-mini.}}
%     \label{fig:math_stdstep}
% \end{figure}


% \begin{figure}[ht]
%     \centering
%     \includegraphics[width=0.5\linewidth]{graphics/live_mean.pdf}
%     \caption{\textbf{Mean reward per step of different decomposition methods on LiveCodeBench with gpt-4o-mini.}}
%     \label{fig:live_rewardstep}
% \end{figure}

\newpage
\subsection{LiveCodeBench}
\label{sec:livecodebench_extended}

We evaluate \decomp on LiveCodeBench, a benchmark designed for code generation tasks with a focus on real-world software development challenges. LiveCodeBench presents a unique set of problems requiring both reasoning and structured decomposition, making it a suitable testbed for evaluating \decomp's ability to refine and improve intermediate steps.

\Cref{fig:live_passk} shows the Pass@k comparison of different decomposition methods on LiveCodeBench. \decomp consistently scales better than other decomposition methods, highlighting its ability to refine intermediate steps more effectively in complex coding scenarios.

\Cref{fig:live_actualpart} illustrates the observed partition frequency of different decomposition methods. The structured approach of \decomp results in well-balanced decomposition across steps, reducing unnecessary partitioning while maintaining sufficient granularity for improved solution refinement.

\Cref{fig:live_plannedpart} displays the planned partition frequency across methods. \decomp dynamically determines the most effective partitions based on the evolving problem state, leading to more targeted and efficient decompositions.

Finally, \Cref{fig:live_stdstep} presents the mean standard deviation per step across decomposition methods. Lower variance in \decomp suggests that it produces more stable and reliable decompositions, reinforcing its robustness for solving LiveCodeBench problems.

\begin{figure}
    \centering
    \includegraphics[width=0.5\linewidth]{graphics/live_passk.pdf}
    \caption{\textbf{Pass@k performance comparison for different decomposition methods on LiveCodeBench.} \decomp consistently outperforms other methods in structured problem refinement.}
    \label{fig:live_passk}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\linewidth]{graphics/live_actual.pdf}
    \caption{\textbf{Observed partition frequency of different decomposition methods on LiveCodeBench.} \decomp effectively balances problem segmentation while avoiding excessive partitioning.}
    \label{fig:live_actualpart}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\linewidth]{graphics/live_planned.pdf}
    \caption{\textbf{Planned partitioning strategy of different decomposition methods on LiveCodeBench.} \decomp dynamically adapts its partitioning to optimize search efficiency.}
    \label{fig:live_plannedpart}
\end{figure}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\linewidth]{graphics/live_std.pdf}
    \caption{\textbf{Mean standard deviation per step for different decomposition methods on LiveCodeBench.} Lower variance in \decomp suggests more stable and reliable problem-solving steps.}
    \label{fig:live_stdstep}
\end{figure}


% \newpage
% \subsection{Livecodebench}
% \label{sec:livecodebench_extended}

% \begin{figure}
%     \centering
%     \includegraphics[width=0.5\linewidth]{graphics/live_passk.pdf}
%     \caption{\textbf{Pass@k comparison of different decomposition methods on LiveCodeBench.} \decomp consistently scales better than other decomposition methods.}
%     \label{fig:live_passk}
% \end{figure}

% \begin{figure}[ht]
%     \centering
%     \includegraphics[width=0.5\linewidth]{graphics/live_actual.pdf}
%     \caption{\textbf{Actual partition frequency of different decomposition methods on LiveCodeBench with gpt-4o-mini.}}
%     \label{fig:live_actualpart}
% \end{figure}

% \begin{figure}[ht]
%     \centering
%     \includegraphics[width=0.5\linewidth]{graphics/live_planned.pdf}
%     \caption{\textbf{Planned partition frequency of different decomposition methods on LiveCodeBench with gpt-4o-mini.}}
%     \label{fig:live_actualpart}
% \end{figure}


% \begin{figure}[ht]
%     \centering
%     \includegraphics[width=0.5\linewidth]{graphics/live_std.pdf}
%     \caption{\textbf{Mean standard deviation different decomposition methods on LiveCodeBench with gpt-4o-mini.}}
%     \label{fig:live_stdstep}
% \end{figure}


% \begin{figure}[ht]
%     \centering
%     \includegraphics[width=0.5\linewidth]{graphics/live_mean.pdf}
%     \caption{\textbf{Mean reward per step of different decomposition methods on LiveCodeBench with gpt-4o-mini.}}
%     \label{fig:live_rewardstep}
% \end{figure}








