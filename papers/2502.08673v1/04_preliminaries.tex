\vspace{-0.2cm}
\section{Preliminaries}
\subsection{SAT Sampling} \label{sec:sat-sampling}

SAT sampling involves drawing solutions from the solution space defined by a set of logical constraints expressed in CNF. In SAT sampling applications, Boolean expressions are typically represented in higher-level logical formats before being converted into CNF \cite{Biere2009SAT, Barrett2013SAT}. These formats include propositional logic with operators like AND, OR, NOT, implications, and equivalences, as well as more complex structures such as if-then-else conditions, arithmetic expressions, and bit-level operations. In hardware verification, Boolean expressions can take the form of circuit representations, such as And-Inverter Graphs (AIGs) or Binary Decision Diagrams (BDDs). In cryptographic contexts, Algebraic Normal Form (ANF) is sometimes used. These representations are transformed into CNF through logical simplifications, flattening complex structures, and applying techniques like Tseitin transformation \cite{tseitin1983complexity}. This transformation preserves the satisfiability of the original formula while introducing auxiliary variables when needed. The conversion to CNF provides SAT solvers with a standardized problem representation that retains the essential constraints of the original problem.



% As discussed in Section \ref{sec:sat-sampling}, Boolean expressions are typically expressed in more abstract logical formats before being converted to CNF through techniques like logical simplifications and transformations such as the Tseitin transformation. This transformation preserves the satisfiability of the original formula while introducing auxiliary variables when needed. The conversion to CNF provides SAT solvers with a standardized problem representation that retains the essential constraints of the original problem.



A CNF consists of a conjunction of clauses (i.e., an AND of multiple clauses), where each clause consists of a disjunction of literals (i.e., an OR of literals). Literals refer to Boolean variables or their negations. In SAT solving, the goal is to determine if there exists an assignment of binary values to the variables in a given CNF, representing a Boolean expression, such that all clauses evaluate to $1$. SAT sampling adds a probabilistic layer to this process. Instead of seeking just one solution for satisfiable instances, the aim is to produce multiple solutions or samples from the complete set of possible solutions. Generating samples from SAT instances plays a crucial role in design verification, testing, and synthesis, with significant applications in constrained-random verification (CRV) \cite{Kitchen2007crv}.

A common method for SAT sampling involves using SAT solvers with built-in sampling functionality. These solvers are designed not only to determine the satisfiability of a Boolean formula but also to extract solutions from the solution space. Efficient SAT solving techniques include backtracking algorithms like the Davis-Putnam-Logemann-Loveland (DPLL) algorithm \cite{Davis1962DPLL}, stochastic local search methods such as WalkSAT \cite{selman1993local}, and CDCL algorithms \cite{Silva1996CDCL, silva2021CDCL}. In recent years, several approaches have been developed for SAT sampling, including randomized algorithms, Markov chain Monte Carlo (MCMC) techniques, and heuristic-based sampling methods \cite{Impagliazzo2017RandomSAT, kitchen2009markov, Soos2020unigen3, dutra2018quicksampler, Golia2021cmsgen}. These methods typically explore the solution space iteratively, selecting candidate solutions based on predefined criteria and stochastically deciding whether to accept or reject them.

SAT solvers and samplers have been optimized over decades to efficiently handle problems in CNF. CNF is well-suited for SAT-solving algorithms like DPLL and CDCL. These algorithms take advantage of CNF's structure to systematically explore possible truth assignments, detect conflicts early, and prune the search space efficiently. By focusing on individual clauses, which define specific constraints on solutions, the use of CNF enables solvers to address highly complex problems in a manageable way.





\subsection{Multi-Output Regression Task}
A multi-output regression task, in the context of example generation, refers to the process of creating data points (or ``examples'') that serve as input-output pairs for a given model \cite{Ardakani2024diffsampler}. The main goal is to generate inputs such that they satisfy multiple specific output constraints simultaneously. Various methods, such as linear regression, neural networks or probabilistic representations of the relationships between inputs and outputs, can be used to construct such a model. The inputs to the model are adjusted in an iterative manner to minimize the difference between the predicted and actual output values. One common way to measure this difference is by using metrics like mean squared error (MSE) or $\ell_2$ loss.

