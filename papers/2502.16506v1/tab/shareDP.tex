\begin{algorithm}[H]
    \caption{ShareDP}
    \label{alg:shareDP}
    \KwIn{Set of $k$DP queries $Q$, original graph $G$, integer $k$}
    \KwOut{$k$ disjoint paths for each query $q \in Q$}
    
    Initialize \{$P$\}: Set $prehops$, $nexthops$, $isPinner$ to $\emptyset$, and initialize $isS$ and $isT$ according to the definition.\textit{\color{gray}// Initialize the merged split-graph. See Sec.~\ref{sec:approach_details}.} \\
    \ForEach{$i$ $\in$ $1, \ldots, k$ \textit{\color{blue}/* Find the $i$th disjoint paths */}} 
    {
        \textit{\color{blue}/* Initialization for bidirectional BFS */} \\
        Initialize $s$-$seen$, $s$-$queue$, $s$-$nextqueue$ for forward BFS. Backward BFS uses analogous structures (e.g., $t$-$queue$). \\
        Initialize $joint$, $pred$, and $succ$ \textit{\color{gray}// $joint$: meeting points of forward and backward searches; $pred$/$succ$: path predecessors/successors.} \\
        $undone = Q$ \textit{\color{gray}// Queries that have not yet found the $i$th path.} \\
        
        \ForEach{$q \in Q$} 
        {
            $s$-$seen_{q.s} \cup= \{q\}$; $s$-$queue_{q.s} \cup= \{q\}$ \textit{\color{gray}// Mark $q.s$ as visited and enqueue if for forward search. Initialization for backward search is similar.} \\
        }

        \textit{\color{blue}/* Bidirectional BFS */} \\
        \While{$undone \neq \emptyset$ and $s$-$queue$ and $t$-$queue$ are not empty} 
        {
            \textit{\color{gray}/* Forward search */} \\
            \ForEach{\{$v$, $B$\} $\in s$-$queue$ \textit{\color{gray} // $B$ is a set of $k$DPs that need to expand $v$}}
            {
                ForwardExpandFrontier($v$, $B$, $G$, \{$P$\}) \textit{\color{gray}// See Alg.~\ref{alg:expandFrontier}.}
                % $B = B \setminus undone$ \textit{\color{gray}// Skip queries that have already found the $i$th path.} \\
                % \ForEach{\{$u$, $B'$\} $\in$ GetOutNeighbors($v$, $B$, $G$, \{$P$\}) \textit{\color{gray}// See Alg.~\ref{alg:get_nbr}.}} 
                % {
                %         $D = B' \setminus s$-$seen_u$ \textit{\color{gray}// Exclude queries that have already visited $u$.} \\
                %         $s$-$seen_u \cup= D$; $pred_{u, v} \cup= D$ \textit{\color{gray}// Mark $u$ as visited for $D$ and record $v$ as the predecessor.} \\
                %         $meet = D \cap t$-$seen_u$ \textit{\color{gray}// Queries that forward search and backward search meet at $u$.} \\
                %         $joint_u \cup= meet$; $undone \setminus= meet$ \textit{\color{gray}// Mark queries as completed.} \\
                %         $s$-$nextqueue_u \cup= (D \setminus meet)$ \textit{\color{gray}// Add $u$ to the queue for remaining queries.} \\
                % }
            }
            Swap $s$-$queue$ and $s$-$nextqueue$ \\
            \textit{\color{gray}/* Backward search proceeds similarly to forward search. */}
        }

        \textit{\color{blue}/* Construct paths and update the merged split-graph */} \\
        Construct paths from $undone$, $joint$, $pred$, and $succ$. \\
        Update $prehops$, $nexthops$, and $isPinner$.\textit{\color{gray}// Adjust paths similar to flow augmentation in max-flow problem. For example, if trying to add edge $\langle u, v\rangle$ for queries $B$, first let $cancel = prehops_{u, v} \cap B$ (edge $\langle v, u\rangle$), then remove $cancel$ from $prehops_{u, v}$ and add $(B \setminus cancel)$ to $prehops_{v, u}$. Similarly, update $nexthops$.} \\
    }
    
    Extract $k$ disjoint paths for each $q \in Q$ from $isS$ and $nexthops$ (or $isT$ and $prehops$) and return the results. \\
\end{algorithm}