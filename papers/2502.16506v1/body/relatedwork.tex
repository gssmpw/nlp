\section{Related Work}
\label{sec:relatedwork}

% \vspace{-5pt}
\subsection{$k$DP problems}\label{sec:related_kdp}
\textbf{Single-query.} 
Approaches to single-query $k$DP can be divided into \emph{flow-augmenting path-based methods}~\cite{baseline_moreverbose, baselineOnlySplitP1, baseline1step2} and \emph{dissimilar path-based methods}~\cite{Penalty, dissimilarity_topk1, SCB}.
Flow-augmenting methods use \emph{split-graphs}~\cite{baseline_moreverbose, baseline1step2}, achieving linear time complexity (Sec.~\ref{sec:splitgraph}).
Dissimilar path-based methods, which define dissimilarity as disjointness, include \emph{penalty-based}, \emph{dissimilarity-based}, and \emph{plateaus-based} methods~\cite{Penalty, SCB}.
Plateaus-based methods, however, may fail to find solutions, as they depend on shared branches between two shortest spanning trees, which may not present in all $k$DP solutions. Thus, we exclude them from comparison.

Penalty-based and dissimilarity-based methods reduce to path enumeration with disjointness constraints, either by \emph{(1)} marking vertices in previous paths as inaccessible or by \emph{(2)}  verifying disjointness before adding new paths. However, both lead to factorial time complexity in the worst case.
For instance, if a path $p$ is not part of any solution, all computations involving $p$ in the result set will fail to yield a solution. 
    Consequently, alternative path orderings must be attempted (e.g., adding $p_1$ first, then $p_2$, and so on).
    In the worst case, every possible path ordering must be evaluated, leading to factorial time complexity.
We may also \emph{(3)} first identify all paths and then select a subset of $k$ disjoint paths, 
    but this also faces the path-ordering challenge, resulting in the same factorial complexity.
Our experiments (Sec.~\ref{sec:experiment_time}) show these methods time out on large graphs.

\emph{$k$ shortest dissimilar path finding}~\cite{dissimilarity_topk1} can solve $k$DP but is slower due to path enumeration in ascending length order, as noted in~\cite{SCB}. Thus, we exclude them from comparison.

\textbf{Single-source.} 
The problem of finding $k$ independent spanning trees~\cite{2009BRTree, four_independent_spanning, IST_survey} is related to $k$DP, where paths in different spanning trees are disjoint. While this provides solutions for vertex pairs formed by the root and other vertices, the problem remains an open challenge for $k>4$. For $k\le 4$, this method was over 10 times slower than our approach in our experiments (Sec.~\ref{sec:experiment_time}).

To our knowledge, no prior work addresses the \texttt{batch-$k$DP} problem.

\subsection{Batch Query Processing} \label{sec:related_batch}
Batch query processing has been studied for other graph problems~\cite{BatchEnum, tods21subgraphiso, icde20shortestpath, msbfs}, focusing on queries within the same graph.
\cite{BatchEnum} explores batch simple path enumeration, leveraging shared computations and caching results. \cite{tods21subgraphiso} investigates batch subgraph isomorphism with a unified join plan. \cite{icde20shortestpath} implements caching and query decomposition for shortest path queries. Batch BFS queries~\cite{msbfs} exploit overlaps among frontiers across concurrent BFS runs.
In contrast, our problem involves different $k$DP queries on different graphs (split-graphs), requiring unification of these graphs, which remains unexplored in the literature.
