% 先压缩实验，然后方法
% 方法能不能，有个overview就差不多呢
%!TEX root = main.tex
\section{ShareDP} \label{sec:approach_algo}

Given a set of \texttt{$k$DP} queries, the key improvement over the baseline in our approach lies in sharing computations across queries. 
We demonstrate this with the indochina-2004 dataset (statistics in Tab.~\ref{tab:datasets}). 
In both the first and last iterations (i.e., finding the first and $k$-th disjoint paths), exploration of over 60\% of the vertices are shared across levels, and in more than half of the levels, over 80\% are shared. 
This illustrates the potential for shared exploration in the batch-$k$DP problem. Based on this, we propose the \texttt{ShareDP} algorithm.

% \vspace{-10pt}
\subsection{Algorithm Overview} \label{sec:approach_overview}

The \texttt{ShareDP} framework (Fig.~\ref{fig:shareDP_overview}) takes as input a graph \( G \), a set of $k$DP queries \( Q \), and an integer \( k \). 
In each iteration, the algorithm identifies one path for each query. 
In the \( i \)-th iteration, the algorithm operates on a merged split-graph \( G' \) , 
	conceptually the union of individual split-graphs for each query (top half of Fig.~\ref{fig:shareDP_overview}(a)). 
	\( G' \) is represented implicitly using the current result sets of all queries (bottom half of Fig.~\ref{fig:shareDP_overview}(a)). 
During path-finding, traversals are combined across queries, 
	conceptually visualized as collapsing multiple planes where the traversal for each query flows into a unified plane (top half of Fig.~\ref{fig:shareDP_overview}(b)).
	Common operations are consolidated into a merged step by tagging data structures with query sets (bottom half of Fig.~\ref{fig:shareDP_overview}(b)).  
Paths identified in each iteration update the result sets, which in turn update \( G' \) for the next iteration (bottom of Fig.~\ref{fig:shareDP_overview}(b)). 

% \vspace{-15pt}
\begin{figure}
    \centering
    % \resizebox{\linewidth}{!}
    {\includegraphics[width=\linewidth]{pic/idea/shareDP}}
    % \vspace{-10pt}
        \caption{Framework of \texttt{ShareDP}. Colored balls (e.g., the blue ball for query \( q_0 \)) represent queries. 
	Each iteration identifies a path for each query 
    by conducting a combined search on a merged split-graph $G'$.
        % enabling the sharing of traversals and operations.
See Sec.~\ref{sec:approach_overview} for details.}
    \label{fig:shareDP_overview}
\end{figure}
% \vspace{-10pt}

% \vspace{-10pt}
\subsection{Algorithm Details} \label{sec:approach_details}
% \subsection{Merge the Split-Graphs} \label{sec:approach_topo}

\emph{Merge the Split-Graphs.} We merge the split-graphs from the perspective of a vertex \( v \), focusing on its out-neighbors (in-neighbors analysis is symmetric). 
They are derived from the original graph’s out-neighbors, reversed edges, and vertex splitting (Sec.~\ref{sec:splitgraph}). 
To manage edge reversals and vertex positions, we define \( nexthops \), \( prehops \), \( isPinner \), \( isS \), and \( isT \), which also represent the current result sets $\{P\}$. 
Specifically, 
    \( prehops_{u,v} \) represents queries where \( v \) is \( u \)'s $prehop$; 
    \( isPinner_v \), \( isS_v \), and \( isT_v \) represent the set of $k$DP queries where \( v \) is \( P \)-inner, \( s \), and \( t \), respectively.
With these definitions, given a query set \( B \) and a vertex \( v \), the procedure for acquiring \( v \)'s out-neighbors is shown in Alg.~\ref{alg:get_nbr}. 
The merging process uses the result sets \(\{P\}\) from each query \( q \in B \) to determine neighbors in the merged split-graph \( G' \), simplifying neighbor retrieval and improving efficiency compared to constructing a supergraph (Sec.~\ref{sec:experiment_opt}).

\input{tab/getNeighbors}

% \subsection{Combine Traversals in the Merged Split-Graph} \label{sec:approach_algorithm_list}
\emph{Combine Traversals.}
% To get a picture of how the traversals get merged in the merged split-graph $G'$, assume that each $k$DP runs separately.
% Traversals start from their source vertices, and may meet in certain regions. Then they proceed together until they diverge.
The ShareDP algorithm combine the traversals by tagging data structures with query sets. 
While any path-finding algorithm could be used, we employ bidirectional BFS as an example here.
% The algorithm iteratively finds disjoint paths. 
% For each $i$-th iteration, each query is initialized with its source vertex and a $k$DP set. 
% The algorithm expands vertices in the frontier until all $k$DPs find their $i$-th path or the queue empties. 
When a frontier vertex $v$ expands in the forward search (Alg.~\ref{alg:expandFrontier}, 
backward search proceeds similarly), its $k$DP set is divided into subsets, and each neighbor is processed only once for the $k$DPs in that subset.
If frontiers share the same neighbor, their $k$DP sets are merged, enabling continued shared traversal.
The complete algorithm of \texttt{ShareDP} is provided in the appendix (arXiv).

\input{tab/expandFrontier}

% % \vspace{-5pt}

