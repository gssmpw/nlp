%!TEX root = main.tex
% \vspace{-3pt}
\section{Experimental Evaluation}\label{sec:experiment}

We implemented all algorithms in C++ and tested on a Ubuntu machine with 512 GB RAM and Intel(R) Xeon(R) Platinum 8352V 2.10GHz CPU. 

% \vspace{-5pt}
\subsection{Experimental Setup}\label{sec:experiment_setup}
% We implemented all algorithms in C++ and tested on a Ubuntu machine with 512 GB RAM and Intel(R) Xeon(R) Platinum 8352V 2.10GHz CPU. 

% \subsubsection{Algorithms}\label{sec:experiment_algo}
{\textbf{Algorithms.}}
% We compare the following algorithms:
1) \emph{{\texttt{ShareDP}}}: Our approach using bidirectional BFS (Sec.~\ref{sec:approach_details}).
2) \emph{{\texttt{ShareDP-}}}: \texttt{ShareDP} with supergraph representation.
3) \emph{{\texttt{maxflow}}}~\cite{baselineOnlySplitP1}: Baseline method (Sec.~\ref{sec:splitgraph}).
4) \emph{{\texttt{BatchEnum}}}~\cite{BatchEnum}: State-of-the-art path enumeration with adaptations (3) for our problem (Sec.~\ref{sec:related_kdp}).\footnote{BatchEnum reuses path enumeration results across queries, requiring complete enumeration, which prevents adaptations (1) and (2). }
5) \emph{{\texttt{SCB+}}}~\cite{SCB}: State-of-the-art dissimilar path finding method (adaptation (2)).
6) \emph{{\texttt{Penalty}}}~\cite{Penalty}: Another dissimilar path finding method (adaptation (1)).
7) \emph{\texttt{IST}}~\cite{2009BRTree}: Single-source method for \( k = 2 \) (case for $k > 4$ is open challenge, see Sec.~\ref{sec:related_kdp}).

% For \texttt{ShareDP} and \texttt{ShareDP-}, we split the query set into equal-sized batches and run them sequentially, balancing shared computation and memory overhead. 
% Specifically, batch sizes of $128$ ($64$) were used for large (small) graphs.

% \subsubsection{Datasets And Queries}\label{sec:experiment_dataset}
{\textbf{Datasets and Queries.}}
We evaluate on 12 real-world datasets (Tab.~\ref{tab:datasets}), sourced from \href{https://snap.stanford.edu/}{SNAP}, \href{http://networkrepository.com/networks.php}{NetworkRepository}, and \href{https://law.di.unimi.it/index.php}{LAW}. 
These include the datasets used in \cite{SCB} (first 6 rows), supplemented by 6 larger datasets for improved comparison (last 6 rows).
% queries
For each graph, we generate 1000 vertex pairs with \( k \)DP solutions, starting from \( k \)=\( 50 \) down to \( k \)=\( 2 \). 
Candidate pairs are selected based on vertex degree \( \geq k \). 
If fewer than 20\% succeed, \( k \) is reduced. The maximum \( k \) is termed \( k_{max} \). Algorithms are evaluated on 4–5 \( k \)s per graph, based on \( k_{max} \).

% % % \vspace{-10pt}
% \begin{table}[!h]
%     \centering
%     \caption{Properties and evaluated $k$ values of datasets}
%     % \resizebox{\linewidth}{!}
%     {
%         \input{tab/tab_datasets}
%     }
%     \label{tab:datasets}
% \end{table}
% % % \vspace{-10pt}

% \vspace{-10pt}
\subsection{Experimental Result}\label{sec:experiment_result}
\subsubsection{Comparing Algorithms when varying $k$}\label{sec:experiment_time}

We evaluated different algorithms across various $k$ values (Fig.~\ref{fig:running_time}). 
The y-axis shows average runtime per query (seconds), and the x-axis represents $k$. 
Queries exceeding 200 seconds were terminated and recorded as such. 
% For \texttt{ShareDP++}, batch sizes of $128$ and $64$ were used for large and small graphs, respectively, to balance shared computation with overhead.


\texttt{ShareDP} (brown) consistently outperformed others with the lowest runtime. 
Most dissimilarity-based methods failed to complete for nearly all $k$s, 
% except for small graphs (rt, ts), where they also failed for larger $k$. 
When they did run, they were more than 10 times slower than flow-based methods (\texttt{maxflow} and \texttt{ShareDP}). 
\texttt{IST} was at least 10 times slower for the only \( k \) it handled (\( k \)=2).

% \texttt{maxflow} (purple line) showed faster performance than the slower methods but grew quickly with $k$. 
\texttt{ShareDP}'s advantage over \texttt{maxflow} increased as $k$ grew. For graphs with fewer disjoint paths (e.g., id and uk), \texttt{ShareDP} significantly outperformed \texttt{maxflow}. For graphs with more disjoint paths (e.g., sk and tw), the advantage of \texttt{ShareDP} was more pronounced at larger $k$, as finding a small number of disjoint paths in these graphs is easy, reducing the relative advantage of \texttt{ShareDP} in simpler cases. For similar reasons, \texttt{ShareDP} showed a greater advantage on larger graphs (e.g., the last row). These results highlight the efficiency and scalability of \texttt{ShareDP}.

% % \vspace{-20pt}
% \begin{figure}
%     \centering
%     \includegraphics[width=\linewidth]{pic//exp/k_running_time}
%     % \vspace{-10pt}
%     \caption{Running time when varying $k$.}
%     \label{fig:running_time}
% \end{figure}
% % % \vspace{-25pt}
% % \vspace{-20pt}

% % \vspace{-10pt}
\begin{table}[!h]
    \centering
    \caption{Properties and evaluated $k$ values of datasets}
    % \resizebox{\linewidth}{!}
    {
        \input{tab/tab_datasets}
    }
    \label{tab:datasets}
\end{table}
% % \vspace{-10pt}

% % 删除 begin
\subsubsection{Effect of the number of $k$DPs}\label{sec:experiment_instance_number}

% The goal of this paper is to efficiently execute a large number of $k$DPs.  
We analyzed performance as the number of $k$DPs ($|Q|$) varied from 1 to 1000 with $k$=$10$ across all datasets (Fig.~\ref{fig:vpcnt_impact}).  
% For each $|Q|$, we generated $max\{256/|Q|, 1\}$ samples by random selection from the query set in Sec.~\ref{sec:experiment_setup}, averaging the runtime per sample. 
The y-axis shows average runtime per query (seconds), and the x-axis shows $|Q|$.
As shown in Fig.~\ref{fig:vpcnt_impact}, \texttt{ShareDP}'s runtime decreases as $|Q|$ increases, outperforming \texttt{maxflow} at small $|Q|$.  
This is due to shared computation when more $k$DPs are processed together.  
The improvement slows with larger $|Q|$ as the average shared computation stabilizes, reaching an upper limit based on the graph’s properties.

% % \vspace{-10pt}
% \begin{figure}
%     \centering
%     \includegraphics[width=\linewidth]{pic//exp/vp_impact}
%     % \vspace{-10pt}
%     \caption{Running time when varying the number of $k$DPs with $k$=$10$.}
%     \label{fig:vpcnt_impact}
% \end{figure}
% % \vspace{5pt}

% % 删除 end
    
\subsubsection{Ablation Study}\label{sec:experiment_opt}

We evaluate key components of \texttt{ShareDP} with $k$=$10$ on the 4 largest graphs in terms of running time (Tab.~\ref{tab:optimization_impact}, bold indicates the best, and underline indicates the second-best.).
(1) {\emph{Merged Split-Graph Representation.}}  
\texttt{ShareDP} outperforms \texttt{ShareDP-}, validating the effectiveness of our representation.
(2) {\emph{Merged Traversal.}}  
\texttt{ShareDP-} outperforms \texttt{maxflow} in 3 datasets, demonstrating the effectiveness of merged traversals. However, for the largest dataset, \texttt{maxflow} outperforms \texttt{ShareDP-}, highlighting the importance of well-designed components (e.g., representation of $G'$) beyond merged traversals.


% % % \vspace{-10pt}
% \begin{table}[!h]
%     \centering
%     \caption{Ablation Study. Average execution time (seconds) with $k$=$10$. }
%     % \resizebox{\linewidth}{!}
%     {
%         \input{tab/tab_optimization_impact}
%     }
%     \label{tab:optimization_impact}
% \end{table}
% % % \vspace{-10pt}
