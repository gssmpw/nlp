\subsubsection{Latency Monitoring}
\label{sec:latency}

We now discuss our approach to measuring latencies between replicas in a star topology.

We measure the \textit{round-trip latency} of protocol message exchanges.
Our \latsensor instruments the \consmod's Proposal-Vote exchange, capturing the latency between the proposing (leader) replica and the voting replicas.
The leader then compiles these latencies into a \textit{latency vector}, which is included in the next proposal.
Any faulty replicas that did not vote are marked as $\infty$ in the latency vector.
To collect measurements from each replica's vantage point, we assume frequent leader rotation (views), a common practice in star topologies.

Each replica has a \latmonitor that maintains a \textit{latency matrix} \lm, representing inter-replica latencies.
When a proposal is committed, the monitor updates the leader's row in \lm based on the proposal's latency vector.
To maintain a symmetric matrix, we set $\lme{\na}{\nb}=\lme{\nb}{\na}=\max(\lat[r]{\na}{\nb}, \lat[r]{\nb}{\na})$, where $\lat[r]{\na}{\nb}$ is the \textit{recorded} latency between replicas $\na$ and $\nb$.
To allow all replicas to build a complete latency matrix, at least $2\n$ views are needed.
The monitor may repeat this process to improve \lm's accuracy.

In a Byzantine environment, \lm may not accurately reflect inter-replica latencies.
We now examine scenarios where replicas record incorrect measurements to distort the matrix.

\begin{table}[ht]
  \footnotesize
  \centering
  \begin{tabular}{@{}ll@{}}
    \toprule
    \textbf{Scenario}              & \textbf{Recorded vs Actual Latency} \\ \midrule
    1: $A$ and $B$ are non-faulty  & $\lme{\na}{\nb}$ in $[\lat[a]{\na}{\nb}, \delta\lat[a]{\na}{\nb}]$ \\
    2: $A$ or $B$ is faulty        & $\lme{\na}{\nb} \geq (\leq) \lat[a]{\na}{\nb}$ \\
    3: $A$ and $B$ are faulty      & $\lme{\na}{\nb} \geq$ or $\leq \lat[a]{\na}{\nb}$ \\
    \bottomrule
  \end{tabular}
\end{table}

\noindent
In Scenario~1, $\na$ and $\nb$ are correct, so their recorded latency matches the actual latency.
In Scenario~2, the \lm at correct replicas reports the highest latency.
Thus, $\lme{\na}{\nb} < \lat[a]{\na}{\nb}$ is unlikely when either $\na$ or $\nb$ is faulty.
For a faulty replica to log a latency lower than the actual value, it would need to collude with another replica $\nc$ that has a lower latency to the correct replica.
However, to benefit from $\nc$'s lower latency, the faulty replica needs to synchronize with $\nc$, which may itself add latency and make this strategy difficult.
We do not assume that such cases cannot happen, but consider them unlikely.
In Scenario~3, both replicas are faulty, so we ignore their \lm entries as meaningless.

Our latency measurement technique offers three key benefits over existing methods~\cite{aware,bft-smart,rbft}.
First, it measures actual protocol latency, including command execution, rather than just network latency experienced by dummy messages.
Second, it supports incremental logging, allowing extended data collection and refinement.
Finally, we can use historical latency data for more thorough analysis to improve accuracy and reliability.






