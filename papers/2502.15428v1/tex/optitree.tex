\section{\optitree}
\label{sec:optitree}

This section introduces \optitree, a variant of Kauri~\cite{kauri}, utilizing \sysname to construct \validt, low-latency trees.

\subsection{Preliminaries for \optitree}
\label{sec:optitree-prelim}

\subsubsection{A Brief Primer on Kauri}
\label{sec:kauri}

This section gives an overview of Kauri and its reconfiguration approach.
To improve scalability, Kauri replaces HotStuff's star topology with a tree topology (\cref{fig:plain-tree}), where leader \nr disseminates proposals top-down and aggregates votes bottom-up.
We refer to replicas with a specific role or placement in the tree as nodes.
In this structure, Kauri's \textit{internal nodes}, $\Internal = \{\nr, \nin_1, \ldots, \nin_b\}$, manage only $\bn$ child nodes, where $\bn$ is the tree's branch factor.
As a result, the internal nodes experience a much lower load than HotStuff's leader, which must interact with $\n-1$ replicas.
Let $\Intermediate = \Internal \setminus \{\nr\}$ denote the \textit{intermediate nodes}, and $\Leaf = \C{} \setminus \Internal = \{\nleaf{1}, \ldots, \nleaf{b^2}\}$ the \textit{leaf nodes}.

\begin{figure}[hbt]
  \centering
  \input{images/plain-tree}
  \caption{Tree with $\n=13$ replicas and branch factor $\bn=3$.}
  \Description{Diagram showing a tree with 13 replicas and a branch factor of 3.}
  \label{fig:plain-tree}
\end{figure}

Kauri exploits the parallelism of its tree topology through pipelining.
Specifically, the root can initiate multiple consensus instances concurrently, resulting in higher throughput than a comparable star topology.

However, it is hard to construct trees in the presence of faults.
That is, the internal nodes of a tree can control both the dissemination and aggregation stages of the protocol.
In a star topology, assuming an honest leader, protocol execution may succeed despite some faulty votes.
This may not be the case for a tree topology.
To address this concern, Kauri forms a \validt tree using a reconfiguration algorithm based on \tbc~\cite{kauri}.
This method involves dividing the replicas into $\tn$ disjoint bins, assuming that $\f<\tn$, where $\tn=\n/\inn$ and $\inn$ is the number of internal nodes.
Kauri then constructs trees using these bins, with replicas in each bin serving as internal nodes and the rest as leaf nodes.
If $\f<\tn$, there is always at least one fault-free bin, ensuring at least one tree with correct internal nodes.
If Kauri is unable to establish a \validt tree within $\tn$ reconfiguration trials, it reverts to using a star topology.
Neiheiser et al.~\cite{kauri} show that a three-level tree can guarantee liveness if the internal nodes are correct.
Their reconfiguration algorithm exploits this guarantee by iterating through trees constructed from disjoint sets of internal nodes.

\subsubsection{Kauri's Challenges}

In a wide-area environment, Kauri may face several challenges:
1)~A single faulty replica may exclude many other replicas from being considered as internal nodes.
Moreover, if latencies are not uniform, the performance of successive trees may degrade significantly.
%We show this in \cref{sec:security-latency}.
2)~Kauri reconfigures only when a tree fails to collect $\q$ replies.
For example, if a low-latency subtree fails, Kauri may wait for a higher-latency subtree to respond, resulting in degraded performance.
3)~Kauri's reconfiguration approach only supports $\mathcal{O}(\sqn)$ reconfigurations.

To address Challenge~1, \optitree eliminates faulty replicas from the candidate set, individually or paired with at most one correct replica.
For Challenge 2, \optitree dynamically adjusts the tree's failure threshold based on recorded suspicions.
Further, we prove that in any scenario with up to $\f$ faults, \optitree uses at most $2\f$ reconfigurations to find a \validt tree, addressing Challenge~3.

\subsection{Overview of \optitree}

\optitree's goal is to find \validt, low-latency trees for large-scale RSM deployments.
A \textit{\validt tree} is one where the internal nodes are correct, ensuring that the tree can collect a quorum of votes.
However, an arbitrary \validt tree may be suboptimal, and so \optitree additionally aims to minimize the tree's latency based on the replicas' recorded latencies.
We define \textit{tree latency} as the time it takes for the root to disseminate the proposal and aggregate a quorum of votes.
A tree fails when it cannot collect a quorum of votes within a timeout.
In the following, we explain how \sysname's sensors and monitors are adjusted to match the characteristics of a tree topology.
