% \section{code refinement}

% 在一次code review过程中，首先由developer提交了一份修改，用最初的代码C0修改到代码C1。而后，reviewer针对这次修改（C0->C1）提出了review comment(RC),无论是reviewer提交review，还是developer查看review，RC会呈现在某一行代码之后，我们称这一行代码是review line（RL）。通常review line是C0->C1的修改部分，review对上次的修改进行评价和建议，也有少部分情况review line是针对未修改代码提出新的修改建议。而后developer根据RC，对C1进行修改，得到新的代码版本C2。传统的code refinement任务我们称之为Basic Code Refinement，其input为：<C1, RC>，output为<C2>。然而，我们注意到一些数据只提供C1, RC是信息不足的。如图1所示，例子a需要提供review line才能确定review要删除哪一行。例子2中，需要指导C0才能确定如何回退代码。我们定义两种新型的任务，Position-Aware Code Refinement: 其输入为<C1,RC,RL>，输出是<C2>；	Comprehensive Code Refinement:输入为<C0,C1,RC,RL>，输出也是<C2>。本文主要研究的对象就是Comprehensive Code Refinement。
% 为了避免文字混淆，我们称C0版本的代码是initial code，C1版本的代码是original code，C2版本的代码是revised code。



% 目前coderefine方向有两个使用广泛的数据集，Tufano数据集和codereview数据集。如前文介绍的，我们需要数据集提供initial code， original code， review line， review comment， revised code等五个字段。Tufano数据集没有initial code字段，且没有提供原始数据的链接。而codereview数据集虽没有review line，initial code两个字段，但是提供了原始的数据连接，故而我们选择使用codereview数据，并补齐缺失字段。

% 首先介绍review line字段获取方法。我们观察到通过GitHub REST API获取code review信息时，可以获取到partial last code diff（在API返回的json中叫做diff hunk字段，给个角标https://api.github.com/repos/meganz/sdk/pulls/comments/326107667）。之所以我们称之为partial last code diff，是因为这段code diff只提供了review comment之前的修改信息。在例子中，原本的last code diff有三行代码删除，三行代码添加。review line在第一行代码添加之后。所以partial last code diff只有三行删除，一行添加。根据这个规律，我们可以得到review line就是partial last code diff的最后一行。

% 而后我们需要设计得到initial code的方法。我们观察到，一次code review可能是reviewer对前面多次commit的review。如果当前pull request有n个commit：（commit_1，commit_2，...,commit_n），reviewer可以选择commit_m到commit_n之间所有commit（n小于等于m），然后查看这些commit叠加后的文件变化,而后再给出review comment。而GitHub REST API只给出了最后一次commit的id，即commit_n，无法确定前面的commit_m。不过GitHub REST API中提供的partial alst code diff就是commit_m到commit_n的code diff。故而，我们倒序依次遍历前面的所有commit，并与commit_n做比较，得到review line附近的code diff。并与partial last code diff做对比，就可以找到与partial last code diff一致的，完整的last code diff。根据last code diff和original code就可以得到initial code。