\section{Intention-Based Framework}


% 现有的code Refinement是个端到端的任务，从输入数据直接要求大模型生成RevisedCode。这种任务要求对大模型来说近似于黑盒猜测结果，没有完整的推理过程，其效果也难以保证。为解决这种问题，一个很自然的想法是利用COT方法来补齐推理过程，提高模型效果。
% COT方法可以帮助模型明确推理路径，将复杂任务分解成若干个模型可以处理的简单子任务。例如在COT论文中的例子，对于问题“The cafeteria had 23 apples. If they used 20 to make lunch and bought 6 more, how many apples do they have?”。直接做，模型会给出错误答案。用COT方法，可以帮助模型理解问题的含义，像人类一样将问题拆解成多步的小问题：先计算用20个苹果做午饭后还剩多少个，再计算再买6个之后共多少个，模型就可以给出正确结果。然而在code refinement任务中，使用COT方法的效果并不理想。这是因为大模型没有真正理解任务，没有掌握如何分解任务，所以不能像人一样生成推理的路径。如图1所示，原有的代码中is_spmv_supported_node_feat总是返回True值，因此ReviewComment要求删掉这个函数。然而，模型在分析时，只是重复了ReviewComment中的句子，没有定位要删除的内容。最后模型的给出的答案就没有删除is_spmv_supported_node_feat函数，反而给_is_spmv_supported_edge_feat也补全了Return True。这可能是模型产生了幻觉，把后续代码片段当做补全任务处理了。

% 由此我们希望从人类developer解决Code Refinement任务的方法中得到启发，帮助大模型设计具体的推理路径，将复杂任务拆解成子任务。像COT技术一样，通过拆解问题让大模型在解决code Refinement时拥有清晰的推理过程，增强结果的可解释性，并提升最终结果的效果。
\begin{figure*}[!t]
\centering
\includegraphics[width=\linewidth]{fig/framework.pdf}
\vspace{-6mm}
\caption{The framework of our intention-based code refinement.}
\label{fig:framework}
\vspace{-4mm}
\end{figure*}

\subsection{\major{Understanding Intention in Code Review}}
When developers tackle code refinement tasks, they begin by analyzing the reviewer's intention, particularly code modification suggestions. While the \texttt{ReviewComment} often provides these suggestions, it may also contain unrelated information such as explanations of reasons, polite expressions, or even emojis. Additionally, \texttt{ReviewComment} may include ambiguous references, colloquial language, or domain-specific terminology. Developers need to navigate these elements to extract the precise intention, which can often be summarized as a clear and templated directive, such as \texttt{"revert the previous modification"} or \texttt{"replace word A with word B"}. \major{Thus, understanding the review comment and distilling the intended action (i.e., intention) are crucial for performing the correct code refinement.}

% Based on the different methods developers use to modify code, we categorize Intentions into three major classes and eight subcategories. The three major classes are \textbf{Explicit Code Suggestions}, \textbf{Reversion Suggestions}, and \textbf{General Suggestions}.
\major{
\emph{Preliminary Study on Review Comments and Intentions.} 
To understand the intentions behind code review comments, we conducted a preliminary human study by manually analyzing these comments.
% Specifically, we selected 30 highly starred projects on GitHub. From each project, we extracted pull requests submitted.
Specifically, we selected 30 highly starred projects on GitHub and extracted code reviews from the pull requests submitted within each project.
Projects without suitable pull requests or code reviews were excluded. To ensure diversity across projects, we limited the sampling to a maximum of 100 code reviews per project. Finally, we collected a total of 1,100 code review instances from 15 projects.}

\major{Three coauthors conducted the study to understand the intentions behind code review comments. Based on this understanding, we developed a classification framework to categorize these comments according to their intentions. Specifically, our classification is guided by three key criteria: 1) the representativeness of each category, ensuring that each type of comment constitutes a significant portion of the dataset; 2) an intention-oriented approach designed to capture the underlying intentions behind each type of comment; and 3) the feasibility of reliably extracting these intentions from only code reviews. In cases of disagreement during the categorization process, another coauthor facilitated discussions to resolve differences until a consensus was reached. Through this collaborative process, we identified three categories of code review comments, each reflecting a distinct intention: \textit{Explicit Code Suggestions}, \textit{Reversion Suggestions}, and \textit{General Suggestions}. These categories are representative and account for 13\%, 23\%, and 64\% of the total comments, respectively. The details of these three categories and their associated intentions are summarized as follows:
}

\begin{itemize}[leftmargin=*,topsep=2pt]
    \item \textbf{Explicit Code Suggestions}: This category includes the exact code that needs to be applied. Developers only need to identify the appropriate location and insert the given suggestion code accordingly. \major{\emph{For this type of comment, the intention is clear and direct, as the target changes are already explicitly stated within the comment.}}

    
    \item \textbf{Reversion Suggestions}: These imply that the reviewer explicitly or implicitly indicates that the previous modification was unsuitable and suggests reverting to the version before the last modification. \major{\emph{For this type of comment, the intention is to restore the code to its previous state.}}
    
    \item \textbf{General Suggestions}: \major{Comments that do not fall into the two specific categories above are classified as general suggestions, which lack explicit intentions. For these comments, we characterize their intention based on two general aspects: the type of change (i.e., insertion, modification, and deletion) and the corresponding scope of the change (i.e., single-line or multi-line). Since insertion is a specific form of modification, we group it under the broader category of changes, resulting in four general intention categories: single-line change, single-line deletion, multi-line change, and multi-line deletion. Additionally, we observed that word-level changes are particularly common in single-line edits. Therefore, we distinguish between word-level changes and code-level changes within single-line edits, which maintains clarity and operability. \emph{Ultimately, for this type of comment, we have six types of general intentions: }
    }
      \begin{itemize}
        \item Single-line change: Change word \texttt{(...)} to \texttt{(...)}
        \item Single-line change: Delete word \texttt{(...)}
        \item Single-line change: Change the code to \texttt{<code>}
        \item Single-line change: Delete code \texttt{<code>}
        \item Multi-line change: Delete code lines \texttt{<code>}
        \item Multi-line change: Change the code lines \texttt{<code 1>} to \texttt{<code 2>}
    \end{itemize}
    % This category encompasses other types of modifications that have general intention. Each subcategory serves as a template for a type of modification, requiring specific words and code to be filled in based on the actual situation. \major{Our classification of intentions diverges from previous approaches [22, 24], as we focus on categorizing potential actions that the system needs to execute, such as replacing a word or deleting a block of code. This approach prioritizes aiding the model in understanding the specific operations required by the reviewer, rather than interpreting the semantic nuances, such as whether the reviewer is renaming a variable or fixing a specific bug. By simplifying the classification into six actionable categories, we aim to enhance the model's ability to perform accurate and targeted code revisions, which aligns with the primary goal of our framework.}
    % This category encompasses other types of modifications, including six subcategories. 每个子类别是个修改类型的模板，需要根据实际情况填入单词和代码
    % Specifically, the content between \verb|```| represents a code block, while the content between parentheses represents ordinary words.
    % 特别的，\verb|```|之间的内容代表代码块，括号之间的代表普通单词
\end{itemize}


% \major{
% Through our study of 1430 GitHub code review comments, we identified three distinct categories based on their nature: \textbf{Explicit Code Suggestions}, \textbf{Reversion Suggestions}, and \textbf{General Suggestions}. These categories reflect the types of review content developers commonly encounter. Among the collected comments, \textbf{Explicit Code Suggestions} accounted for 32\%, while \textbf{Reversion Suggestions} comprised 11\%. Both of these categories are relatively straightforward to process and can often be addressed using targeted strategies tailored to their specific characteristics.
% In contrast, the remaining \textbf{General Suggestions} are more complex and require a deeper understanding of the reviewer's intent. To effectively handle these, we propose a novel intention-driven method that goes beyond conventional approaches, enabling better interpretation and implementation of these nuanced suggestions.}


% \major{Our classification of Intention categories was developed through a systematic approach, focusing on two primary dimensions: the major change types (insertion, modification, and deletion) and the size of the changes (single-line vs. multi-line). Recognizing that insertion is inherently a form of modification, we grouped them together under the broader "Change" category. This approach resulted in four fundamental Intention categories: single-line change, single-line deletion, multi-line change, and multi-line deletion.}

% \major{To further address the commonality of word-level modifications, particularly in single-line edits, we introduced two additional categories: single-line word change and single-line word deletion. These categories ensure that our classification framework captures the granularity of typical refinement tasks while maintaining clarity and operability. }

% Our design of the Intention categories satisfies both comprehensiveness and operability. Comprehensiveness means that all code refinement modification types can be covered by our Intention categories and described using one of the Intention templates. Operability means that the Intention serves as a clear operational instruction, allowing both humans and models to modify the code unambiguously according to the Intention. The reason we did not design a separate category for adding lines and instead classified insert operations as multi-line modifications is that this approach ensures the Intention is unambiguous and enhances operability.

\major{
Note that our classification differs from those in previous works~\cite{tufano2024code, fregnan2022happens} due to a difference in focus. Previous studies primarily aim to perform post-analysis, understanding the concrete actions from both refined code and comments, such as renaming variables or fixing specific bugs. In contrast, our work focuses on pre-analysis to identify the potential intention from review comments, which is more difficult. While it is possible to refine these classifications and intentions further, doing so would significantly increase the complexity of predicting such intentions from code review. An incorrect prediction of intention could potentially misguide the refinement process, leading to unintended changes or deviations from the desired outcomes. Therefore, this paper focuses on intentions that are either easy to extract (i.e., explicit changes and reversions) or with high-level patterns (i.e., the six general intention patterns). Our results (see Section~\ref{sec:rq2}) demonstrate the effectiveness of this approach. More fine-grained intention extraction and analysis are left as our future work.
}

% developer解决Code Refinement问题时，会先分析reviewer的Intention，也就是具体的代码修改建议。注意，ReviewComment虽然有时也能代表代码修改建议，但是ReviewComment同时可能也包含了原因解释，礼貌用词，甚至表情符号等无关信息，也可能有指代不明，口语化用词，领域专用词等问题。而经过developer理解后的Intention，是简洁化模板化的描述，例如："退回上次修改"，或者"将单词A换成单词B"等。
% 依据developer修改代码时的方法不同，我们将Intention分为3个大类，8个小类。三个大类分别是Explicit Code Suggestions，Reversion Suggestions和General Suggestions。Explicit Code Suggestions是指代码中有明确的建议代码，通常只需要developer找到合适的位置，理解suggested code要替换哪些代码，按suggested code填写就行。Reversion Suggestions是指reviewer或明示，或暗示，认为上次的修改不合适，需要退回上次的修改，恢复到LastCodeDiffHunk修改前的版本。General Suggestions则是其他类型的修改，包括六个子类别：
% Single-line change. Change word (old_word) to (new_word)
% Single-line change. Delete word (word_to_delete)
% Single-line change. Change the code to ```new_code```
% Single-line change. Delete code ```code_to_delete```
% Multi-line change. Delete code lines ```code_lines_to_delete```
% Multi-line change. Change the code lines ```old_code_lines``` to ```new_code_lines```

% 我们这种Intention的类别设计既满足全面性，又符合了可操作性。全面性是指全部code Refinement的修改类型都可以被我们的Intention类别覆盖，可以用其中一种Intention模板描述。可操作性是指，Intention是明确的操作指令，人和模型都可以无歧义的按照Intention来修改代码。

% 确定Intention后，我们设计了一个基于Intention的code Refinement框架，如图二所示。框架包括Intention Extracting和Intention Guided Code Modification两部分。特别的，本框架面向更接近实际情况的Comprehensive Code Refinement任务，以防因为缺少ReviewLine或LastCodeDiffHunk信息。导致一部分Intention难以理解或者难以修复。接下来，我们将介绍框架的Intention Extracting和Intention Guided Code Modification设计方法。



\subsection{Intention Extraction}


% Upon determining the Intention, we developed an Intention-Based Code Refinement Framework, as illustrated in Fig.~\ref{fig:framework}. This framework comprises two main components: \textbf{Intention Extraction} and \textbf{Intention-Guided Revision Generation}. The framework is specifically designed to address the Comprehensive Code Refinement task, which reflects more realistic scenarios. In the following subsections, we will elaborate on the design methodologies for Intention Extraction and Intention-Guided Revision Generation within the framework.


Based on the intentions in different kinds of code reviews, we design the corresponding methods to extract intention and generate code revision. As illustrated in Fig.~\ref{fig:framework}, we employ three agents to distinguish among \textit{Explicit Code Suggestions}, \textit{Reversion Suggestions}, and \textit{General Suggestions}.

\textit{Intention for Explicit Code Suggestions.} In Agent 1, we utilize a rule-based method to identify the most explicit category: \textit{Explicit Code Suggestions}, which shows the direct and explict intention. 
% As illustrated in Fig.~\ref{fig:framework}, we employ a multi-tiered classification approach that combines a Large Language Model (LLM) classifier with a rule-based classifier to extract the Intentions. Initially, we utilize a rule-based method to classify the most explicit category: \textit{Explicit Code Suggestions}. 
This category includes cases where the review comment contains suggestion code snippets in the format \verb|```suggestion <code>```|. Accompanying these suggestions, there may be explanatory remarks and other exchanges between the reviewer and developer. We use regular expressions to determine if a case contains a suggestion code. If it does, it is categorized as \textit{Explicit Code Suggestions}.


\textit{Intention for Reversion Suggestions.} For cases not classified as \textit{Explicit Code Suggestions}, we employ Agent 2 to determine whether they fall under Reversion Suggestions. This assessment primarily relies on the \texttt{LastCodeDiffHunk}, which captures modifications from the Pre-Modification Code to the Post-Modification Code (also serving as the Original Code). We analyze whether the last modification involved an addition, deletion, or revision, and design specific prompts to evaluate whether the \texttt{ReviewComment} implies or explicitly requests a reversion of these changes.

If the \texttt{LastCodeDiffHunk} involves a deletion, we match the review comment into one of the following comment types:
The review comment with one of the following intentions:
 \begin{itemize}[leftmargin=*,topsep=2pt]
        \item  Expressing an opinion: You shouldn't delete this code.
        \item Expressing an opinion: You still need this code.
        \item Expressing an opinion: Change the code back.
        \item  Raising a question: Why delete this code?
        \item  Raising a question: Why did you do this?
        \item Giving a suggestion: You should add another piece of code.
\end{itemize}
Our preliminary study shows that the first five types cover the main deletion-related reversions, while the last one indicates no reversion. To accurately match with the types, we design a single-choice prompt for LLM-based classification, reducing ambiguities caused by variations in phrasing and tone. This approach improves the effectiveness of identifying and distinguishing reversion intents for deletions. Detailed prompts, along with handling for additions and revisions, are available on our website~\cite{IntentionWebsite}.


% The rationale behind this prompt design is twofold: firstly, to inform the LLM of the potential expressions and tones a reviewer might use to suggest reverting a change, thereby enhancing the model's domain knowledge; and secondly, to increase the accuracy of the LLM's task understanding through multiple-choice classification. 



% \major{This differentiation is mainly based on observations of the \texttt{LastCodeDiffHunk}, which reflects the modifications made from the Pre-Modification Code to the Post-Modification Code (which also serves as the Original Code). We examine whether the last modification involved an addition, deletion, or revision. }
% Depending on the type, we have designed specific prompts to assess whether the \texttt{ReviewComment} implies or explicitly states the need for a reversion of the code changes. For instance, if the \texttt{LastCodeDiffHunk} involved a deletion, we design the prompts to ask which of the following intentions the reviewer's comment corresponds to. 
% % \sql{The prompts for other types of modifications are provided on our website~\cite{IntentionWebsite}.}
%  \begin{itemize}[leftmargin=*,topsep=2pt]
%         \item  Expressing an opinion: You shouldn't delete this code.
%         \item Expressing an opinion: You still need this code.
%         \item Expressing an opinion: Change the code back.
%         \item  Raising a question: Why delete this code?
%         \item  Raising a question: Why did you do this?
%         \item Giving a suggestion: You should add another piece of code.
% \end{itemize}

% These six intentions cover most cases: the first five suggest reversion, while the last one does not. By having the LLM answer a single-choice question, we can reduce misunderstandings caused by potential expressions and tones in the review comment, making it more effective in distinguishing reversion intentions.
% % The rationale behind this prompt design is twofold: firstly, to inform the LLM of the potential expressions and tones a reviewer might use to suggest reverting a change, thereby enhancing the model's domain knowledge; and secondly, to increase the accuracy of the LLM's task understanding through multiple-choice classification. 
% Detailed prompts, along with other types of LastCodeDiffHunk (such as additions and revisions), are available on our website~\cite{IntentionWebsite}.


\begin{figure}[!t]
\centering
\includegraphics[width=.8\linewidth]{fig/prompt_agent3.pdf}
\vspace{-2mm}
\caption{\major{The prompt used for extracting general intention.}}
\label{fig:agent3}
\vspace{-4mm}
\end{figure}

\major{
\textit{Intention for General Suggestions.} If the code reviews are not matched with the explicit suggestions and reversion suggestions, they will be categorized as \textit{General Suggestions}. We employ Agent 3 to further classify them into six subcategories: four types of single-line modifications and two types of multi-line modifications.
As shown in Fig.~\ref{fig:agent3}, the templates used by Agent 3 consist of two components: the \textit{System} and \textit{User} prompts. The \textit{System} prompt instructs the LLM to interpret the code review according to one of the six predefined Intention templates. The models used in our experiments support \textit{System} prompts, a parameter commonly available in most modern LLMs.
% For cases categorized under \textit{General Suggestions}, we have designed an additional prompt that divides them into six subcategories, including four types of single-line modifications and two types of multi-line modifications. 
% Due to the rarity of code additions, we did not create a separate category for them but instead grouped them into the code modification category. 
Notably, each intention category template includes placeholders that the LLM must fill based on the specific case details in the user prompt.
This design clarifies the reviewer's intent and facilitates the subsequent generation of revised code.}

% 如图1左半部分所示，我们使用多层次的，LLM分类器和基于规则分类器相结合的分类方式提取Intention。首先，我们用基于规则的方法分类出最清晰的类别：Explicit Code Suggestions。这类case会在review comment中会出现```suggestion <code>```这样形式的Suggestion 代码片段，在Suggestion code前后，可能会伴随原因解释，和一些其他的reviewer和developer之间的交流。我们使用正则表达式判断，可以分辨出case是否包含Suggestion code，如果包含则属于Explicit Code Suggestions，如果不包含，则进入下一分类阶段。

% 接下来，我们要对于那些不是Explicit Code Suggestions的case，分辨出哪些属于Reversion Suggestions，哪些属于General Suggestions。首先我们观察从LastCodeDiffHunk,也就是从initial code到original code的修改。查看上次修改是属于添加，删除，还是修改的哪一类。根据不同的类别，我们设计了不同的prompt，让大模型判断ReviewComment中是否包含明示或暗示这个修改需要退回的意思。例如，如果LastCodeDiffHunk是删除，那么我们的prompt设计是问reviewer的意图属于以下哪一种：
% Expressing an opinion. You shouldn't delete this code.
% Expressing an opinion. You still need this code.
% Expressing an opinion. Change the code back.
% Raising a question. Why delete this code.
% Raising a question. Why did you do this.
% Giving a suggestion. You should add another piece of code.
% 除了最后一种之外，其他五种的结果都属于Reversion Suggestions。这样prompt设计的原因一来是告诉大模型reviewer可能通过哪些方式和语气来表达希望退回上次修改，也就是增强了模型的领域知识，二来是用选择分类的方法可以增加大模型对任务理解的准确度。详细的prompt设计，我们会在网站公布。

% 最后，对于General Suggestions的case，我们再设计了一个prompt，将其分为6个子类包括4类单行修改，2类多行修改。由于添加代码的情况较少，我们没有单独列出一类，而把他们共同分类到Change code类别中。这样设计的好处是更加明确了reviewer的意图，也方便后续的生成revised code的操作。特别的，我们对于每个Intention类别的模板都留有一些空白，需要根据具体case的情况，由大模型进行填写。

\subsection{Intention Guided Revision Generation}


\begin{figure*}[!t]
\centering
\includegraphics[width=0.85\linewidth]{fig/framework_prompt.pdf}
\vspace{-2mm}
\caption{The format of the used prompt in the generation.}
\label{fig:framework_prompt}
\vspace{-4mm}
\end{figure*}

As illustrated in Fig.~\ref{fig:framework}, the Intention Guided Revision Generation process consists of two primary steps: \textit{generation} and \textit{post-processing}. Each of the three distinct intention categories—Explicit Code Suggestions, Reversion Suggestions, and General Suggestions—follows its own specific generation and post-processing. Post-processing is used to adjust and repair the generated code in cases where LLMs may over-modify or fail to maintain consistency.

For the Explicit Code Suggestions and General Suggestions categories, the generation phase is similar. Both utilize LLMs as the foundational method for code generation. Our framework does not restrict the prompting strategy for LLMs. Various prompt strategies could be incorporated within our framework. We have implemented three commonly used prompt strategies in code tasks: Simple Prompts, RAG (Retrieval-Augmented Generation) Prompts, and Self-generated Prompts. Below, we describe each of these prompt design strategies, as illustrated in Fig.~\ref{fig:framework_prompt}:

\noindent \textbf{Simple Prompt:} This strategy involves describing the task scenario and introducing each field's information, instructing the model to make modifications as required.

\noindent \textbf{RAG Prompt:} \major{This approach enhances few-shot prompting by selecting relevant examples from a retrieval database. The database consists of key-value pairs, where the retrieval key is a combination of the intention and the comment, and the value includes \texttt{OriginalCode}, \texttt{Intention}, \texttt{ReviewLine}, and \texttt{RevisedCode}. For a new case, the comment and its associated intention are used to retrieve relevant examples, which are then appended to the front of a simple prompt, creating a tailored few-shot prompt.}

\noindent \textbf{Self-Generated Prompt:} This approach allows the model to generate code refinement examples on its own. Each example includes the \texttt{OriginalCode}, \texttt{Intention}, \texttt{ReviewLine}, and \texttt{RevisedCode}. The model then uses these self-generated examples as inspiration to address the original problem.

Next, we describe the generation and post-processing for each Intention category in detail:

\noindent \textbf{Explicit Code Suggestions:} We input the \texttt{OriginalCode}, \texttt{SuggestionCode}, and \texttt{ReviewLine} in the model. \texttt{SuggestionCode} refers to the code suggested within the \texttt{ReviewComment}. Based on these inputs, we design specialized post-processing criteria tailored to the unique characteristics of code refinement:

\begin{itemize}[leftmargin=*,topsep=2pt]
    \item Inclusion of Suggestion Code: The suggestion code must appear in the revised code.
    \item Invariant Code Context: The original code’s preceding and succeeding segments should remain unchanged, with the suggestion code either inserted in the middle or replacing a middle segment.
\end{itemize}

Using these characteristics, we first locate the suggestion portion within the revised code. If there is a complete match of the suggestion code in the revised code, the location is successfully identified. If not, the suggestion code has not been fully replicated. By determining the maximum matching probability for each line, we can locate the corresponding suggestion code section and copy the complete suggestion code. Additionally, by applying the rule that each line of revised code should originate from either the original code or the suggestion code, we trim redundant sections and fill in missing parts of the revised code.

\noindent \textbf{Reversion Suggestions:} For Reversion Suggestions, we employ a rule-based approach to generate the revision, eliminating the need for additional post-processing steps. \major{Specifically, this involves reverting the changes that transformed the Pre-Modification Code into the Post-Modification Code (which also serves as the Original Code), resulting in the revised code.} We begin by aligning the \texttt{LastCodeDiffHunk} with the \texttt{OriginalCode} and then revert the previous code changes to the \texttt{OriginalCode}: delete added lines and add deleted lines from the previous modifications. This rule-based generation approach negates the need for any further post-processing.

\noindent \textbf{General Suggestions:} For General Suggestions, we first employ LLMs to generate the code based on \texttt{OriginalCode}, \texttt{Intention} and \texttt{ReviewLine}. We then design two specific rules for the post-processing of the refined code:

\begin{itemize}[leftmargin=*,topsep=2pt]
    \item Comment Consistency: If the intention suggests new code without comments, the modified code should also lack comments.
    \item  Line Consistency: For single-line modification, other lines should remain unchanged.
\end{itemize}

% In summary, we have designed the  appropriate code revision method for each Intention category by selecting specific input content and devising targeted code post-processing strategies.

% 如图2右半部所示，Intention Guided Code Modification总体分为生成和修复两个步骤。对于Explicit Code Suggestions，Reversion Suggestions和General Suggestions三种不同的类别Intention，有各自不同的生成和修复流程。

% 对Explicit Code Suggestions和General Suggestions类别，生成部分是类似的。都是使用了LLM作为生成的基础方法，我们的framework并不限定LLM的prompt的策略，任何prompt策略都可以用到我们的框架中。我们实现了三种代码任务重的常见prompt策略：简单prompt，RAG，和self-generated。接下来，我们介绍一下每一种prompt设计策略，如图3所示：
% 简单prompt：描述任务场景，并介绍每一个字段信息，要求按照要求修改。
% RAG：我们首先建立一个索引集：使用Intention作为被索引的key，将数据集中其他的数据存入索引集中，包括original code，Intention，review line，revised code等字段。然后对于每一个新来的case，我们利用其Intention来检索得到3个最相近的datas，检索方法我们使用的BM25。而后，我们将检索到的结果作为例子，罗列出其中每一个data的original code，Intention，Intention Related Line，revised code，并拼接到简单prompt前面，重复3次，构成3-fewshot的prompt。
% self-generated：这个方法是利用模型自己生成3个例子，每个例子也要包含original code，Intention，Intention Related Line，revised code四个字段，然后再根据模型自己生成的例子启发自己，然后再去做原始问题。

% 接下来，我们具体介绍每一个类别的Suggestion的生成和修复过程。
% 对Explicit Code Suggestions，我们使用大模型时，使用的输入包括original code，Suggestion code和review line。而后，根据Explicit Code Suggestions我们设计了一个特殊的repairer。我们观察到此类任务有两个特点，第一：所有Suggestion code必须出现在revised code中。第二：original code的前后应存在不变的部分，只是中间插入了Suggestion code，或者中间一段代码改成了Suggestion code。利用这两个特性，我们首先定位revised code中的Suggestion部分。如果Suggestion code在revised code中有完全的匹配，那就定位成功。如果没有完全匹配，那么说明Suggestion code没有被完整的复制。我们可以根据每一行最大匹配的概率，找到对应Suggestion code部分，然后把完整的Suggestion code复制过来。其次，利用规则“revised code每一行代码都应该来自于original code或者Suggestion code”，裁剪revised code中的冗余部分，补齐revised code的缺失部分。

% 对Reversion Suggestions，我们仅使用规则来生成，不需要额外的修复。只需要退回从initial code到original code修改，就可以得到revised code。我们首先需要对齐LastCodeDiffHunk和OriginalCode，然后根据前一次修改的code change修改OriginalCode，凡是前一次添加代码的，则删除代码，凡是前一次删除代码的，则添加代码。这种生成方式完全是基于规则的，无需再经过其他repairer。

% 最后，对于General Suggestions，我们首先使用大模型生成revised code，使用的输入包括original code，Intention和review line。而后，我们根据两项规则设计repairer，一是如果Intention建议的代码里没有注释，则修改的代码不该有注释。二是对于单行修改，其他行的代码应保持不变。

% 总之，我们根据不同的Intention特性，分别设计了最合适的revised code生成方式，选择了不同的内容输入，以及设计了针对性的代码修复策略。