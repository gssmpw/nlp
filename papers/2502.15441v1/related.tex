\section{Related work}
\label{sec:related}

Large language models (LLMs) have enabled automation of many software
development and verification themes, including writing
code~\cite{BairiETALFSE2024,XiaETALFSE2025}, clarifying
requirements~\cite{MuETALFSE2024}, software
maintenance~\cite{DilharaETALFSE2024,JinETALFSE2024,JiangETALFSE2024,MaETALICSE2024,XuETALICSE2024,NamETALICSE2024},
software
testing~\cite{RyanETALFSE2024,LiuETALICSE2024,DinellaETALICSE2022},
debugging~\cite{WadhwaETALFSE2024,KangETAL2024}, constructing proofs
of theorems in automated provers~\cite{FirstETALFSE2024}, and
human-centric studies~\cite{WangETAL2024,ImranETALICSE2024}.  Our work
shares the spirit of previous work on using LLMs to formalize
specifications, e.g., postconditions~\cite{EndresETALFSE2024}, loop
invariants~\cite{ChakrabortyETALEMNLP2023}, or
Javadocs~\cite{JiangETALarXiv2024}.  In the specific context of Alloy,
LLMs were previously employed to repair faulty Alloy
models~\cite{Hasan2023,Alhanahnah2024}.  Indeed, repair and synthesis
are closely related; repair can be viewed as a restricted form of
synthesis where the faulty part of code that has been localized is
replaced with new code.  The topic of connecting LLMs and Alloy was
also briefly discussed on the Alloy community discourse
forum\footnote{\url{https://alloytools.discourse.group/t/the-use-of-alloy-and-llms/449}}.
To our knowledge, this paper presents the first study of LLMs in
solving the traditional synthesis and sketching problems for Alloy.

Program synthesis is a heavily studied
area~\cite{PueliRosnerICALP1989}.  A popular form of synthesis is
test-driven where user-provided tests are used to validate the
synthesized code.  SyPet~\cite{FengETAL2017} introduced the use of
Petri nets in creating sequences of method invocations for complex
APIs with respect to given tests.  EdSketch~\cite{HuaKhurshid2017} and
EdSynth~\cite{YangETAL2017} defined an optimized backtracking search
for completing Java sketches where test executions guided search
pruning.  Test-Driven Synthesis is defined an iterative method to build a
C$\#$ program such that it satisfies all the given tests~\cite{TDS}.
Component-based synthesis constructs programs by putting together
components from given libraries~\cite{oracleCBS}.

Program
sketching~\cite{Solar-LezamaETALCombSketchFinite2006,Solar-LezamaETALStencils2007,SolarLazemaPhD2008,jsketch,psketch,storyboardDS,AlurETAL2013,Singh2015},
pioneered by the Sketch system~\cite{SolarLazemaPhD2008}, offered an
exciting new advance in scaling program synthesis, where a partial
implementation is given and the goal is to complete
it~\cite{BodikJobstmannAlgoSynthesis2013,CodeHint,Feser2015,Kuncak:2010:CFS:1809028.1806632,Osera:2015:TPS:2813885.2738007,GveroETAL2011,MandelinETAL2005,FengETAL2017,synthesisRecursive,Singh2015}.
The Sketch system provided Java-like Sketch language for writing
partial programs, and deployed SAT and inductive synthesis in a
counterexample-guided loop to complete them.  JSketch enabled
sketching Java programs~\cite{jsketch} by translating Java to Sketch.
PSketch focused on concurrent data structures and enabled sketching
them~\cite{psketch}.

Researchers developed several approaches to assist Alloy users build
their models correctly, e.g., by highlighting UNSAT
cores~\cite{Shlyakhter2003,Torlak2008}, reducing
symmetries~\cite{TorlakJacksonTACAS2007,Shlyakhter2001,KhurshidETALSAT2003},
improving scenario
exploration~\cite{Alluminum,Nelson2017,SullivanETALICFEM2019},
supporting state
modeling~\cite{JacksonFeketeTACS01,FriasETALICSE05,JacksonVaziriISSTA2000,MarinovKhurshidASE2001,Sullivan2017EvaluatingSM},
and supporting testing a la traditional unit
testing~\cite{SullivanETALSPIN2014,SullivanETALICST2018,SullivanETALICST2017,WangETALICSE2018}.

ASketch~\cite{WangETALABZ2018ASketch} introduced sketching of Alloy
models in the spirit of the Sketch system.  The heart of ASketch is an
efficient enumerator for non-equivalent relational
expressions~\cite{WangETALABZ2018RexGen}.  We use the basic ASketch
approach for creating the sketching problems for the LLMs.  A key
difference is that ASketch, just like the Sketch system, requires test
cases to be given as input in order to complete the sketch and
validate the resulting code.  In contrast, our use of LLMs does not
require test cases; in addition to the sketch, we simply provide a
natural language description of the desired property to the LLMs.

% LocalWords:  LLMs provers centric postconditions invariants SyPet
% LocalWords:  Javadocs Petri APIs EdSketch EdSynth TDS JSketch UNSAT
% LocalWords:  PSketch ASketch
