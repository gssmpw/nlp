\section{Related work}
\label{sec:related}

Large language models (LLMs) have enabled automation of many software
development and verification themes, including writing
code____, clarifying
requirements____, software
maintenance____,
software
testing____,
debugging____, constructing proofs
of theorems in automated provers____, and
human-centric studies____.  Our work
shares the spirit of previous work on using LLMs to formalize
specifications, e.g., postconditions____, loop
invariants____, or
Javadocs____.  In the specific context of Alloy,
LLMs were previously employed to repair faulty Alloy
models____.  Indeed, repair and synthesis
are closely related; repair can be viewed as a restricted form of
synthesis where the faulty part of code that has been localized is
replaced with new code.  The topic of connecting LLMs and Alloy was
also briefly discussed on the Alloy community discourse
forum\footnote{\url{https://alloytools.discourse.group/t/the-use-of-alloy-and-llms/449}}.
To our knowledge, this paper presents the first study of LLMs in
solving the traditional synthesis and sketching problems for Alloy.

Program synthesis is a heavily studied
area____.  A popular form of synthesis is
test-driven where user-provided tests are used to validate the
synthesized code.  SyPet____ introduced the use of
Petri nets in creating sequences of method invocations for complex
APIs with respect to given tests.  EdSketch____ and
EdSynth____ defined an optimized backtracking search
for completing Java sketches where test executions guided search
pruning.  Test-Driven Synthesis is defined an iterative method to build a
C$\#$ program such that it satisfies all the given tests____.
Component-based synthesis constructs programs by putting together
components from given libraries____.

Program
sketching____,
pioneered by the Sketch system____, offered an
exciting new advance in scaling program synthesis, where a partial
implementation is given and the goal is to complete
it____.
The Sketch system provided Java-like Sketch language for writing
partial programs, and deployed SAT and inductive synthesis in a
counterexample-guided loop to complete them.  JSketch enabled
sketching Java programs____ by translating Java to Sketch.
PSketch focused on concurrent data structures and enabled sketching
them____.

Researchers developed several approaches to assist Alloy users build
their models correctly, e.g., by highlighting UNSAT
cores____, reducing
symmetries____,
improving scenario
exploration____,
supporting state
modeling____,
and supporting testing a la traditional unit
testing____.

ASketch____ introduced sketching of Alloy
models in the spirit of the Sketch system.  The heart of ASketch is an
efficient enumerator for non-equivalent relational
expressions____.  We use the basic ASketch
approach for creating the sketching problems for the LLMs.  A key
difference is that ASketch, just like the Sketch system, requires test
cases to be given as input in order to complete the sketch and
validate the resulting code.  In contrast, our use of LLMs does not
require test cases; in addition to the sketch, we simply provide a
natural language description of the desired property to the LLMs.

% LocalWords:  LLMs provers centric postconditions invariants SyPet
% LocalWords:  Javadocs Petri APIs EdSketch EdSynth TDS JSketch UNSAT
% LocalWords:  PSketch ASketch