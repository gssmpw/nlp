\section{Illustrative overview}
\label{sec:example}

\begin{figure}[!t]
\begin{center}
\begin{tabular}{@{}c@{}|@{\hspace{1ex}}c@{}|@{\hspace{1ex}}c@{}|@{\hspace{1ex}}c@{}}
\begin{minipage}[t]{.2\textwidth}
\raisebox{-\height}{\includegraphics[width=0.3in]{irreflexive/1}}
\end{minipage}
&
\begin{minipage}[t]{.25\textwidth}
\raisebox{-\height}{\includegraphics[width=1.1in]{irreflexive/2}}
\end{minipage}
&
\begin{minipage}[t]{.2\textwidth}
\raisebox{-\height}{\includegraphics[width=0.55in]{irreflexive/3}}
\end{minipage}
&
\begin{minipage}[t]{.2\textwidth}
\raisebox{-\height}{\includegraphics[width=0.8in]{irreflexive/4}}
\end{minipage}
\\
(a) & (b) & (c) & (d)
\end{tabular}
\end{center}
\caption{\label{fig:irreflexive-instances}Four example instances
  generated by the Alloy analyzer.  Each instance represents an
  irreflexive relation.  \CodeIn{S0}, \CodeIn{S1}, and \CodeIn{S2} are
  the atoms in signature \CodeIn{S}.  The directed edges represent the
  tuples in relation \CodeIn{r}.}
\end{figure}

This section illustrates how we employ LLMs for writing Alloy
formulas.  We describe the basics of Alloy and the notation for
creating sketching
problems~\cite{WangETALABZ2018ASketch,SolarLazemaPhD2008} as we
introduce them.

The following Alloy code introduces a set \CodeIn{S} (\CodeIn{sig}), a
binary relation \CodeIn{r: S$\times$ S}, and a \Intro{predicate}
(\CodeIn{pred}) named \CodeIn{Irreflexive} that characterizes an
irreflexive relation:

\begin{CodeOut}
\begin{Verbatim}
\BLUE{sig} S \{ r: \BLUE{set} S \}

\BLUE{pred} Irreflexive \{
  \GREEN{-- No element in S is related to itself}
  \BLUE{all} s, t: S | s->t \BLUE{in} r \BLUE{implies} s != t
\}

\BLUE{run} Irreflexive
\end{Verbatim}
\end{CodeOut}

The binary relation \CodeIn{r} is declared as a \Intro{field} in the
signature (\CodeIn{sig}) declaration of set \CodeIn{S}.  The keyword
\CodeIn{set} in the field declaration defines \CodeIn{r} to be an
arbitrary binary relation; alternatively, the keywords \CodeIn{one}
and \CodeIn{lone} can be used to define a total function and a partial
function respectively.  Any text between `\CodeIn{-{}-}' (or
`\CodeIn{$//$}') and the end-of-line is a comment and ignored by the
Alloy analyzer.  The body of the predicate \CodeIn{Irreflexive} uses a
universally quantified (\CodeIn{all}) formula to define irreflexivity
as:
%\[
``$\forall s,t \in S ~|~ (s, t) \in r \Rightarrow s \neq t$''.
%\]
The Alloy operator `\CodeIn{->}' is Cartesian product.  The
\CodeIn{run} command defines a constraint solving problem and
instructs the Alloy analyzer to create an \Intro{instance}, i.e.,
valuation for the set \CodeIn{S} and relation \CodeIn{r} such that the
constraint specified in the predicate \CodeIn{Irreflexive} is
satisfied.  The analyzer solves each problem with respect to a
\Intro{scope}, i.e., a bound on the universe of discourse, which can
be explicitly stated in the \CodeIn{run} command.  The default bound
is 3, i.e., up to 3 atoms in each signature.  The analyzer supports
instance enumeration for satisfiable formulas.
Fig~\ref{fig:irreflexive-instances} shows 4~example instances created
by the Alloy analyzer.

\subsection{Natural language to Alloy}

Consider using an LLM to create an Alloy formula from a natural
language description of the desired property.  To illustrate, we run
the following query using ChatGPT:

\noindent\hfil\rule{0.99\textwidth}{1pt}\hfil

\vspace*{-2ex}
\begin{CodeOut}
\begin{verbatim}
Implement the following Alloy predicate Irreflexive as defined in the comments:
sig S { r: set S }
pred Irreflexive {
  -- No element in S is related to itself
}
Output only the formula in the predicate body.
\end{verbatim}
\end{CodeOut}

\vspace*{-3ex}

\noindent\hfil\rule{0.99\textwidth}{1pt}\hfil

\noindent{}ChatGPT produces the following output:

\noindent\hfil\rule{0.99\textwidth}{1pt}\hfil

\vspace*{-2ex}
\begin{CodeOut}
\begin{verbatim}
all s: S | s not in s.r
\end{verbatim}
\end{CodeOut}

\vspace*{-3ex}

\noindent\hfil\rule{0.99\textwidth}{1pt}\hfil

ChatGPT formulates the irreflexivity property using universal
quantification with just one variable.  The operator `\CodeIn{.}' in
Alloy is a relational composition.  Specifically, when \CodeIn{s} is a
scalar and \CodeIn{r} is a binary relation, the expression
`\CodeIn{s.r}' denotes the relational image of \CodeIn{s} under
\CodeIn{r}.  Thus, ChatGPT's formulation states that ``$\forall s\in S
~|~ s \not\in s.r$''.  Note how the formula structure of ChatGPT's
output differs quite a bit from how we wrote irreflexivity in the
predicate \CodeIn{Irreflexive}.

We validate ChatGPT's output using the Alloy analyzer by: (1)~creating
a new Alloy predicate \CodeIn{ChatGPTOutput} that contains the output
of ChatGPT; and (2)~checking that it is equivalent to our predicate
\CodeIn{Irreflexive} that serves as the ground truth:

\begin{CodeOut}
\begin{Verbatim}
\BLUE{pred} ChatGPTOutput \{
  \BLUE{all} s: S | s \BLUE{not} \BLUE{in} s.r
\}

\BLUE{check} \{ Irreflexive <=> ChatGPTOutput \}
\end{Verbatim}
\end{CodeOut}
The \CodeIn{check} command instructs the Alloy analyzer to find a
counterexample to the given formula, which asserts the logical
equivalence of our reference predicate and ChatGPT's output.  The
The alloy analyzer reports no counterexample and validates the correctness
of the output of ChatGPT (with respect to the default scope).

\subsection{Alloy to Alloy}
\vspace*{-1ex}

Next, consider using an LLM to create a new Alloy formula equivalent
to a given property in Alloy.  To illustrate, we run the following
query using DeepSeek:

\noindent\hfil\rule{0.99\textwidth}{1pt}\hfil

\vspace*{-2ex}
\begin{CodeOut}
\begin{verbatim}
Give an Alloy formula that is equivalent to the following predicate Irreflexive:
sig S { r: set S }
pred Irreflexive {
  all s, t: S | s->t in r implies s != t
}
Output only the formula.
\end{verbatim}
\end{CodeOut}

\vspace*{-3ex}

\noindent\hfil\rule{0.99\textwidth}{1pt}\hfil

\noindent{}DeepSeek produces the following output:

\noindent\hfil\rule{0.99\textwidth}{1pt}\hfil

\vspace*{-2ex}
\begin{CodeOut}
\begin{verbatim}
all s: S | s->s not in r
\end{verbatim}
\end{CodeOut}
\vspace*{-3ex}

\noindent\hfil\rule{0.99\textwidth}{1pt}\hfil

\noindent{}DeepSeek uses universal quantification with one variable
and states that ``$\forall s\in S ~|~ (s, s) \not\in r$''.  Note the
difference in the logical structure of DeepSeek's output and the input
formula we provided it.

We use the Alloy analyzer once again to validate the LLM's output.
The analyzer reports that no counterexample is found, i.e., the output
of DeepSeek is correct (with respect to the default scope).

\subsection{Sketching Alloy}
\vspace*{-1ex}

Next, consider using an LLM to complete the
sketch~\cite{SolarLazemaPhD2008,WangETALABZ2018ASketch} of an Alloy
model.  To illustrate, we run the following query using ChatGPT (in a
fresh session):

\noindent\hfil\rule{0.99\textwidth}{1pt}\hfil

\vspace*{-2ex}
\begin{CodeOut}
\begin{verbatim}
Complete the following sketch of the Alloy predicate Irreflexive with
respect to the property defined in the comments:
sig S { r: set S }
pred Irreflexive {
  -- No element in S is related to itself
  all s, t: S | s->t in r implies \E,e\ \O,o\ \E,e\
}
e := {| S|s|t|(s|t)->(s|t)|(s|t).r |}
o := {| in|!in|=|!= |}
Output only the completed predicate.
\end{verbatim}
\end{CodeOut}
\vspace*{-3ex}

\noindent\hfil\rule{0.99\textwidth}{1pt}\hfil

\noindent{}ChatGPT produces the following output:

\noindent\hfil\rule{0.99\textwidth}{1pt}\hfil

\vspace*{-2ex}
\begin{CodeOut}
\begin{verbatim}
pred Irreflexive {
  -- No element in S is related to itself
  all s, t: S | s -> t in r implies s != t
}
\end{verbatim}
\end{CodeOut}
\vspace*{-3ex}

\noindent\hfil\rule{0.99\textwidth}{1pt}\hfil

The sketch in the input query follows the notation used in previous
work~\cite{SolarLazemaPhD2008,WangETALABZ2018ASketch}.  There are
three \Intro{holes} in the sketch: two expression holes
(\CodeIn{$\backslash$E,e$\backslash$}) and one operator hole
(\CodeIn{$\backslash$O,o$\backslash$}).  The sketch defines a set of
possible completions for each hole.  Each expression hole can be
completed with one of the following nine~expressions: \CodeIn{\{`S',
  `s', `t', `s->s', `s->t', `t->s', `t->t', `s.r', `t.r'\}}.  The
operator hole can be completed with one of the following
four~operators: \CodeIn{\{`in', `!in', `=', `!='\}}.

Note that ChatGPT's output faithfully conforms to the structure of the
input sketch and each hole is completed appropriately.  Note also that
ChatGPT was given no directions regarding what a sketch is, let alone
how to complete it.  Nonetheless, the output is in fact identical to
our ground truth predicate, and is indeed correct.

% LocalWords:  LLMs sig pred Irreflexive irreflexive satisfiable LLM
% LocalWords:  ChatGPT ChatGPTOutput ChatGPT's DeepSeek LLM's ASketch
% LocalWords:  irreflexivity DeepSeek's
