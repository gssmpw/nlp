While we have so far discussed only the standard notion of equivalence (that two programs produce the same output on any input), there are other, more precise definitions of equivalence used for each category in the benchmark. For each category, we provide the definition of equivalence, which is included in the prompt when testing LLM reasoning capabilities. We describe the process of generating (in)equivalent pairs for the following six categories:

\begin{itemize}
    \item \textbf{\dce}: C program pairs generated via the compiler's dead code elimination (DCE) pass (\Cref{subsec:dce}).

    \item \textbf{\cuda}: CUDA program pairs created by applying different scheduling strategies using a tensor compiler (\Cref{subsec:cuda}).
    
    \item \textbf{\ass}: x86-64 assembly program pairs generated by a superoptimizer (\Cref{subsec:x86}).
    
    \item \textbf{\oja}, \textbf{\ojv}, \textbf{\ojva}: Python program pairs from online judge submissions, featuring algorithmic differences (\oja), variable-renaming transformations (\ojv), and combinations of both (\ojva) (\Cref{subsec:oj}).
\end{itemize}





\begin{figure}[!tb]
\centering
\includegraphics[width=\columnwidth]{figure/dce.pdf}
\caption{\textbf{An inequivalent pair from the \dce category in \name.} In the left program, \CodeIn{c = 1} is dead code and has no effect on the program state, whereas in the right program, it is executed and alters the program state. Such cases are generated using the Dead Code Elimination (DCE) pass in compilers.}
\label{fig:dce}
\end{figure}

\begin{figure*}[!tb]
\centering
\includegraphics[width=\textwidth]{figure/cuda.pdf}
\caption{\textbf{An equivalent pair from the \cuda category in \name.} Both programs perform matrix-vector multiplication ($y = Ax$). The right-hand program uses \emph{shared memory tiling} to improve performance. Tensor compilers are utilized to explore different \emph{scheduling strategies}, automating the generation.}
\label{fig:cuda}
\end{figure*}


\subsection{Pairs from Program Analysis (DCE)}
\label{subsec:dce}
Dead code elimination (DCE), a compiler pass, removes useless program statements. After DCE, remaining statements in the modified program naturally {\em correspond} to those in the original program.

\paragraph{Definition of Equivalence.} Two programs are considered equivalent if, when executed on the same input, they \emph{always} have identical \emph{program states} at all corresponding points reachable by program execution. We expect language models to identify differences between the two programs, align their states, and determine whether these states are consistently identical.

\paragraph{Example.} \Cref{fig:dce} illustrates an inequivalent pair of C programs. In the left program, the condition (\CodeIn{p1 == p2}) compares the memory address of the first element of the array \CodeIn{b} with that of the static variable \CodeIn{c}. Since \CodeIn{b} and \CodeIn{c} reside in different memory locations, this condition can never be satisfied. As a result, the assignment \CodeIn{c = 1} is never executed in the left program but is executed in the right program. This difference in program state during execution renders the pair inequivalent.

\paragraph{Automation.} This reasoning process is automated by compilers through \emph{alias analysis}, which statically determines whether two pointers can reference the same memory location. Based on this analysis, the compiler’s \emph{Dead Code Elimination (DCE)} pass removes code that does not affect program semantics to improve performance.

\paragraph{Dataset Generation.} We utilize CSmith~\cite{yang2011finding} to create an initial pool of random C programs. Building on techniques from prior compiler testing research~\cite{theodoridis2022finding}, we implement an LLVM-based tool~\cite{lattner2004llvm} to classify code snippets as either dead or live. Live code is further confirmed by executing random inputs with observable side effects. Equivalent program pairs are generated by eliminating dead code, while inequivalent pairs are generated by removing live code.

\subsection{Pairs from Compiler Scheduling (\cuda)}
\label{subsec:cuda}

\paragraph{Definition of Equivalence.} Two CUDA programs are considered equivalent if they produce the same mathematical output for any valid input, \emph{disregarding floating-point rounding errors}. This definition \emph{differs} from that in \Cref{subsec:dce}, as it does not require the internal program states to be identical during execution.

\paragraph{Example.} \Cref{fig:cuda} shows an equivalent CUDA program pair. Both compute matrix-vector multiplication  $y=Ax$, where $A$ has dimensions (R, C) and $x$ has size C. The right-hand program applies the \emph{shared memory tiling} technique, loading \CodeIn{x} into shared memory \CodeIn{tile} (declared with \CodeIn{\_\_shared\_\_}). Synchronization primitives \CodeIn{\_\_syncthreads()} are properly inserted to prevent synchronization issues.

\paragraph{Automation.} The program transformation can be automated with tensor compilers, which provide a set of \emph{schedules} to optimize loop-based programs. These schedules include loop tiling, loop fusion, loop reordering, loop unrolling, vectorization, and cache optimization. For any given schedule, the compiler can generate the transformed code. While different schedules can significantly impact program performance on the GPU, they do not affect the program's correctness (assuming no compiler bugs), providing the foundation for automation.

\paragraph{Dataset Generation.} We utilize TVM as the tensor compiler~\cite{chen2018tvm} and sample tensor program schedules from TenSet~\cite{zheng2021tenset} to generate equivalent CUDA program pairs. Inequivalent pairs are created by sampling code from different tensor programs.


\begin{figure}[!tb]
\centering
\includegraphics[width=\columnwidth]{figure/x86.pdf}
\caption{\textbf{An equivalent pair from the \ass category in \name.} Both programs are compiled from the same C function shown above—the left using a compiler and the right using a \emph{superoptimizer}. The function counts the number of set bits in the input \CodeIn{\%rdi} register and stores the result in \CodeIn{\%rax}. Their equivalence has been formally verified by the superoptimizer.}
\label{fig:x86}
\end{figure}

\subsection{Pairs from a Superoptimizer (\ass)}
\label{subsec:x86}

\paragraph{Definition of Equivalence.} Two x86-64 assembly programs are considered equivalent if, for any input provided in the specified input registers, both programs produce identical outputs in the specified output registers. Differences in other registers or memory are ignored for equivalence checking.

\paragraph{Example.} \Cref{fig:x86} shows an example of an equivalent program pair in x86-64 assembly. Both programs implement the same C function, which counts the number of bits set to 1 in the variable \CodeIn{x} (mapped to the \CodeIn{\%rdi} register) and stores the result in \CodeIn{\%rax}. The left-hand program, generated by GCC with O3 optimization, uses a loop to count each bit individually, while the right-hand program, produced by a superoptimizer, leverages the \CodeIn{popcnt} instruction, a hardware-supported operation for efficient bit counting. The superoptimizer verifies that both programs are semantically equivalent. Determining this equivalence requires a solid understanding of x86-64 assembly semantics and the ability to reason about all possible bit patterns.

\paragraph{Automation.} A superoptimizer searches a space of programs to find one equivalent to the target. Test cases efficiently prune incorrect candidates, while formal verification guarantees the correctness of the optimized program. Superoptimizers apply aggressive and non-local transformations, making semantic equivalence reasoning more challenging. For example, in \Cref{fig:x86}, while a traditional compiler translates the loop in the source C program into a loop in assembly, a superoptimizer can find a more optimal instruction sequence by leveraging specialized hardware instructions. Such semantic equivalence is beyond the scope of traditional compilers.

\paragraph{Dataset Generation.} We use Stoke~\cite{schkufza2013stochastic}  to generate program pairs. Assembly programs are sampled from prior work~\cite{koenig2021adaptive}, and Stoke applies transformations to produce candidate programs. If verification succeeds, the pair is labeled as equivalent; if the generated test cases fail, it is labeled as inequivalent.


\begin{figure}[!tb]
\centering
\includegraphics[width=\columnwidth]{figure/oj.pdf}
\caption{\textbf{Equivalent pairs from the \oja, \ojv, \ojva categories in \name.} \oja pairs demonstrate \emph{algorithmic equivalence}, \ojv pairs involve \emph{variable renaming} transformations, and \ojva pairs combine \emph{both} types of variations.}
\label{fig:oj}
\end{figure}


\subsection{Pairs from Programming Contests}
\label{subsec:oj}

\paragraph{Definition of Equivalence.} Two programs are considered equivalent if they solve the same problem by producing the same output for any valid input, as defined by the problem description. Both programs, along with the problem description, are provided to determine equivalence.

\paragraph{Example.} Given the problem description in \Cref{fig:oj}, all four programs are equivalent as they correctly compute the Fibonacci number. The \textbf{\oja} pairs demonstrate \textbf{algorithmic} equivalence—the left-hand program uses recursion, while the right-hand program employs a for-loop. The \textbf{\ojv} pairs are generated through \textbf{variable renaming}, a \textbf{pure syntactic transformation} that can obscure the program’s semantics by removing meaningful variable names. The \textbf{\ojva} pairs combine \textbf{both} algorithmic differences and variable renaming.

\paragraph{Dataset Generation.}
We sample Python submissions using a publicly available dataset from Online Judge (OJ)~\cite{puri2021codenet}. For \oja pairs, accepted submissions are treated as equivalent, while pairs consisting of an accepted submission and a wrong-answer submission are considered inequivalent. Variable renaming transformations are automated with an open-source tool~\cite{PythonTool}.