\subsection{Prompts}
\label{subsec:app:prompt}

\lstset{style=mystyle}

\subsubsection{DCE Category}
We show the prompts for 0-shot, 4-shot, 0-shot CoT, 4-shot CoT settings.

\paragraph{0-Shot.} You are here to judge if two C programs are semantically equivalent.\\
    Here equivalence means that, when run on the same input, the two programs always have the same program state at all corresponding points reachable by program execution.\\
    \text{    [Program 1]}:\\
    \begin{lstlisting}
    {program_1_code}
    \end{lstlisting}
    \text{    [Program 2]}:\\
    \begin{lstlisting}
    {program_2_code}
    \end{lstlisting}
    
    Please only output the answer of whether the two programs are equivalent or not. You should only output YES or NO.\\
\\

\paragraph{0-shot CoT.} You are here to judge if two C programs are semantically equivalent.\\
    Here equivalence means that, when run on the same input, the two programs always have the same program state at all corresponding points reachable by program execution.\\
    \text{    [Program 1]}:
    \begin{lstlisting}
    {program_1_code}
    \end{lstlisting}
    \text{    [Program 2]}:\\
    \begin{lstlisting}
    {program_2_code}
    \end{lstlisting}
    
    Please output the answer of whether the two programs are equivalent or not. You should output YES or NO in the end. Let's think step by step.\\
\\

\paragraph{4-shot.} You are here to judge if two C programs are semantically equivalent.\\
Here equivalence means that, when run on the same input, the two programs always have the same program state at all corresponding points reachable by program execution.\\
\noindent\textbf{[Example 1]}:\\
\text{    [Program 1]}:\\
      \begin{lstlisting}
        int main() {
          int x = 0;
          if (false) {
            x = 1;
          }
          return 0;
        }
      \end{lstlisting}
\text{    [Program 2]}:\\
      \begin{lstlisting}
        int main() {
          int x = 0;
          if (true) {
            x = 1;
          }
          return 0;
        }
      \end{lstlisting}
    \text{[Answer]}: NO\\
\\
\noindent\textbf{[Example 2]}:\\
      \text{    [Program 1]}:\\
      \begin{lstlisting}
        int main() {
          int x = 0;
          if (false) {
            x = 1;
          }
          return 0;
        }
      \end{lstlisting}
      \text{    [Program 2]}:\\
      \begin{lstlisting}
        int main() {
          int x = 0;
          return 0;
        }
      \end{lstlisting}
      [Answer]: YES\\
\\
    \noindent\textbf{[Example 3]}:\\
      \text{    [Program 1]}:\\
      \begin{lstlisting}
        char b[2];
        static int c = 0;
        int main() {
          if (&b[0] == &c) {
              c = 1;
          }
          return 0;
        }
      \end{lstlisting}
      \text{    [Program 2]}:\\
      \begin{lstlisting}
        char b[2];
        static int c = 0;
        int main() {
          c = 1;
          return 0;
        }
      \end{lstlisting}
      [Answer]: NO\\
\\
    \noindent\textbf{[Example 4]}:\\
      \text{    [Program 1]}:\\
      \begin{lstlisting}
        char b[2];
        static int c = 0;
        int main() {
          if (&b[0] == &c) {
              c = 1;
          }
          return 0;
        }
      \end{lstlisting}
      \text{    [Program 2]}:\\
      \begin{lstlisting}
        char b[2];
        static int c = 0;
        int main() {
          return 0;
        }
      \end{lstlisting}
      [Answer]: YES\\
\\
    \text{    [Program 1]}:\\
    \begin{lstlisting}
    {program_1_code}
    \end{lstlisting}
    \text{    [Program 2]}:\\
    \begin{lstlisting}
    {program_2_code}
    \end{lstlisting}
    
    Please only output the answer of whether the two programs are equivalent or not. You should only output YES or NO.\\

\paragraph{4-shot CoT.} You are here to judge if two C programs are semantically equivalent.\\
    Here equivalence means that, when run on the same input, the two programs always have the same program state at all corresponding points reachable by program execution.\\

\noindent\textbf{[Example 1]:}\\
      \text{    [Program 1]}:\\
      \begin{lstlisting}
        int main() {
          int x = 0;
          if (false) {
            x = 1;
          }
          return 0;
        }
      \end{lstlisting}
      \text{    [Program 2]}:\\
      \begin{lstlisting}
        int main() {
          int x = 0;
          if (true) {
            x = 1;
          }
          return 0;
        }
      \end{lstlisting}
      [Answer]: x = 1 in program 1 will not be executed, but x = 1 in program 2 will be executed, leading to different program states.\\
                The answer is NO.\\
\\
    \noindent\textbf{[Example 2]}:\\
      \text{    [Program 1]}:\\
      \begin{lstlisting}
        int main() {
          int x = 0;
          if (false) {
            x = 1;
          }
          return 0;
        }
      \end{lstlisting}
      \text{    [Program 2]}:\\
      \begin{lstlisting}
        int main() {
          int x = 0;
          return 0;
        }
      \end{lstlisting}
      [Answer]: x = 1 in program 1 will not be executed, and this statement does not exist in program 2. Program states are always the same.\\
                The answer is YES.\\
    \noindent\textbf{[Example 3]}:\\
\\
      \text{    [Program 1]}:\\
      \begin{lstlisting}
        char b[2];
        static int c = 0;
        int main() {
          if (&b[0] == &c) {
              c = 1;
          }
          return 0;
        }
      \end{lstlisting}
      \text{    [Program 2]}:\\
      \begin{lstlisting}
        char b[2];
        static int c = 0;
        int main() {
          c = 1;
          return 0;
        }
      \end{lstlisting}
      [Answer]: The if statement in program 1 checks whether the memory address of b[0] equals c's address.\\
                c = 1 will not be executed in program 1, leading to a program state different from program 2.\\
                The answer is NO.\\
\\
    \noindent\textbf{[Example 4]}:\\
      \text{    [Program 1]}:\\
      \begin{lstlisting}
        char b[2];
        static int c = 0;
        int main() {
          if (&b[0] == &c) {
              c = 1;
          }
          return 0;
        }
      \end{lstlisting}
      \text{    [Program 2]}:\\
      \begin{lstlisting}
        char b[2];
        static int c = 0;
        int main() {
          return 0;
        }
      \end{lstlisting}
      [Answer]: The if statement in program 1 checks whether the memory address of b[0] equals c's address.\\
                c = 1 will not be executed in program 1, so the two programs always have the same states.\\
                The answer is YES.\\
    \text{    [Program 1]}:\\
    \begin{lstlisting}
    {program_1_code}
    \end{lstlisting}
    \text{    [Program 2]}:\\
    \begin{lstlisting}
    {program_2_code}
    \end{lstlisting}
    
    Please output the answer of whether the two programs are equivalent or not. You should output YES or NO in the end. Let's think step by step.


\subsubsection{CUDA Category}
We show the prompts for 0-shot and 4-shot CoT settings.

\paragraph{0-Shot.} You are here to judge if two CUDA programs are semantically equivalent.\\
Here equivalence means that, when run on the same valid input, the two programs always compute the same mathematical output (neglecting floating point rounding errors).\\
\text{    [Program 1]}:
\begin{lstlisting}
{program_1_code}
\end{lstlisting}
\text{    [Program 2]}:
\begin{lstlisting}
{program_2_code}
\end{lstlisting}

Please only output the answer of whether the two programs are equivalent or not. You should only output YES or NO.\\

\paragraph{4-shot CoT.} You are here to judge if two CUDA programs are semantically equivalent.\\
    Here equivalence means that, when run on the same valid input, the two programs always compute the same mathematical output (neglecting floating point rounding errors).\\

\noindent\textbf{[Example 1]:}\\
      \text{    [Program 1]}:\\
      \begin{lstlisting}
        __global__ void sgemm_naive(int M, int N, int K, float alpha,
          const float *A, const float *B, float beta, float *C) {
          const uint x = blockIdx.x * blockDim.x + threadIdx.x;
          const uint y = blockIdx.y * blockDim.y + threadIdx.y;

          if (x < M && y < N) {
            float tmp = 0.0;
            for (int i = 0; i < K; ++i) {
              tmp += A[x * K + i] * B[i * N + y];
            }
            C[x * N + y] = alpha * tmp + beta * C[x * N + y];
          }
        }
      \end{lstlisting}
      \text{    [Program 2]}:\\
      \begin{lstlisting}
        __global__ void sgemm_naive(int M, int N, int K, float alpha,
          const float *A, const float *B, float beta, float *C) {
          const uint x = blockIdx.x * blockDim.x + threadIdx.x;
          const uint y = blockIdx.y * blockDim.y + threadIdx.y;

          if (x < M && y < N) {
            float tmp = 0.0;
            for (int i = 0; i < K; ++i) {
              tmp += A[x * K + i] * B[i * N + y];
            }
            C[x * N + y] = beta * tmp + alpha * C[x * N + y];
          }
        }
      \end{lstlisting}
      [Answer]: Program 1 computes C = alpha*(A@B) + beta*C, while Program 2 computes C = beta*(A@B) + alpha*C.\\
               The answer is NO.\\
\\
\noindent\textbf{[Example 2]:}\\
      \text{    [Program 1]}:\\
      \begin{lstlisting}
        __global__ void sgemm_naive(int M, int N, int K, float alpha,
          const float *A, const float *B, float beta, float *C) {
          const uint x = blockIdx.x * blockDim.x + threadIdx.x;
          const uint y = blockIdx.y * blockDim.y + threadIdx.y;

          if (x < M && y < N) {
            float tmp = 0.0;
            for (int i = 0; i < K; ++i) {
              tmp += A[x * K + i] * B[i * N + y];
            }
            C[x * N + y] = alpha * tmp + beta * C[x * N + y];
          }
        }
      \end{lstlisting}
      \text{    [Program 2]}:\\
      \begin{lstlisting}
        template <const uint BLOCKSIZE>
        __global__ void sgemm_global_mem_coalesce(int M, int N,
          int K, float alpha, const float *A, const float *B,
          float beta, float *C) {
          const int cRow = blockIdx.x * BLOCKSIZE
                         + (threadIdx.x / BLOCKSIZE);
          const int cCol = blockIdx.y * BLOCKSIZE
                         + (threadIdx.x % BLOCKSIZE);

          if (cRow < M && cCol < N) {
            float tmp = 0.0;
            for (int i = 0; i < K; ++i) {
              tmp += A[cRow * K + i] * B[i * N + cCol];
            }
            C[cRow * N + cCol] = alpha * tmp
                                + beta * C[cRow * N + cCol];
          }
        }
      \end{lstlisting}
      [Answer]: Both programs compute C = alpha*(A@B) + beta*C.\\
                Program 2 improves performance with global memory coalescing, which does not change computation results.\\
                The answer is YES.\\
\\
\noindent\textbf{[Example 3]:}\\
      \text{    [Program 1]}:\\
      \begin{lstlisting}
        __global__ void sgemm_naive(int M, int N, int K, float alpha,
          const float *A, const float *B, float beta, float *C) {
          const uint x = blockIdx.x * blockDim.x + threadIdx.x;
          const uint y = blockIdx.y * blockDim.y + threadIdx.y;

          if (x < M && y < N) {
            float tmp = 0.0;
            for (int i = 0; i < K; ++i) {
              tmp += A[x * K + i] * B[i * N + y];
            }
            C[x * N + y] = alpha * tmp + beta * C[x * N + y];
          }
        }
      \end{lstlisting}
      \text{    [Program 2]}:\\
      \begin{lstlisting}
        template <const int BLOCKSIZE>
        __global__ void sgemm_shared_mem_block(int M, int N, int K,
          float alpha, const float *A, const float *B, float beta,
          float *C) {
          const uint cRow = blockIdx.x;
          const uint cCol = blockIdx.y;

          __shared__ float As[BLOCKSIZE * BLOCKSIZE];
          __shared__ float Bs[BLOCKSIZE * BLOCKSIZE];

          const uint threadCol = threadIdx.x % BLOCKSIZE;
          const uint threadRow = threadIdx.x / BLOCKSIZE;

          A += cRow * BLOCKSIZE * K;
          B += cCol * BLOCKSIZE;
          C += cRow * BLOCKSIZE * N + cCol * BLOCKSIZE;

          float tmp = 0.0;
          for (int bkIdx = 0; bkIdx < K; bkIdx += BLOCKSIZE) {
            As[threadRow * BLOCKSIZE + threadCol] =
                            A[threadRow * K + threadCol];
            Bs[threadRow * BLOCKSIZE + threadCol] =
                            B[threadRow * N + threadCol];

            A += BLOCKSIZE;
            B += BLOCKSIZE * N;

            for (int dotIdx = 0; dotIdx < BLOCKSIZE; ++dotIdx) {
              tmp += As[threadRow * BLOCKSIZE + dotIdx] *
                    Bs[dotIdx * BLOCKSIZE + threadCol];
            }
          }
          C[threadRow * N + threadCol] = alpha * tmp
                            + beta * C[threadRow * N + threadCol];
        }
      \end{lstlisting}
      [Answer]: Both programs aim to compute C = alpha*(A@B) + beta*C, but there are two synchronization bugs in Program 2.\\
                Before entering the inner loop to compute tmp, there is no guarantee that the cache (As, Bs) is fully populated by all threads.\\
                At the end of each iteration of bkIdx, faster threads may fetch the next block into the cache before slower threads are done.\\
                The answer is NO.\\
\\
\noindent\textbf{[Example 4]:}\\
      \text{    [Program 1]}:\\
      \begin{lstlisting}
        __global__ void sgemm_naive(int M, int N, int K, float alpha,
          const float *A, const float *B, float beta, float *C) {
          const uint x = blockIdx.x * blockDim.x + threadIdx.x;
          const uint y = blockIdx.y * blockDim.y + threadIdx.y;

          if (x < M && y < N) {
            float tmp = 0.0;
            for (int i = 0; i < K; ++i) {
              tmp += A[x * K + i] * B[i * N + y];
            }
            C[x * N + y] = alpha * tmp + beta * C[x * N + y];
          }
        }
      \end{lstlisting}
      \text{    [Program 2]}:\\
      \begin{lstlisting}
        template <const int BLOCKSIZE>
        __global__ void sgemm_shared_mem_block(int M, int N, int K,
          float alpha, const float *A, const float *B, float beta,
          float *C) {
          const uint cRow = blockIdx.x;
          const uint cCol = blockIdx.y;

          __shared__ float As[BLOCKSIZE * BLOCKSIZE];
          __shared__ float Bs[BLOCKSIZE * BLOCKSIZE];

          const uint threadCol = threadIdx.x % BLOCKSIZE;
          const uint threadRow = threadIdx.x / BLOCKSIZE;

          A += cRow * BLOCKSIZE * K;
          B += cCol * BLOCKSIZE;
          C += cRow * BLOCKSIZE * N + cCol * BLOCKSIZE;

          float tmp = 0.0;
          for (int bkIdx = 0; bkIdx < K; bkIdx += BLOCKSIZE) {
            As[threadRow * BLOCKSIZE + threadCol] =
                    A[threadRow * K + threadCol];
            Bs[threadRow * BLOCKSIZE + threadCol] =
                    B[threadRow * N + threadCol];

            __syncthreads();
            A += BLOCKSIZE;
            B += BLOCKSIZE * N;

            for (int dotIdx = 0; dotIdx < BLOCKSIZE; ++dotIdx) {
              tmp += As[threadRow * BLOCKSIZE + dotIdx] *
                    Bs[dotIdx * BLOCKSIZE + threadCol];
            }
            __syncthreads();
          }
          C[threadRow * N + threadCol] = alpha * tmp
                    + beta * C[threadRow * N + threadCol];
        }
      \end{lstlisting}
      [Answer]: Both programs aim to compute C = alpha*(A@B) + beta*C.\\
                Program 2 load a chunk of A and a chunk of B from global memory into shared memory.\\
                Such shared memory cache-blocking improves performance but does not change the correctness of the computation (no bugs found).\\
                The answer is YES.\\
      \text{    [Program 1]}:\\
      \begin{lstlisting}
      {program_1_code}
      \end{lstlisting}
      \text{    [Program 2]}:\\
      \begin{lstlisting}
      {program_2_code}
      \end{lstlisting}

      Please output the answer of whether the two programs are equivalent or not. You should output YES or NO in the end. Let's think step by step.



\subsubsection{x86-64 Category}
We show the prompts for 0-shot and 4-shot CoT settings.

\paragraph{0-shot.} You are here to judge if two x86-64 programs are semantically equivalent.\\
    Here equivalence means that, given any input bits in the register \texttt{\{def\_in\}}, the two programs always have the same bits in register \texttt{\{live\_out\}}. Differences in other registers do not matter for equivalence checking.\\

\text{[Program 1]:}\\
\begin{lstlisting}
{program_1_code}
\end{lstlisting}

\text{[Program 2]:}\\
\begin{lstlisting}
{program_2_code}
\end{lstlisting}

Please only output the answer of whether the two programs are equivalent or not. You should only output YES or NO.\\

\paragraph{4-shot CoT.} You are here to judge if two x86-64 programs are semantically equivalent.\\
    Here equivalence means that, given any input bits in the register \texttt{\{def\_in\}}, the two programs always have the same bits in register \texttt{\{live\_out\}}. Differences in other registers do not matter for equivalence checking.\\

\noindent\textbf{[Example 1]:} In this example, the input register is \texttt{\%rdi}, and output register is \texttt{\%rdi}.\\
\text{[Program 1]:}\\
\begin{lstlisting}
movq -8(%rsp), %rdi
.L4:
sall (%rdi)
movq 8(%rdi), %rdi
.L6:
testq %rdi, %rdi
jne .L4
\end{lstlisting}
\text{[Program 2]:}\\
\begin{lstlisting}
.L4:
movq -8(%rsp), %rdi
sall (%rdi)
movq 8(%rdi), %rdi
movq %rdi, -8(%rsp)
.L6:
movq -8(%rsp), %rdi
testq %rdi, %rdi
jne .L4
\end{lstlisting}
[Answer]: The additional instructions in Program 2 are: \texttt{movq \%rdi, -8(\%rsp)} and \texttt{movq -8(\%rsp), \%rdi}.\\
Program 2 stores the updated \texttt{\%rdi} value back into \texttt{-8(\%rsp)} after each iteration and reloads it before the next iteration. But this does not affect the value of \texttt{\%rdi}.\\
The answer is YES.\\

\noindent\textbf{[Example 2]:} In this example, the input register is \texttt{\%rdi}, and output register is \texttt{\%rdi}.\\
\text{[Program 1]:}\\
\begin{lstlisting}
movq -8(%rsp), %rdi
.L4:
sall (%rdi)
movq 8(%rdi), %rdi
.L6:
testq %rdi, %rdi
jne .L4
\end{lstlisting}
\text{[Program 2]:}\\
\begin{lstlisting}
.L4:
movq -8(%rsp), %rdi
sall (%rdi)
movq 8(%rdi), %rdi
movq %rdi, -8(%rsp)
.L6:
movq -8(%rsp), %rdi
addq $1, %rdi
testq %rdi, %rdi
jne .L4
\end{lstlisting}
[Answer]: The additional instruction from Program 2 includes \texttt{addq \$1, \%rdi}, which increments \texttt{\%rdi} by 1 before the test condition.\\
The two programs do not produce the same result for \texttt{\%rdi}.\\
The answer is NO.\\

\noindent\textbf{[Example 3]:} In this example, the input register is \texttt{\%rdi}, and output register is \texttt{\%rax}.\\
\text{[Program 1]:}\\
\begin{lstlisting}
.text
.globl _Z6popcntm
.type _Z6popcntm, @function
_Z6popcntm:
xorl   %eax,%eax
testq  %rdi,%rdi
je     .L_4005b0
nop
.L_4005a0:
movq   %rdi,%rdx
andl   $0x1,%edx
addq   %rdx,%rax
shrq   $0x1,%rdi
jne    .L_4005a0
retq
.L_4005b0:
retq
nop
nop
.size _Z6popcntm, .-_Z6popcntm
\end{lstlisting}
\text{[Program 2]:}\\
\begin{lstlisting}
.text
.globl _Z6popcntm
.type _Z6popcntm @function
_Z6popcntm:
popcnt %rdi, %rax
retq
.size _Z6popcntm, .-_Z6popcntm
\end{lstlisting}
[Answer]: Both programs compute the population count (the number of 1s in a number's binary representation) of \texttt{\%rdi} and store the result in \texttt{\%rax}.\\
The answer is YES.\\

\noindent\textbf{[Example 4]:} In this example, the input register is \texttt{\%rdi}, and output register is \texttt{\%rax}.\\
\text{[Program 1]:}\\
\begin{lstlisting}
.text
.globl _Z6popcntm
.type _Z6popcntm, @function
_Z6popcntm:
xorl   %eax, %eax
testq  %rdi, %rdi
je     .L_4005b0
nop
.L_4005a0:
movq   %rdi, %rdx
andl   $0x1, %edx
addq   %rdx, %rax
addq   $1, %rax
shrq   $0x1, %rdi
jne    .L_4005a0
retq
.L_4005b0:
retq
nop
nop
.size _Z6popcntm, .-_Z6popcntm
\end{lstlisting}
\text{[Program 2]:}\\
\begin{lstlisting}
.text
.globl _Z6popcntm
.type _Z6popcntm @function
_Z6popcntm:
popcnt %rdi, %rax
retq
.size _Z6popcntm, .-_Z6popcntm
\end{lstlisting}
[Answer]: The instruction \texttt{addq \$1, \%rax} in Program 1 introduces a discrepancy by adding the number of loop iterations to the output register.\\
Program 2 simply computes the population count, but Program 1 adds an extra increment for each bit in \texttt{\%rdi}.\\
The answer is NO.\\

The input register is \texttt{\{def\_in\}}, and the output register is \texttt{\{live\_out\}}.\\
\text{[Program 1]:}\\
\begin{lstlisting}
{program_1_code}
\end{lstlisting}
\text{[Program 2]:}\\
\begin{lstlisting}
{program_2_code}
\end{lstlisting}

Please output the answer of whether the two programs are equivalent or not. You should output YES or NO in the end. Let's think step by step.


\subsubsection{OJ\_A Category}
We show the prompts for both 0-shot and 4-shot CoT settings.

\paragraph{0-shot.} You are here to judge if two Python programs are semantically equivalent.\\
    You will be given \text{[Problem Description]}, \text{[Program 1]} and \text{[Program 2]}.\\
    Here equivalence means that, given any valid input under the problem description, the two programs will always give the same output.\\

\noindent\text{[Problem Description]}:\\
\begin{lstlisting}
{problem_html}
\end{lstlisting}

\noindent\text{[Program 1]}:\\
\begin{lstlisting}
{program_1_code}
\end{lstlisting}

\noindent\text{[Program 2]}:\\
\begin{lstlisting}
{program_2_code}
\end{lstlisting}

Please only output the answer of whether the two programs are equivalent or not. You should only output YES or NO.

\paragraph{4-shot CoT.} You are here to judge if two Python programs are semantically equivalent.\\
You will be given \text{[Problem Description]}, \text{[Program 1]}, and \text{[Program 2]}.\\
Here equivalence means that, given any valid input under the problem description, the two programs will always give the same output.\\

\noindent\textbf{[Example 1]:}\\
\text{[Problem Description]:}\\
Given a single line of input containing integers separated by spaces, sort the integers in ascending order and print them in a single line separated by spaces.\\
Input: A single line containing integers A[i] ($-10^6 \leq A[i] \leq 10^6$, $1 \leq n \leq 10^6$).\\
Output: A single line of integers sorted in ascending order.\\
Example Input: 4 2 5 1 3\\
Example Output: 1 2 3 4 5\\

\text{[Program 1]:}\\
\begin{lstlisting}
def bubble_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        for j in range(n - 1 - i):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

nums = list(map(int, input().split()))
sorted_nums = bubble_sort(nums)
print(" ".join(map(str, sorted_nums)))
\end{lstlisting}

\text{[Program 2]:}\\
\begin{lstlisting}
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr

nums = list(map(int, input().split()))
sorted_nums = insertion_sort(nums)
print(" ".join(map(str, sorted_nums)))
\end{lstlisting}

[Answer]: Program 1 is bubble sort, and Program 2 is insertion sort.\\
The answer is YES.\\

\noindent\textbf{[Example 2]:}\\
\text{[Problem Description]:} Same as Example 1.\\
\text{[Program 1]:} Same as Program 1 from Example 1.\\
\text{[Program 2]:}\\
\begin{lstlisting}
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] < key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr

nums = list(map(int, input().split()))
sorted_nums = insertion_sort(nums)
print(" ".join(map(str, sorted_nums)))
\end{lstlisting}

[Answer]: Program 1 is bubble sort, and Program 2 has a bug (the loop condition incorrectly uses arr[j] < key instead of arr[j] > key).\\
The answer is NO.\\

\noindent\textbf{[Example 3]:}\\
\text{[Problem Description]:} Same as Example 1.\\
\text{[Program 1]:}\\
\begin{lstlisting}
def bubble_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        for j in range(n - 1 - i):
            if arr[j] < arr[j + 1]:  
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

nums = list(map(int, input().split()))
sorted_nums = bubble_sort(nums)
print(" ".join(map(str, sorted_nums)))
\end{lstlisting}

\text{[Program 2]:} Same as Program 2 from Example 1.\\

[Answer]: Program 1 has a bug for bubble sort (the comparison is reversed, causing incorrect swaps).\\
The answer is NO.\\

\noindent\textbf{[Example 4]:}\\
\text{[Problem Description]:} Same as Example 1.\\
\text{[Program 1]:} Same as Program 1 from Example 1.\\
\text{[Program 2]:}\\
\begin{lstlisting}
nums = list(map(int, input().split()))
sorted_nums = sorted(nums)
print(" ".join(map(str, sorted_nums)))
\end{lstlisting}

[Answer]: Program 1 is bubble sort, and Program 2 uses Python's built-in sorting implementation.\\
The answer is YES.\\

\text{[Problem Description]:}\\
\begin{lstlisting}
{problem_html}
\end{lstlisting}

\text{[Program 1]:}\\
\begin{lstlisting}
{program_1_code}
\end{lstlisting}

\text{[Program 2]:}\\
\begin{lstlisting}
{program_2_code}
\end{lstlisting}

Please output the answer of whether the two programs are equivalent or not. You should output YES or NO in the end. Let's think step by step.


\subsubsection{OJ\_V Category}
We show the prompt for 4-shot CoT settings.

\paragraph{4-shot CoT.} You are here to judge if two Python programs are semantically equivalent.\\
You will be given \text{[Problem Description]}, \text{[Program 1]} and \text{[Program 2]}.\\
Here equivalence means that, given any valid input under the problem description, the two programs will always give the same output.\\

\noindent\textbf{[Example 1]:}\\
\text{    [Problem Description]}:\\
Given a single line of input containing integers separated by spaces, sort the integers in ascending order and print them in a single line separated by spaces.\\
Input: A single line containing integers A[i] ($-10^6 <= A[i] <= 10^6, 1 <= n <= 10^6$).\\
Output: A single line of integers sorted in ascending order.\\
Example Input:\\
4 2 5 1 3\\
Example Output:\\
1 2 3 4 5
\\
\text{    [Program 1]}:\\
\begin{lstlisting}
nums = list(map(int, input().split()))
sorted_nums = sorted(nums)
print(" ".join(map(str, sorted_nums)))
\end{lstlisting}
\text{    [Program 2]}:\\
\begin{lstlisting}
random_var1 = list(map(int, input().split()))
random_var2 = sorted(random_var1)
print(" ".join(map(str, random_var2)))
\end{lstlisting}
[Answer]: The only difference is in variable names, which do not affect the logic or output of the program.\\
The answer is YES.\\

\noindent\textbf{[Example 2]:}\\
\text{    [Problem Description]}:\\
\begin{lstlisting}
Same as Example 1.
\end{lstlisting}
\text{    [Program 1]}:\\
\begin{lstlisting}
nums = list(map(int, input().split()))
sorted_nums = sorted(nums)
print(" ".join(map(str, sorted_nums)))
\end{lstlisting}
\text{    [Program 2]}:\\
\begin{lstlisting}
nums = list(map(int, input().split()))
sorted_nums = nums.sort()
print(" ".join(map(str, sorted_nums)))
\end{lstlisting}
[Answer]: Program 1 sorts the integers in the correct way. In Program 2, nums.sort() modifies the list in place and returns None. Program 2 will trigger a TypeError.\\
The answer is NO.\\

\noindent\textbf{[Example 3]:}\\
\text{    [Problem Description]}:\\
Given a list of integers, remove all duplicate values while maintaining the order of their first appearance and print the resulting list in a single line, separated by spaces.\\
Input: A single line containing integers A[i] ($-10^6 <= A[i] <= 10^6, 1 <= n <= 10^5$).\\
Output: A single line containing the integers from the input with duplicates removed, in the order of their first appearance.\\
Example Input:\\
4 5 4 2 5 1 3\\
Example Output:\\
4 5 2 1 3\\
\text{    [Program 1]}:\\
\begin{lstlisting}
nums = list(map(int, input().split()))
unique_nums = []
for num in nums:
    if num not in unique_nums:
        unique_nums.append(num)
print(" ".join(map(str, unique_nums)))
\end{lstlisting}
\text{    [Program 2]}:\\
\begin{lstlisting}
random_var1 = list(map(int, input().split()))
random_var2 = []
for random_var3 in random_var1:
    if random_var3 not in random_var2:
        random_var2.append(random_var3)
print(" ".join(map(str, random_var2)))
\end{lstlisting}
[Answer]: The only difference is in variable names, which do not affect the logic or output of the program.\\
The answer is YES.\\

\noindent\textbf{[Example 4]:}\\
\text{    [Problem Description]}:\\
\begin{lstlisting}
Same as Example 3.
\end{lstlisting}
\text{    [Program 1]}:\\
\begin{lstlisting}
nums = list(map(int, input().split()))
unique_nums = []
for num in nums:
    if num not in unique_nums:
        unique_nums.append(num)
print(" ".join(map(str, unique_nums)))
\end{lstlisting}
\text{    [Program 2]}:\\
\begin{lstlisting}
nums = list(map(int, input().split()))
unique_nums = []
for num in nums:
    if num in unique_nums:
        unique_nums.append(num)
print(" ".join(map(str, unique_nums)))
\end{lstlisting}
[Answer]: Program 1 correctly appends unique values to unique\_nums by checking if num not in unique\_nums.\\
Program 2 is incorrect because it uses if num in unique\_nums, causing only duplicates to be appended to the list.\\
The answer is NO.\\

\text{    [Problem Description]}:\\
\begin{lstlisting}
{problem_html}
\end{lstlisting}

\text{    [Program 1]}:\\
\begin{lstlisting}
{program_1_code}
\end{lstlisting}

\text{    [Program 2]}:\\
\begin{lstlisting}
{program_2_code}
\end{lstlisting}

Please output the answer of whether the two programs are equivalent or not. You should output YES or NO in the end. Let's think step by step.


\subsubsection{OJ\_VA Category}
We show the prompt for 4-shot CoT settings.

\paragraph{4-shot CoT.} You are here to judge if two Python programs are semantically equivalent.\\
You will be given [Problem Description], [Program 1] and [Program 2].\\
Here equivalence means that, given any valid input under the problem description, the two programs will always give the same output.\\

\noindent\textbf{[Example 1]:}\\
\text{    [Problem Description]}:\\
Given a single line of input containing integers separated by spaces, sort the integers in ascending order and print them in a single line separated by spaces.\\
Input: A single line containing integers A[i] (-10$^6$ <= A[i] <= 10$^6$, 1 <= n <= 10$^6$).\\
Output: A single line of integers sorted in ascending order.\\
Example Input:\\
4 2 5 1 3\\
Example Output:\\
1 2 3 4 5\\
\text{    [Program 1]}:\\
\begin{lstlisting}
def bubble_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        for j in range(n - 1 - i):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

nums = list(map(int, input().split()))
sorted_nums = bubble_sort(nums)
print(" ".join(map(str, sorted_nums)))
\end{lstlisting}
\text{    [Program 2]}:\\
\begin{lstlisting}
def random_sort(rand_var1):
    for rand_var2 in range(1, len(rand_var1)):
        rand_var3 = rand_var1[rand_var2]
        rand_var4 = rand_var2 - 1
        while rand_var4 >= 0 and rand_var1[rand_var4] > rand_var3:
            rand_var1[rand_var4 + 1] = rand_var1[rand_var4]
            rand_var4 -= 1
        rand_var1[rand_var4 + 1] = rand_var3
    return rand_var1

rand_input = list(map(int, input().split()))
rand_output = random_sort(rand_input)
print(" ".join(map(str, rand_output)))
\end{lstlisting}
[Answer]: Program 1 is bubble sort, and Program 2 is insertion sort (though the variable names are randomized).\\
The answer is YES.\\

\noindent\textbf{[Example 2]:}\\
\text{    [Problem Description]}:\\
Same as Example 1.\\
\text{    [Program 1]}:\\
Same as Program 1 from Example 1.\\
\text{    [Program 2]}:\\
\begin{lstlisting}
def insertion_sort(rand_var1):
    for i in range(1, len(rand_var1)):
        key = rand_var1[i]
        j = i - 1
        while j >= 0 and rand_var1[j] < key:
            rand_var1[j + 1] = rand_var1[j]
            j -= 1
        rand_var1[j + 1] = key
    return rand_var1

nums = list(map(int, input().split()))
sorted_nums = insertion_sort(nums)
print(" ".join(map(str, sorted_nums)))
\end{lstlisting}
\text{    [Answer]}: Program 1 is bubble sort, and Program 2 has a bug (the loop condition incorrectly uses rand\_var1[j] < key instead of rand\_var1[j] > key).\\
The answer is NO.\\

\noindent\textbf{[Example 3]:}\\
\text{    [Problem Description]}:\\
Same as Example 1.\\
\text{    [Program 1]}:\\
\begin{lstlisting}
def rand_alg(rand_var):
    n = len(rand_var)
    for i in range(n - 1):
        for j in range(n - 1 - i):
            if rand_var[j] < rand_var[j + 1]:  
                rand_var[j], rand_var[j + 1] = rand_var[j + 1], rand_var[j]
    return rand_var

nums = list(map(int, input().split()))
sorted_nums = rand_alg(nums)
print(" ".join(map(str, sorted_nums)))
\end{lstlisting}
\text{    [Program 2]}:\\
Same as Program 2 from Example 1.\\
\text{[Answer]}: Program 1 has a bug for bubble sort (the comparison is reversed, causing incorrect swaps).\\
The answer is NO.\\

\noindent\textbf{[Example 4]:}\\
\text{    [Problem Description]}:\\
Same as Example 1.\\
\text{    [Program 1]}:\\
Same as Program 1 from Example 1.\\
\text{    [Program 2]}:\\
\begin{lstlisting}
nums = list(map(int, input().split()))
sorted_nums = sorted(nums)
print(" ".join(map(str, sorted_nums)))
\end{lstlisting}
[Answer]: Program 1 is bubble sort, and Program 2 uses Python's built-in sorting implementation.\\
The answer is YES.\\

\text{    [Problem Description]}:\\
\begin{lstlisting}
{problem_html}
\end{lstlisting}

\text{    [Program 1]}:\\
\begin{lstlisting}
{program_1_code}
\end{lstlisting}
\text{    [Program 2]}:\\
\begin{lstlisting}
{program_2_code}
\end{lstlisting}

Please output the answer of whether the two programs are equivalent or not. You should output YES or NO in the end. Let's think step by step.

\clearpage

\subsection{Model Prediction Bias}
\label{subsec:app:bias}

We evaluate the prediction bias of the models and observe a pronounced tendency to misclassify equivalent programs as inequivalent in the \cuda and \ass categories. The table here shows the full results on all models under 0-shot prompting.

\begin{table}[h]
    \centering
% \small
\begin{tabular}{lcccc}
\toprule
\multicolumn{1}{c}{\multirow{2}{*}{\textbf{Model}}} & \multicolumn{2}{c}{\textbf{\cuda}} & \multicolumn{2}{c}
{\textbf{\ass}} \\
\cmidrule(lr){2-5}
 & \textbf{Eq} & \textbf{Ineq} & \textbf{Eq} & \textbf{Ineq} \\
\midrule
\textit{Random Baseline} & \textit{50.0} & \textit{50.0} & \textit{50.0} & \textit{50.0} \\
deepseek-ai/DeepSeek-V3 & 8.5 & 93.0 & 44.0 & 94.5 \\
deepseek-ai/DeepSeek-R1 & 28.0 & 94.0 & 57.5 & 99.0 \\
meta-llama/Llama-3.1-405B-Instruct-Turbo & 6.0 & 92.0 & 68.5 & 81.5 \\
meta-llama/Llama-3.1-8B-Instruct-Turbo & 2.0 & 97.5 & 1.0 & 100.0 \\
meta-llama/Llama-3.1-70B-Instruct-Turbo & 7.0 & 93.0 & 27.5 & 89.5 \\
meta-llama/Llama-3.2-3B-Instruct-Turbo & 0.0 & 99.5 & 0.0 & 100.0 \\
anthropic/claude-3-5-sonnet-20241022 & 62.5 & 62.0 & 49.5 & 90.5 \\
Qwen/Qwen2.5-7B-Instruct-Turbo & 18.5 & 80.0 & 17.5 & 98.5 \\
Qwen/Qwen2.5-72B-Instruct-Turbo & 14.5 & 97.5 & 36.0 & 93.5 \\
Qwen/QwQ-32B-Preview & 35.0 & 66.0 & 39.0 & 86.5 \\
mistralai/Mixtral-8x7B-Instruct-v0.1 & 18.0 & 76.0 & 50.5 & 78.0 \\
mistralai/Mixtral-8x22B-Instruct-v0.1 & 10.5 & 87.5 & 32.5 & 93.0 \\
mistralai/Mistral-7B-Instruct-v0.3 & 52.5 & 62.0 & 87.0 & 60.5 \\
openai/gpt-4o-mini-2024-07-18 & 0.5 & 100.0 & 16.5 & 97.0 \\
openai/gpt-4o-2024-11-20 & 0.0 & 99.0 & 68.5 & 62.0 \\
openai/o3-mini-2025-01-31 & 27.5 & 90.5 & 69.5 & 99.5 \\
openai/o1-mini-2024-09-12 & 2.5 & 99.0 & 50.0 & 98.5 \\
\bottomrule
\end{tabular}
\label{tab:appbias}
\end{table}