\section{Dataset Collection}

In this section, we first introduce our game design, including the representations of game setup and mechanics. We then describe a two-stage data collection process for the Game Creation (GC) and Game Simulation (GS) tasks. In the first stage, we build a non-player character (NPC) pool from fictional character Wikipedia pages, and prompt various LLMs to create one game per NPC. An automatic game validity checker applies for selecting valid games. In the second stage, we assemble a test set of valid games for GS.

\subsection{Game Design}\label{sec:gd}

% A game is represented as a JSON dictionary, as illustrated in Figure~\ref{fig:rpebench-overview}, containing information on \textbf{Game World}, \textbf{Player Character Name}, \textbf{Player Character Description}, \textbf{Main NPC Name}, \textbf{Main NPC Description}, \textbf{Main NPC Personality} (using the Big Five traits), \textbf{Main NPC Facts}, \textbf{Game Objective}, \textbf{Game Scenes}, \textbf{State Variables}, \textbf{Game Events} and \textbf{Termination Conditions}.


The games in \benchmark{}, as illustrated in Figure~\ref{fig:rpebench-overview}, are structured around several core components that create a text-based role-playing game (RPG) experience. This design ensures sufficient flexibility for diverse storytelling while maintaining support for objective mechanic evaluation:

\begin{itemize} 
\item \textbf{Game World}: The overarching setting where the story unfolds (e.g., "Gotham City"). 
\item \textbf{Player Character}: The protagonist controlled by the player, including a name and description (e.g., "Ann," a detective and ally of Batman). 
\item \textbf{Main NPC}: A key non-player character controlled by the game engine, characterized by a name, description, Big Five personality traits, and relevant facts (e.g., "Bruce Wayne (Batman)"). 
\item \textbf{Game Objective}: The primary goal to accomplish.
% (e.g., "Uncover the mastermind behind a conspiracy"). 
\item \textbf{Game Scenes}: Distinct locations where events occur.
% (e.g., "Wayne Manor"). 
\end{itemize}


% \begin{itemize}
%     \item \textbf{Game World}: A textual description of the game world.
%     \item \textbf{Player Character Name}: Name of the player character.
%     \item \textbf{Player Character Description}: A brief textual description of the player character.
%     \item \textbf{Main NPC Name}: Name of the main NPC.
%     \item \textbf{Main NPC Description}: A brief textual description of the main NPC.
%     \item \textbf{Main NPC Personality}: The Big Five personality traits for the main NPC, each scored from 1--5 (Openness, Conscientiousness, Extraversion, Agreeableness, and Neuroticism).
%     \item \textbf{Main NPC Facts}: A list of simple facts related to the main NPC.
%     \item \textbf{Game Objective}: A short textual description of the game objective.
%     \item \textbf{Game Scenes}: A list of game scenes.
%     \item \textbf{State Variables}: A list of finite discrete state variables. Each has an initial value, ensuring the total number of possible states is finite.
%     \item \textbf{Game Events}: A list of game events.
%     \item \textbf{Termination Conditions}: A set of conditions that, when met, lead to either success or failure.
% \end{itemize}
% The full JSON structure is provided in the Appendix~\ref{app:game_json}.

% \noindent\textbf{Game Mechanics.} 
% We present mechanics via interactions between state variables and game events, specified by four properties of each event: \textbf{Entering Condition}, \textbf{Success Condition}, \textbf{Success Effect} and \textbf{Fail Effect}. All the conditions are boolean expressions of state variables, and all effects are value updates of state variables.
% \begin{itemize}[leftmargin=*]
%     \item : Conditions for the event to occur.
%     \item : Conditions for the event to succeed.
%     \item : Effects on state variables if succeeds.
%     \item : Effects on state variables if fails.
% \end{itemize}
The core \textbf{game mechanics} in \benchmark{} are structured around \textbf{event-state interactions}, which define how game events modify the game state:

\begin{itemize} 
    \item \textbf{State Variables} represent numerical values that track the game's dynamic elements, such as character skills and trust levels. These variables always have an initial value along with minimum and maximum bounds.
    \item \textbf{Game Events} drives game progression and modifies \textbf{state variables} upon execution. Each event has an \textbf{entering condition} (whether it can occur) and a \textbf{success condition} (whether it succeeds). Upon execution, an event applies either a \textbf{success effect} or, if applicable, a \textbf{fail effect}, updating the state variables accordingly.
    \item \textbf{Termination Conditions} specify when the game ends by evaluating specific state variable expressions. These conditions, checked before processing game events, determine whether the game ends with success or failure.
\end{itemize}

This design creates an interactive experience where player actions and game events influence the game state. An LLM serves as the game engine, creating the game, simulating the game world based on user actions. Further details, including the exact game JSON schema, are provided in Appendix~\ref{app:game_json}.



\subsection{Game Data Collection}\label{sec:gdc}

We select 100 fictional characters from Wikipedia to serve as the test set for GC. For each character, we prompt an LLM to create a JSON-formatted game (as specified above) that treats this character as the main NPC. We employ a 5-shot prompting approach, where the examples are generated by initially prompting \emph{GPT 4o} using a manually crafted game. The full prompt is provided in the Appendix~\ref{app:gc_prompt}.

We parse LLM outputs to ensure they conform to the JSON format. Any game that passes this format check is then tested for validity using a BFS-based checker (see Section~\ref{sec:evaluation_gc}), which confirms whether a game can end in both success and failure, and whether all events can be reached. All valid games from multiple models are collected for the GS task (Table~\ref{tab:data_stats} shows the distribution).

\begin{table}[!ht]
    \centering
    \begin{tabular}{lr}
    \toprule
    Game Source & \# of Valid Games (Out of 100)\\
    \midrule
    Claude 3.5 Sonnet & 1\\
    DeepSeek V3       & 38\\
    Gemini 1.5 Pro    & 4\\
    Gemini 2.0 Flash Exp & 33\\
    GPT 4o            & 49\\
    \midrule
    Total             & 125 \\
    \bottomrule
    \end{tabular}
    \caption{Generated Game Statistics}
    \label{tab:data_stats}
\end{table}
