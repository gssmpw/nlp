\chapter{Recursive Data Interpolation Techniques} % Neural decoder
\chaptermark{Interpolation}
%\thispagestyle{empty}
\label{sec:data interpolation}



Ch.~\ref{sec:copulas} described how, from $N$ data points $(x_1,\dots, x_N)$, it is possible to leverage NNs to interpolate a function representing the underlying PDF $p_X(x)$ that generated the observed data. In all the previous contexts, interpolation effectively meant estimating the distribution of the given samples in order to understand the \textit{stochastic} nature of the data. We typically exploit $p_X(x)$ to produce new realizations $(\hat{x}_1,\dots, \hat{x}_N)$.

In this chapter, instead, we focus on capturing the \textit{deterministic} relationship between inputs and outputs, determining a function that passes through specific points. 
When we approach interpolation from the perspective of finding a fitting function, we aim to create a mathematical model that accurately represents the relationship between the given data points, abstracting from how these points have been obtained. 
This fitting function allows us to predict intermediate values within the range of the data, enabling smooth transitions between observed points.

Fitting functions are extremely useful for trajectory generation in various fields such as physics, robotics and aerospace engineering. When designing trajectories for moving objects or systems, it is essential to create smooth and continuous paths that meet specific constraints and objectives.
In the following, we study the trajectory generation problem and propose a novel iterative interpolation technique.

The results presented in this chapter are documented in \cite{Letizia2020_rst, LetiziaRobotics, 9525383}.

\label{sec:rst}
\input{RST/Introduction.tex}
\input{RST/Problem_statement.tex}
\input{RST/Main_results.tex}
\input{RST/Perturbation.tex}
\input{RST/Optimization.tex}
\input{RST/Examples.tex}
\input{RST/Comments.tex}

\section{Rational interpolation} 
\sectionmark{RRST}
\label{sec:rst_rrst}
Polynomial interpolation is in general a simple and fast process to implement. Nevertheless, when the degree of the interpolant function is high, oscillation at the edges may occur as mentioned before. For this reason, we consider a different basis function which may take advantage of the simplicity of polynomials but also provide more flexibility and degrees of freedom to tackle Runge's phenomenon.

\subsection{Rational recursive smooth trajectory}
We identify and propose a new basis as the rational basis function
\begin{equation}
R_{n,d}(t) = \frac{N(t)}{D(t)},
\end{equation}
where $N(t)$ is the numerator, a polynomial of degree $n$, and $D(t)$ is the denominator, a polynomial of degree $d$.
Such choice allows us to exploit some of the polynomial properties for both numerator and denominator but most importantly, enables the development of a new algorithm, referred to as rational recursive smooth trajectory (RRST). To find the coefficients of both numerator and denominator, the idea is to pick the denominator $D(t)$ and use RST to find the coefficients of the numerator $N(t)$. Intuitively, the new kinematic constraints for building $N(t)$ are a weighted sum of the kinematic constraints $\frac{d^i}{dt^i}f_k(t)\biggr|_{t=t_j}$ (given) and the kinematic constraints $\frac{d^i}{dt^i}D(t)\biggr|_{t=t_j}$ (designed as input). The following Lemma provides the mathematical formulation for the RRST.

\begin{lemma}
\label{lemma:rrst_Lemma1}
Let $t_j$ be a point in time, for $j=0,1,\dots, N$, such that $\frac{d^i}{dt^i}f_k(t)\bigr|_{t=t_j}$ is the associated given kinematic constraint, for $i=0,1,\dots, k$. Let $N(t)$ and $D(t)$ be polynomials with $D$ given of degree $d$. If $f_k(t)$ is a rational function defined as
\begin{equation}
f_k(t) = R_{n,d}(t) = \frac{N(t)}{D(t)},
\end{equation}
with $n=(k+1)(N+1)-1$, then the coefficients of $N(t)$ can be obtained with RST, in particular its associated kinematic constraint has expression
\begin{equation}
\frac{d^i}{dt^i}N(t)\biggr|_{t=t_j} = \sum_{l=0}^{i}{\binom{i}{l}\biggr(\frac{d^l}{dt^l}f_k(t)\bigr|_{t=t_j}\biggr) \cdot \biggr(\frac{d^{i-l}}{dt^{i-l}}D(t)\bigr|_{t=t_j}}\biggr).
\end{equation}
\end{lemma}

\begin{proof}
For simplicity of notation, the rational function $R_{n,d}(t)$ will be denoted with $R(t)$.
We proceed by induction on the kinematic constraint. Consider the case when $i=0$, then
\begin{equation}
N(t_j) = R(t_j)\cdot D(t_j)
\end{equation}
represents the value that $N(t)$ needs to assume at the time $t_j$. For the case $i=1$
\begin{equation}
\frac{d}{dt}N(t)\biggr|_{t=t_j} = \frac{d}{dt} \biggl(R(t)\cdot D(t)\biggr)\biggr|_{t=t_j}
\end{equation}
which is equal to
\begin{equation}
\frac{d}{dt}N(t)\biggr|_{t=t_j} = \binom{1}{0}R(t_j) \cdot \biggr( \frac{d}{dt}D(t)\bigr|_{t=t_j}\biggr) + \binom{1}{1} \biggr( \frac{d}{dt}R(t)\bigr|_{t=t_j}\biggr) \cdot D(t_j) .
\end{equation}
Suppose that the statement of the lemma is true for the case $i$, which means that
\begin{equation}
\frac{d^i}{dt^i}N(t)\biggr|_{t=t_j} = \sum_{l=0}^{i}{\binom{i}{l}\biggr(\frac{d^l}{dt^l}R(t)\bigr|_{t=t_j}\biggr) \cdot \biggr(\frac{d^{i-l}}{dt^{i-l}}D(t)\bigr|_{t=t_j}}\biggr).
\end{equation}
Then, it is true also for the case $i+1$. Indeed
\begin{align}
\frac{d^{i+1}}{dt^{i+1}}N(t)\biggr|_{t=t_j} = &\; 
\frac{d}{dt}\sum_{l=0}^{i}{ \binom{i}{l}\biggr(\frac{d^l}{dt^l}R(t)\bigr|_{t=t_j}\biggr) \cdot \biggr(\frac{d^{i-l}}{dt^{i-1}}D(t)\bigr|_{t=t_j}\biggr)} \nonumber \\
= &\; \sum_{l=0}^{i}{\binom{i}{l} \frac{d}{dt}\Biggl[ \biggr(\frac{d^l}{dt^l}R(t)\bigr|_{t=t_j}\biggr) \cdot \biggr(\frac{d^{i-l}}{dt^{i-1}}D(t)\bigr|_{t=t_j}\biggr)\Biggr] }  \nonumber \\ 
= &\; \sum_{l=0}^{i}{\binom{i}{l} \biggr(\frac{d^{l+1}}{dt^{l+1}}R(t)\bigr|_{t=t_j}\biggr) \cdot \biggr(\frac{d^{i-l}}{dt^{i-1}}D(t)\bigr|_{t=t_j}}\biggr) \nonumber \\
+ &\; \sum_{l=0}^{i}{\binom{i}{l} \biggr(\frac{d^{l}}{dt^{l}}R(t)\bigr|_{t=t_j}\biggr) \cdot \biggr(\frac{d^{i+1-l}}{dt^{i+1-l}}D(t)\bigr|_{t=t_j}\biggr)}
\end{align}
where we used the linearity of the differential operator and the product rule. With a change of variable in the first term of the RHS, $h=l+1$, it follows that
\begin{align}
\frac{d^{i+1}}{dt^{i+1}}N(t)\biggr|_{t=t_j} = &\; 
   \sum_{h=1}^{i+1}{\binom{i}{h-1} \biggr(\frac{d^{h}}{dt^{h}}R(t)\bigr|_{t=t_j}\biggr) \cdot \biggr(\frac{d^{i+1-h}}{dt^{i+1-h}}D(t)\bigr|_{t=t_j}}\biggr) \nonumber \\
+ &\; \sum_{l=0}^{i}{\binom{i}{l} \biggr(\frac{d^{l}}{dt^{l}}R(t)\bigr|_{t=t_j}\biggr) \cdot \biggr(\frac{d^{i+1-l}}{dt^{i+1-l}}D(t)\bigr|_{t=t_j}}\biggr) \nonumber \\ 
= &\; \sum_{l=0}^{i+1}{\binom{i+1}{l}\biggr(\frac{d^l}{dt^l}R(t)\bigr|_{t=t_j}\biggr) \cdot \biggr(\frac{d^{i+1-l}}{dt^{i+1-l}}D(t)\bigr|_{t=t_j}}\biggr)
\end{align}
where we used the Pascal's identity
\begin{equation}
\binom{i+1}{l} = \binom{i}{l-1} + \binom{i}{l}.
\end{equation}
Hence the result is true for $i+1$ and by induction is true for all positive integers. From Corollary \ref{corollary:rst_corollary1}, the minimum degree $n$ of $N(t)$ is $(k+1)(N+1)-1$.
\qedhere
\end{proof}

\begin{figure}[b]
\includegraphics[scale=0.25]{images/extra/acrtan.pdf}
      \centering
      \caption{Comparison between polynomial (RST) and rational (RRST) interpolation of $10$ waypoints, obtained as samples of the analytic control input $\text{arctan}(\pi t)$.}
      \label{fig:rst_arctan}
\end{figure}

\begin{algorithm}
\caption{Rational recursive smooth trajectory (RRST)}
\label{alg:rst_RRST}
\begin{algorithmic}[1]
\Inputs{$N+1$ points in time $t_0<t_1<\dots<t_N$; \\ Number of derivatives $k$ to fulfill; \\ Kin. constr.
 $\frac{d^i}{dt^i}f_k(t)\bigr|_{t=t_0}, \dots, \frac{d^i}{dt^i}f_k(t)\bigr|_{t=t_N}$; \\ Denominator $D(t)$ of degree $d$. \\}
\Initialize{Kin. constr. $\frac{d^i}{dt^i}D(t)\bigr|_{t=t_0}, \dots, \frac{d^i}{dt^i}D(t)\bigr|_{t=t_N}$;}
\For{$i=0$ to $k$}
	\For{$j=0$ to $N$}
		\State $\frac{d^i}{dt^i}N(t)\biggr|_{t=t_j} =$
          \State $\sum_{l=0}^{i}{\binom{i}{l}\biggr(\frac{d^l}{dt^l}f_k(t)\bigr|_{t=t_j}\biggr) \cdot \biggr(\frac{d^{i-l}}{dt^{i-l}}D(t)\bigr|_{t=t_j}}\biggr)$;
	\EndFor
\EndFor
\State Get $N(t)$ with RST given the kinematic constraints $\frac{d^i}{dt^i}N(t)\biggr|_{t=t_j}$ as input;
\State $f_k(t)=\frac{N(t)}{D(t)}$.
\end{algorithmic}
\end{algorithm}

Lemma \ref{lemma:rrst_Lemma1} provides the general expression of the kinematic constraints associated to $N(t)$, however it assumes that the denominator $D(t)$ is given. The choice of the denominator remains an open question although some considerations can be made. The denominator represents a whole set of degree of freedoms and therefore the choice of the coefficients should in principle consider some strategies. For example, a fundamental aspect is the position of the roots inside the interval $[t_0, \hspace{0.2em} t_N]$. Indeed, if one real pole (denominator root) falls inside the desired interval, it may cause discontinuities in the rational interpolant. To avoid this, a possible strategy relies on the selection of multiple complex conjugate roots. Further studies have to be made in the roots locus analysis for such rational function but they go out of the scope of this section therefore we postpone these questions to future work. Finally, it is interesting to notice that if the denominator $D(t)$ is constant, we lead back to the classical polynomial interpolation via RST, therefore we can tract RRST as a rational basis extension of the RST algorithm. The implementation of the RRST algorithm is we reported in the pseudo code of Alg. \ref{alg:rst_RRST}.

To show how the RRST tackles the oscillation problem, we report in Fig.~\ref{fig:rst_arctan} an example of function approximation with polynomials (RST) and rational functions (RRST). In particular, we select as function to interpolate $f_k(t)= \text{arctan}(\pi t)$, with $t\in [-1,1]$. Fig.~\ref{fig:rst_arctan} illustrates the resulting interpolants when the number of waypoints is set to $10$ and no kinematic constraints (from velocity on) are imposed. The denominator of the rational function is set to $D(t)=t^2+0.1$ and for such choice, RRST shows to perform better than the polynomial interpolant at the edges.

In conclusion, we extended the RST algorithm to rational functions. The algorithm can effectively generate an analytic expression that approximates control inputs, for which no closed-form solutions are in general attainable. More details are offered in \cite{9525383}.

\input{RST/Conclusions.tex}
