\section{All Pairs Shortest Paths}

Our single-source  approach can be run repeatedly to approximate distances between all pairs of vertices.

Specifically, the goal is to preprocess $G_0, \ldots, G_m$ such that given $i$, $j$, and $t$, we can quickly find a $(1 + \epsilon)$-approximation of $d^t(i,j)$, the distance from $i$ to $j$ in $G_t$.  
We run the single source shortest path algorithm for each source $s\in V$, storing a separate data structure for each.  
This requires $\Tilde{O}(nm\log W/\epsilon)$ time and $\Tilde{O}(n^2 \log W / \epsilon)$ space, gives the following corollary.


\begin{corollary}
\label{cor:offline-approx-apsp}
    For the offline incremental all-pairs shortest-paths problem, there exists an algorithm running in total time $ O(nm\log(nW)\log^3 n \log\log n/\epsilon)$ that returns $(1+\epsilon)$ approximate shortest paths for each pair of vertices for each time $t$. 
\end{corollary}

\paragraph{Online Learned APSP Algorithm.}  
For the online setting, we consider the worst-case update and query bounds.  In particular, the algorithm first preprocesses $\hat{\sigma}$.  Then, it obtains the edges from $\sigma$ one by one; the time to process any such edge is the update time.  At any time during this sequence of inserts the algorithm can be queried for the distance between any two vertices in the graph; the time required to answer the query is the query time.

We can immediately combine this idea with the techniques of van den Brand et al.~\cite[Theorem 3.1]{BrandFNP24} to obtain Theorem~\ref{thm:online-apsp}.  

\begin{proof}[Proof of  Theorem~\ref{thm:online-apsp}]
We briefly summarize the algorithm of van den Brand et al.; see the proof of Theorem 3.1 in~\cite{BrandFNP24} for the full details.  
To begin, we run the algorithm from Corollary~\ref{cor:offline-approx-apsp} on $\hat{\sigma}$ in $\Tilde{O}(nm\log W / \epsilon)$ time, so that for all $t,i,j$ we can find $\hat{d}^t(i,j)$ in $O(\log \log_{1 + \epsilon} (nW))$ time.  

On a query at time $t$ for vertices $i$ and $j$, we do the following.  Let $t'$ be the latest time such that all edges that were predicted to appear by time $t'$ in $\hat{\sigma}$ have actually appeared (in $\sigma$) by time $t$.  Notice that if $\hat{\sigma}$ is a permutation of $\sigma$, then $t - t' \leq \eta$ (see the discussion immediately after Theorem 3.1 in~\cite{BrandFNP24} for a formal proof).  
Let $E'$ be the set of all edges that have arrived by time $t$ minus the edges that were predicted to arrive by time $t'$. Then, $|E'| = t - t' \leq \eta$. 
We construct $G'$ with a set of vertices equal to all vertices in any edge in $E'$, plus $i$ and $j$.  The graph $G'$ is complete.  For each edge $e = (u,v)$ in $G'$, the weight of the edge is the minimum of: (1) the weight of any edge from $u$ to $v$ in $E'$, and (2) $\hat{d}^{t'}(u,v)$.  We run Dijkstra's algorithm to obtain the distance from $i$ to $j$ in $G'$; this answers the query.  Constructing $G'$ and running Dijkstra's algorithm can be done in time $O(\eta^2 \log\log_{1 + \epsilon} (nW))$.

Let us briefly explain why this works.  
First, let's show that the answer is at least $d^t(i,j)$.  
Consider the shortest path $P$ from $i$ to $j$ in $G'$.  
Each edge $e = (u,v)$ in $P$ is one of two types: either an edge in $E'$, or an edge with weight $\hat{d}^{t'}(u,v)$.  The edge with weight $\hat{d}^{t'}(u,v)$ upper bounds the length of the shortest path between $u$ and $v$ over edges that were predicted to arrive by $t'$.  All such edges are in $G_t$ by definition of $t'$.  
Thus, by concatenating the edges from $P$ in $E'$ and the subpaths corresponding to the edges in $P$ not in $E'$, we obtain a path $P'$ in $G_t$ with weight at most that of $P$.
Now, we show the answer is at most $(1 + \epsilon)d^t(i,j)$.
Consider the shortest path $Q$ from $i$ to $j$ in $G_t$.  
We can decompose $Q$ into a sequence of subpaths, each of which is either an edge in $E'$, or consists of a sequence of edges not in $E'$.  For each edge and subpath, there is an edge in $G'$ with weight at most $(1+\epsilon)$ larger by definition; concatenating these edges we obtain a path $Q'$ in $G'$ of weight at most $(1 + \epsilon)$ larger.

With queries in mind, there are two goals for updates: we must be able to construct $E'$ efficiently, and we must maintain $t'$. 
We can store the inserted edges in a balanced binary-search tree, which takes $O(\log n)$ time per insert to maintain. At each time $t$, the BST contains $\widehat{\ind}(e)$ for all edges $e$ that have arrived by time $t$. This allows us to find $t'$ and construct $|E'|$ in $O(\log n)$ and $O(|E'| \log n) = O(\eta \log n)$ time, respectively (see the discussion in~\cite[Theorem 3.1]{BrandFNP24}).
\end{proof}