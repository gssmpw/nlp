\section{Offline Incremental Weighted Directed Shortest Path}
\label{sec:offline}
This section presents an algorithm for the offline problem which takes ${O(m\log (nW) (\log^3 n)\log\log n/\epsilon)}$ time to build, and $O(\log \log_{1+\epsilon}(nW))$ time to answer a query $(v,t)$.  

The algorithm maintains an estimate of the shortest path at all points in time.  
Let $\hat{d}^t(v)$ be the estimate of $d^t(v)$ obtained by the algorithm. 
The algorithm does not explicitly maintain $\hat{d}^t(v)$ values for each vertex $v$ and each time $t$, because of the following simple observation: 
if for times $\ell$ and $r$, $\ell<r$, we have $\hat{d}^\ell(v)=\hat{d}^r(v)$, it means that from the algorithm's perspective, node $v$ has the same distance from $s$ in graphs $G_{\ell}$ and $G_r$. 
Since the distances of the nodes from $s$
are non-increasing over time, the algorithm infers that $\hat{d}^t(v)=\hat{d}^\ell(v)$ for each $\ell \leq t \leq r$.
Although in such case $\hat{d}^t(v)$ is not explicitly stored by the algorithm, we still use this notation to refer to $\hat{d}^{\ell}(v)=\hat{d}^r(v)$.

In each subproblem $x$ with an interval $[\ell,r]$, where $x=(\ell+r)/2$, vertices and edges are marked by the algorithm as alive or dead.
A vertex is \emph{alive} in subproblem $x$ if its estimated distances are not the same in subproblems $\ell$ and $r$, otherwise it is \emph{dead}.
In each subproblem $x$ (i.e., node $x$ in the recursion tree), the distance estimates $\hat{d}^x(v)$ for all alive nodes $v$ are explicitly maintained in a balanced binary search tree.
This allows us to access $\hat{d}^x(v)$ in $O(\log n)$ time for each alive node $v$ in subproblem $x$.

Moreover, for each node $v$, the algorithm maintains a list $L_v$ of length
$\log_{1 + \epsilon}( nW)$, representing the times when $v$'s estimated distance from $s$ moves from one integer power of $(1+\epsilon)$ to another.
In particular, the $i$th entry for a vertex $v$, denoted by $L_v(i)$, represents the minimum $t$ such that $\hat{d}^t(v) \leq (1 + \epsilon)^i$.
This is the data structure that the algorithm outputs in order to answer queries $(v,t)$.
To answer a query $(v,t)$, i.e., to obtain a $(1+\epsilon)$-approximation of $d^t(v)$, the algorithm performs  a binary search on $L(v)$ to find an $i$ such that $L_v(i) \leq t < L_v(i-1)$, and then we return $d=(1+\epsilon)^i$.
The time needed to obtain $d$ is then $\log (\log_{1+\epsilon}(nW))$. 
Note that $\hat{d}^t(v) \leq d \leq (1+\epsilon)\hat{d}^t(v)$, which as discussed in Section~\ref{sec:prelim}, it means that $d$ is within a $(1+\epsilon)$ factor of $d^t(v)$ for the original $\epsilon$.

Now we are ready to define the algorithm.

\subsection{The Offline Algorithm}
\label{sec:offline_algorithm}

The offline algorithm is recursive.
It starts with the interval $[0,m]$, and it recursively divides the interval in half and continues on the two subintervals.
Initially, the algorithm marks all vertices and edges as alive in $G_m$, and all vertices as alive in $G_0$. The algorithm runs  Dijkstra's  on $G_m$, and for each vertex $v$, it sets $\hat{d}^m(v) = d^m(v)$. The algorithm sets $\hat{d}^0(s) = 0$, and for all $v \in V \setminus \{s\}$, it sets $\hat{d}^0(v) = \infty$.  The algorithm then begins the recursive process on the interval $[0, m]$.
The algorithm stops recursing when the interval $[\ell,r]$ contains only one new edge; that is, when $r-\ell=2$.

Consider when the algorithm is given an interval $[\ell, r]$ to process. 
On this recursive call (subproblem), the goal is to calculate the distance estimates $\hat{d}^x(v)$ for alive nodes $v$, where $x = (\ell + r)/2$ is the midpoint of $[\ell,r]$.
Since the algorithm processes the subproblems in the recursion tree from top to bottom, it has already processed the subproblems $\ell$ and $r$, i.e., the distance estimates are calculated for the alive nodes in $G_\ell$ and $G_r$.

Just to repeat, a vertex $v$ is alive in $G_x$ if it is alive in $G_\ell$ and $G_r$, and its estimated distance is \emph{not} the same in $G_\ell$ and $G_r$, i.e., $\hat{d}^\ell(v) \neq \hat{d}^r(v)$. If a vertex is not alive, it is dead.   
A directed edge $e = (u,v)$ in $G_x$ is said to be \emph{alive} if $v$ is alive in $G_x$; otherwise, $e$ is \emph{dead}. After the description of the algorithm, we discuss how to efficiently maintain alive and dead vertices and edges. 
Although the algorithm does not store $\hat{d}^x(v)$ for the dead vertices $v$ in the subproblem $x$, we still use the notation $\hat{d}^x(v)$ to refer to $\hat{d}^\ell(v) = \hat{d}^r(v)$.

Now, we can define how the algorithm calculates $\hat{d}^x(v)$ for all alive vertices $v$. 
The algorithm creates a \emph{new graph} $G'_x$ whose vertex set is only the alive vertices in $G_x$ along with $s$. Then, for each alive edge $e\in G_x$ with $e = (u,v)$, there are two cases:
\begin{itemize}
    \item If both $u$ and $v$ are alive,  add $e$ to $G'_x$.
    \item If only $v$ is alive, add an edge from $s$ to $v$ with weight $\hat{d}^x(u) + w(u,v)$ to $G'_x$.
\end{itemize}
To compute $\hat{d}^x(u)$, where $u$ is a dead vertex in $G_x$, the algorithm needs to find the first ancestor of the current subproblem in the recursion tree in which $u$ is alive.
To do this, the algorithm does a binary search on the ancestors of node $x$ in the recursion tree, and for the first ancestor $x'$ where $u$ is alive in $G_{x'}$, it recovers the value of $\hat{d}^{x'}(u)=\hat{d}^x(u)$ using the binary search tree stored at node $x'$. 

The algorithm then computes the distance from $s$ to each vertex in $G'_x$ using Dijkstra's algorithm.  For any alive vertex $v$, the algorithm stores the length of the shortest path to $v$ found by Dijkstra's algorithm rounded up to the nearest integer power of $(1+\epsilon/\log m)$ as $\hat{d}^x(v)$.  

\paragraph{Efficiently Maintaining Alive Edges.}
For any $x$, let $m_x$ be the number of alive edges in $G_x$.   The algorithm maintains
a list of all alive edges at each time $x$.  

We now describe how to find the alive vertices and edges in $G_x$, where $x$ is the midpoint of $[\ell, r]$.
Note that if an edge $(u,v)$ is alive in $G_x$, then its head $v$ must be alive in $G_x$, which in turn implies that $v$ is alive in $G_\ell$ and $G_r$. Since $(u,v)$ has arrived before time $r$, it is alive in $G_r$.
Therefore the alive edges in $G_x$ are a subset of the alive edges in $G_r$.
To obtain the list of alive edges in $G_x$, the algorithm iterates over the alive edges in $G_r$ in $O(m_r)$ time, and removes the edges that either arrived after time $x$, or whose head node has the same estimated distance in both $G_\ell$ and $G_r$.   
While doing this, the algorithm additionally updates if each vertex is alive or not in $G_x$ in $O(m_r)$ time.

From this, the algorithm constructs $G'_x$ in $O(m_r)$ time, and runs Dijkstra's algorithm in $O(m_r\log n)$ time. 

\paragraph{Efficiently Maintaining $L_v$ Lists of Time Indexed Distances.}
To obtain the $L_v(i)$ values, initially, all the entries of $L_v$ are empty. 
At each time $x$, when we are calculating the distance estimate $\hat{d}^x(v)$ for an alive node $v$, we update $L_v$: suppose $(1+\epsilon)^{i-1} < \hat{d}^x(v) \leq (1+\epsilon)^{i}$.
If $L_v(i)$ is empty or $x<L_v(i)$, we set $L_v(i)$ to be $x$. Otherwise, $L_v(i)$ remains unchanged. In the end, the algorithm processes each of the lists, and for any empty $L_v(i)$, the algorithm sets it to be equal to the last non-empty entry of $L_v$ before $L_v(i)$.

\subsection{Analysis of the Offline Algorithm}
\label{sec:offline_analysis}

This section establishes the correctness and running time guarantees of the algorithm.   

\begin{lemma}
\label{lem:refined_approx}
   If $x$ is at level $i$, then for any vertex $v$, $d^x(v) \leq \hat{d}^x(v) \leq d^x(v)(1 + \epsilon/ \log m)^i$. 
\end{lemma}
\begin{proof}
    We show the lemma by induction on $i$.  For $i = 0$, i.e., $x=0$ or $x=m$, we obtain the exact distance for every vertex. 
    
    First, we show that $d^x(v) \leq \hat{d}^x(v)$. If $v$ is dead in subproblem $x$, then $\hat{d}^x(v) = \hat{d}^\ell(v)$, where $\ell$ is the start of the interval of node $x$ in the recursion tree. So, the level of $\ell$ is smaller than $i$. By induction, $d^\ell(v) \leq \hat{d}^\ell(v)$. Also, since $\ell \leq x$, we have $d^x(v) \leq d^\ell(v)$. Therefore, 
    $d^x(v) \leq d^\ell(v) \leq \hat{d}^\ell(v) = \hat{d}^x(v).$ So, we can assume $v$ is alive.  
    Let $p = s, v_1, v_2, \cdots, v_k$ be the shortest path from $s$ to $v=v_k$ in $G'_x$, so $\hat{d}^x(v)$ is the length of $p$ rounded up to the nearest integer power of $1 + \epsilon/\log m$.  
    Note that the path $v_1, v_2, \cdots, v_k$ exists in $G_x$ as well, since all the edges that only appear in $G'_x$ start at $s$. 
    If the edge $(s,v_1)$ is present in $G_x$, then $d^x(v) \leq \hat{d}^x(v)$, as $p$ is a path from $s$ to $v$ in $G_x$, which means that $d^x(v)$, the length of the shortest path in $G_x$ from $s$ to $v$, is at most the length of $p$.
    Otherwise, there exists an edge $(u, v_1)$ in $G_x$, such that $u$ is dead at time $x$, and the edge $(s,v_1)$ has weight $\hat{d}^{x}(u) + w(u, v_1)$.
    As shown above, since $u$ is dead at time $x$, we have $\hat{d}^{x}(u) \geq d^x(u)$.
    Therefore, 
    \[\hat{d}^x(v) \geq \hat{d}^{x}(u) + w(u, v_1) + d_{G'_x}(v_1, v) \geq d^x(u) + w(u, v_1) + d_{G_x}(v_1, v) \geq d^x(v).\]
    
    Next, we show that $\hat{d}^x(v) \leq d^x(v)(1 + \epsilon/ \log m)^i$. 
    Let $q$ be the shortest path from $s$ to $v$ in $G_x$.
    If $q$ is also present in $G'_x$, it follows that $\hat{d}^x(v) \leq d^x(v)(1 + \epsilon/ \log m)$.
    Otherwise, let $(a,b)$ be the last edge in $q$ that does not exist in $G'_x$. 
    Thus, either $a$ or $b$ is not alive in $G_x$. 
    
    First, let's assume $b$ is not alive in $G_x$.  Thus $b$ must be the last vertex in $q$---if there were an edge $(b,c)$ in $q$, this edge would exist in $G'_x$, so $b$ would be alive in $G_x$ (note that $b \neq s$).
    Since $b$ is the last vertex in $q$, and $v=b$ is dead in $G_x$, it follows that 
    \[
        \hat{d}^x(v) = \hat{d}^r(v) 
        \leq d^r(v)(1 + \epsilon/ \log m)^{i-1} 
        \leq d^x(v)(1 + \epsilon/ \log m)^{i-1},
    \]
    where $r$ is the end of the interval of node $x$ in the recursion tree.
    The first inequality follows from the induction hypothesis and the fact that the level of $r$ is strictly less than $i$, and the second inequality is because $x \leq r$ and adding more edges can only decrease the distance of each node from $s$.
    
    Otherwise, assume $b$ is alive in $G_x$, which means that $a$ is dead in $G_x$.
    Thus, there is an edge $(s,b)$ in $G'_x$ with weight $\hat{d}^x(a)+w(a,b)=\hat{d}^{r}(a) + w(a,b)$.
    Prepending this edge to the suffix of $q$ beginning at $b$ results in a path in $G'_x$ from $s$ to $v$ of length $\hat{d}^{r}(a) + w(a,b) + d_{G_x}(b,v)$. 
    Since the level of $r$ is less than $x$, 
    by the induction hypothesis we have $\hat{d}^{r}(a) \leq d^{r}(a)(1+\epsilon/\log m)^{i-1}$. 
    Hence, 
    \begin{align*}
      \hat{d}^x(v) &\leq  \left(\hat{d}^{r}(a) + w(a, b) + d_{G_x}(b, v)\right)(1 + \epsilon/\log m) \\ 
      &\leq \left(d^r(a)(1+\epsilon/\log m)^{i-1}+ w(a, b) + d_{G_x}(b, v)\right)(1 + \epsilon/\log m) \\
      &\leq \left(d^x(a) + w(a,b) + d_{G_x}(b, v)\right)(1 + \epsilon/\log m)^i \\
      &= d^x(v)(1 + \epsilon/\log m)^i. \qedhere
    \end{align*}
\end{proof}

With the correctness in place, the following lemma completes the proof of Theorem~\ref{thm:offline-approx} by bounding the running time of the offline algorithm. 

\begin{lemma}
\label{lem:offline-runtime}
    The offline algorithm runs in time $O(m\log (nW)  (\log^3 n) (\log \log n)/\epsilon)$.
\end{lemma}
\begin{proof}
    Let $m_y$ be the number of alive edges in a subproblem $y$.
    For a subproblem $[\ell, r]$, the time to find the alive edges and nodes in $G_x$ is $O(m_r)$, where $x$ is the midpoint of $[\ell, r]$. 
    For an alive edge $e = (u,v)$ in $G_x$, if $u$ is alive in $G_x$, then inserting $e$ in $G'_x$ takes $O(1)$ time.
    Otherwise, the algorithm needs to recover $\hat{d}^x(u)$ from the lowest ancestor of $x$ in the recursion tree in which $u$ is alive in order to calculate the weight of the edge $(s, v)$ in $G'_x$. 
    Each node $y$ in the recursion tree maintains $\hat{d}^{y}(w)$ for all alive vertices $w$ in $G_{y}$ in a balanced binary search tree.
    Therefore, the algorithm can check whether a vertex is alive in a subproblem in time $O(\log n)$.
    Also, if $w$ is alive in $G_y$, it takes $O(\log n)$ time to find $\hat{d}^y(w)$.
    Since node $x$ has at most $\log m$ ancestors, recovering $\hat{d}^x(u)$ can be done in $O(\log n \log\log m)$ time by doing a binary search on the ancestors.
    Hence, building $G'_x$ takes $O(m_x\log n \log\log m)$ time. 
    The time to run Dijkstra's on $G_x'$ is $O(m_x \log n)$.
    Also, the time to build the balanced binary search tree corresponding to subproblem $x$ is $O(m_x \log n)$, as the number of alive nodes in $G_x$ is bounded by the number of alive edges in $G_x$.
    Thus, the runtime of the algorithm is bounded by $O(\log n \log \log m)$ times the total number of alive edges in all the subproblems.
    
    For a given $i$ and $v$, let $x$ be the time when $\hat{d}(v)$ decreases from $( 1 + \epsilon/\log m)^{i+1}$ to $(1 + \epsilon/\log m)^i$.  
    Then $v$ is alive in any subproblem that contains $x$; there is at most 1 such subproblem in each level of the recursion tree.
    For each vertex $v$, summing over all $\log_{1 + \epsilon/\log m} (nW) = O(\log (nW) \log m/\epsilon)$ values of $i$ and the $\log m$ levels of the recursion tree, we have that there are in total $O(\log (nW) \log^2 m/\epsilon)$ subproblems in which $v$ is alive.
    Since an edge is only alive if its head is alive, there are only a total of $m \log (nW) \log^2 m/\epsilon$ alive edges over all subproblems.  
    Substituting $\log m = O(\log n)$, we obtain an aggregate running time $O(m\log (nW)(\log^3 n)(\log \log n)/\epsilon)$. 
\end{proof}