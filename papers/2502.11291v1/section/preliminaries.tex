\section{Preliminaries}
\label{sec:preliminary}

To motivate our work, we review argumentation approaches using Tarski abstract logic characterized by a consequence operator~\cite{Amgoud2009}. 
However, many logic in argumentation systems, like ABA or ASPIC systems, do not always impose certain axioms, such as the absurdity axiom.
Defining the consequence operator by means of "models" cannot allow users to understand reasoning progresses better, as inference rule steps are implicit. 
These motivate a slight generalization of consequence operators in a proof-theoretic manner, inspired by~\cite{Stephen1975}, with minimal properties.


Most of our discussion applies to abstract logics (monotonic and non-monotonic) which slightly generalize Tarski abstract logic.
Let $\mL$ be a set of \emph{well-formed formulas}, or simply \textit{formulas}, and $X$ be an arbitrary set of formulas in $\mL$. With the help of \emph{inference rules}, new formulas are derived from $X$; these formulas are called \emph{logical consequences} of $X$; a \emph{consequence operator} (called \textit{closure operator}) returns the logical consequences of a set of formulas. 
%Formal definitions are as follows.
    
\begin{definition}
     We define a map $\cn : 2^{\mL} \to 2^{\mL}$ such that $\cnb(X) = \bigcup_{n \geq 0}\cn^{n}(X)$ satisfies the axioms: %\leq or \geq
%
     \begin{itemize}
        \item ($A_1$) \textbf{Expansion} $X \subseteq \cnb(X)$.
        \item ($A_2$) \textbf{Idempotence} $\cnb(\cnb(X)) = \cnb(X)$.
         
        
    \end{itemize}
\end{definition}
In general, a map $2^{\mL} \to 2^{\mL}$ satisfying these axioms $A_1 -\ A_2$ is called a \emph{consequence operator}. Other properties that consequence operators might have, but that we do not require in this paper, are
\begin{itemize}   
    \item ($A_3$) \textbf{Finiteness} $\cnb(X) \subseteq \bigcup \{ \cnb(Y) \mid Y \subset_{f} X \}$ where the notation $Y \subset_{f} X$ means that $Y$ is a finite proper subset of $X$.
    \item ($A_4$) \textbf{Coherence} $\cnb(\emptyset) \neq \mL$.
    \item ($A_5$) \textbf{Absurdity} $\cnb(\{x\}) = \mL$ for some $x$ in the language $\mL$.
\end{itemize}

Note that finiteness is essential for practical reasoning and is satisfied by any logic that has a decent proof system.

An \emph{abstract logic} includes a pair $\mL$ and a consequence operator $\cn$. Different logics have consequence operators with various properties that can satisfy certain axioms. For instance, the class of Tarskian logics, such as classical logic, is defined by a consequence operator satisfying $A_1 -\ A_5$ while the one of defeasible logic satisfies $A_1 -\ A_3$. 




\begin{example} An inference rule $r$ in first-order logic is of the form $\frac{ p_1, \ldots, p_n}{c}$ where its conclusion is $c$ and the premises are $p_1, \ldots, p_n$. $c$ is called a \emph{direct consequence} of $p_1, \ldots, p_n$ by virtue of $r$. If we define $\cn(X)$ as the set of direct consequences of $X \subseteq \mL$, then $\cnb$ coincides with
$\cnb(X) = \{ \alpha \in \mL \mid X \vdash \alpha \}$ and
satisfies the axioms $A_1 -\ A_5$.
\end{example}

 Fix a logic $(\mL, \cn)$ and a set of formulas $X \subseteq \mL$. We say that:
\begin{itemize} 
    \item $X$ is \textit{consistent} wrt $(\mL, \cn)$ iff $\cnb(X) \neq \mL$. It is \textit{inconsistent} otherwise;   
     \item $X$ is a \textit{minimal conflict} of $\mK$ if $X^{\prime}  \subsetneq X$ implies  $X^{\prime}$ is consistent.
    \item A \textit{knowledge base} (KB) is any subset $\mK$ of $\mL$. Formulas in a KB are called \emph{facts}. A knowledge base may be inconsistent. %thus contains \textit{minimal conflicts}.
    %\item $X$ is a \textit{minimal conflict} of $\mK$ if it is inconsistent, but $X \setminus \{ \alpha\}$ is consistent for every $\alpha \in X$.
   
\end{itemize}

Reasoning in inconsistent KBs $\mK \subseteq \mL$ amounts to:
\begin{enumerate}
    \item Constructing \emph{maximal consistent subsets},
    \item Applying \emph{classical entailment mechanism} on a choice of the maximal consistent subsets. 
\end{enumerate}
Motivated by this idea, we give the following definition.

\begin{definition} Let $\mK$ be a KB and $X \subseteq \mK$ be a set of formulas. $X$ is a \emph{maximal (for set-inclusion) consistent subsets} of $\mK$ iff 
\begin{itemize}
    \item $X$ is consistent,
    \item there is no $X^{\prime}$ such that $X \subset X^{\prime}$ and $X^{\prime}$ is consistent.
\end{itemize}
 We denote the set of all maximal consistent subsets by $\msc(\mK)$.
\end{definition}

Inconsistency-tolerant semantics allow us to determine different types of entailments.
\begin{definition}
Let $\mK$ be a KB. A formula $\phi \in \mL$ is entailed in
\begin{itemize}
    \item  \emph{some maximal consistent subset}  iff for some $\Delta \in \msc(\mK)$, $\phi \in \cnb(\Delta)$;

    \item the \emph{intersection of all maximal consistent subsets} iff for $\Psi = \bigcap \{\Delta \mid \Delta \in \msc(\mK)\}$, $\phi \in \cnb(\Psi)$;

    \item   \emph{all maximal consistent subsets} iff for all $\Delta \in \msc(\mK)$, $\phi \in \cnb(\Delta)$.
\end{itemize}  
\end{definition}
%Intuitively, first case of Item 1 show that $\phi$ is an possible answer

Informally, \textit{some maximal consistent subset semantics} refers to \textbf{possible answers}, \textit{all maximal consistent subsets semantics} to \textbf{plausible answers}, and the \emph{intersection of all maximal consistent subsets semantics} to \textbf{surest answers}.

In the following subsections, we illustrate the generality of the above definition by providing instantiations for propositional logic, defeasible logic, \datalogPM.
Table~\ref{tab:properties} summarizes properties holding for consequence operators of the instantiations.

\begin{table} 
\centering
 \begin{tabular}{c l l l l l}
   \toprule
   Axioms & $\cn_c$  & $\cn_{p}$ & $\cn_{d}$ & $\cn_{co}$ & $\cn_{da}$ \\
   \midrule
   $A_1$ & $\times$ & $\times$ & $\times$ & $\times$   &  $\times$  \\
   $A_2$ & $\times$ & $\times$ & $\times$  & $\times$  & $\times$ \\
   $A_3$ & $ \times $ & $\times$ & $\times$ & $\times$ &   \\
   $A_4$ & $\times$ & $\times$ &  &  &    \\
   $A_5$ & $\times$ & $\times$ &  &  &  \\
   %$A_6$ &  &  &    &   \\
   \bottomrule
 \end{tabular}
 \caption{Properties of consequence operators of the instantiations}
 \label{tab:properties} 
\end{table}
%We present these instantiations to show that the abstract notion is general enough to model monotonic and nonmonotonic logics.
%

\subsection{Classical Logic}
We assume familiarity with classical logic. A logical language for classical logic $\mL$ is a set of well-formed formulas. Let us define $\cn_c: 2^{\mL_c} \to 2^{\mL_c}$ as follows:  
For $X \subseteq \mL_c$, a formula $x \in \mL_c$ satisfies $x \in \cn_c(X)$ iff the inference rule $\frac{y}{x}$ is applied to $X$ such that $y \in X$. Define $\cnb_c(X) = \bigcup_{n \geq 0}\cn_{c}^{n}(X)$. In particular, $\cnb_c$ is a consequence operator satisfying $A_1 -\ A_5$. Examples of classical logic are propositional logic and first-order logic. Next, we will consider propositional logic as being given by our abstract notions. Since first-order logic can be similarly simulated, we do not consider here in detail.

We next present \emph{propositional logic} as a special case of classical logic.
Let $A$  be a set of propositional atoms. Any atoms $a \in A$ is a well-formed formula wrt. $A$. If $\phi$ and $\alpha$ are well-formed formulas wrt. $A$ then $\neg \phi$, $\phi \wedge \alpha$, $\phi \vee \alpha$ are well-formulas wrt. $A$ (we also assume that the usual abbreviations $\supset$, $\leftrightarrow$ are defined accordingly). Then $\mL_{p}$ is the set of well-formed formulas wrt. $A$.

Let~$\cn_{p}: 2^ {\mL_{p}} \to 2^ {\mL_p}$ be defined as follows: for $X \subseteq \mL_p$, an element~$x\in \mL_p$
satisfies $x\in \cn_p(X)$ iff there are~$y_1,\ldots,y_j \in X$
such that~$x$ can be obtained from~$y_1,\ldots,y_j$ by the application of a single inference rule of propositional logic.

\begin{example} 
\label{ex:pro-logic}
Consider the propositional atoms $A_1 =\{x, y\}$ and the knowledge base $\mK_1 = \{x, y, x \supset \neg y\} \subseteq \mL_p$. Consider a set $\{x, x \supset \neg y\} \subseteq \mK_1$ .
If the inference rule (modus ponens) $\frac{ A, A \supset B}{B}$ is applied to this set, then $\cn_{p}(\{x, x \supset \neg y\}) = \{x, x \supset \neg y, \neg y\}$.
\end{example}
Consider $\cnb_p(X) = \bigcup_{n \geq 0}\cn_{p}^{n}(X)$.  For instance, $\cnb_{p}(\mK_1) = \{x, y, x \supset \neg y, \neg y, x \wedge y, \ldots\}$.
Since propositional logic is coherent and complete, then~$x\in \cnb_p(X) = \{x \mid X \models x \}$ where $\models$ is the entailment relation, i.e., $\phi \models \alpha$ if all models of $\phi$ are models of $\alpha$ in the propositional semantics. In particular,~$\cnb_{p}$ is a consequence operator  satisfying $A_1 -\ A_5$. The propositional logic can be defined as $(\mL_{p} , \cn_{p})$. 

It follows immediately 

\begin{lemma}
    $(\mL_{p} , \cn_{p})$ is an abstract logic.
\end{lemma}



\begin{example} [Continue Example~\ref{ex:pro-logic}] Recall $\mK_1$. The KB admits a MCS: $\{x, y, x \supset \neg y \}$.
    
\end{example}

%A consequence operator $\cn_ p$ is a map $2^{\mL_{p}} \to 2^{\mL_{p}}$  such that, for each $X \subseteq \mL_{p}$, $\cnb_{p}(X) = \{\alpha \in \mL_{p} \mid X \models \alpha\}$. 




\subsection{Defeasible Logic}
\label{subsec:defeasible-logic}
%The language for defeasible logic is based on rules of the following form where $\beta_1, \ldots, \beta_j, \beta_{j+1}$ are literals and $\Rightarrow$ is an implication symbol.

Let $(\mL_d, \cn_d)$ be a defeasible logic such as used in defeasible logic programming~\cite{Alejandro2014}, assumption-based argumentation (ABA)~\cite{Dung2009}, ASPIC/ ASPIC+ systems~\cite{Prakken2002,ModgilP14}.
%Following~\cite{Prakken2002}, one claims that strict and defeasible rules may play two roles: either they encode information of the knowledge base, in which case they are part of the language $\mL_d$, or they represent inference rules, in which case they are part of the consequence operator $\cn_d$. Here we consider the former case, i.e., strict and defeasible rules are used for encoding certain and defeasible information (We refer to Section 5 in \cite{Amgoud12} for encoding the later case).
The language for defeasible logic $\mL_d$ includes a set of (strict and defeasible) rules and a set of literals. The rules is the form of $x_1, \ldots x_i \rightarrow_{s} x_{i+1}$ ($x_1, \ldots x_i \rightarrow_{d} x_{i+1}$) where $x_1, \ldots x_i, x_{i+1}$ are literals and $\rightarrow_{s}$ (denote strict rules) and $\rightarrow_{d}$ (denotes defeasible rules) are implication symbols.
\begin{definition}
Define $\cn_d: 2^{\mL_d} \to 2^{\mL_d}$ as follows: for $X \subseteq \mL_d$, a formula $x \in \mL_d$ satisfies $x \in \cn_d(X)$ iff at least of the following properties is true:
\begin{enumerate}
    \item $x$ is a literal in $X$,
    \item there is $(y_1,\ldots,y_j)\rightarrow_s x \in X$, or $(y_1,\ldots,y_j)\rightarrow_d x \in X$ st. ~$\{ y_1,\ldots,y_j \} \subseteq X$.
\end{enumerate}
Define $\cnb_d(X) = \bigcup_{n \geq 0}\cn_{d}^{n}(X)$.
\end{definition}

\begin{remark}  One can describe $\cnb_d$ explicitly.
We have $x \in \cnb_{d}(X)$ iff there exists a finite \emph{sequence} of literals $x_1, \ldots, x_n$ such that
\begin{enumerate}
    \item $x$ is $x_n$, and
    \item for each $x_i \in \{x_1, \ldots, x_n \}$,
    \begin{itemize}
        \item  there is $ y_1 , \ldots , y_j \rightarrow_{s} x_i \in X$, or $ y_1 , \ldots , y_j \rightarrow_{d} x_i \in X$, such that $\{ y_1 , \ldots , y_j \} \subseteq \{x_1, \ldots , x_{i-1} \}$,
        \item or $x_i$ is a literal in $X$.
    \end{itemize}
\end{enumerate}


Note that if $x \in \cn_{d}^{n}(X)$, the above sequence $x_1, \ldots, x_n$ might have length~$m\neq n$: intuitively~$n$ is the depth of the proof tree while~$m$ is the number of nodes.
\end{remark}





% Let~$\CN_d: 2^\L \to 2^\L$ be defined as follows: an element~$x\in \L$
% satisfies $x\in \CN_d(X)$ if and only if at least one of the following properties is true:
% \begin{enumerate}
% \item $x\in X$
% \item $(y_1,\ldots,y_m)\implies_s x \in X$ or $(y_1,\ldots,y_m)\implies_d x \in X$
% 	for some~$y_1,\ldots,y_m \in X$.
% \end{enumerate}

% there are~$y_1,\ldots,y_m \in X$

% Consider the closure~$\CNN_{d}(X) = \cup_{n\geq 0} \CN_{d}^n(X)$.
% One can describe the closure~$\CNN_{\mathrm{prop}}$ explicitly.
% We have~$x\in \CNN_{d}(X)$ if and only if

% SEQUENCE $x_1,\ldots,x_m$.

% Note that if~$x\in \CN_d(X)$, the above sequence~$x_1,\ldots,x_m$ might have length~$m\neq n$:
% intuitively~$n$ is the depth of the proof tree while~$m$ is the number of nodes.

% Note that there is a substantial difference between~$\CN_{\mathrm{prop}}$
% and~$\CN_d$: in the first case~$\CN_{\mathrm{prop}}$ is the result of obtaining any
% inference rule of propositional logic (which is an infinite set of axioms),
% while in the second case~$\CN_d(X)$ is obtained as the consequences of
% rules~$(y_1,\ldots,y_m)\implies_d x$ that are inside the (possibly finite) set~$X$.


\begin{example}
\label{ex:de-logic}
Consider the KB $\mK_2 = \{x, x \rightarrow_s y, t \rightarrow_d z \} \subseteq \mL_d$. $\cnb_{d}(\mK_2) = \{x, y\}$ where the sequence of literals in the derivation is $x, y$. The KB admits a MCS: $\{x, x \rightarrow_s y, t \rightarrow_d z \}$
\end{example}

%the knowledge base $\mK_2 = \{a, \neg b, a \rightarrow_s \neg c ,\ \neg b \wedge \neg c \rightarrow_{d} s,\ s \rightarrow_{s} t,\ a \wedge t \rightarrow_{d} u \} \subseteq \mL_{d}$. Then $\cnb_{d}(\mK_2) = \{a, \neg b, a \rightarrow_s \neg c ,\ \neg b \wedge \neg c \rightarrow_{d} s,\ s \rightarrow_{s} t,\ a \wedge t \rightarrow_{d} u, u\}$ where the sequence of literals in the derivation is $a, \neg c, \neg b, s, t, u$.


\begin{remark}
\label{re:aspic}
For ASPIC/ASPIC+ systems~\cite{Prakken2002,ModgilP14}, Prakken claimed that strict and defeasible rules can be considered in two ways: (1) they encode information of the knowledge base, in which case they are part of the logical language $\mL_d$, (2) they represent inference rules, in which case they are part of the consequence operator.
These ways can encoded by consequence operators as in~\cite{Amgoud12}. Our definition of $\cnb_{d}$ can align with the later interpretation as done in~\cite{Amgoud12}.
In particular, if we consider $X$ being a set of literals of $\mL_d$ instead of being a set of literals and rules as above, the definitions of $\cn_d$ and $\cnb_d$ still hold for this case. 
Thus, the defeasible logic of ASPIC/ASPIC+ can be represented by the logic $(\mL_d, \cn_d)$ in our settings.
\end{remark}

\begin{proposition} [~\cite{Amgoud12}]
    $\cnb_d$ satisfies $A_1 -\ A_3$.
\end{proposition}

It follows immediately

\begin{lemma}
    $(\mL_d, \cn_d)$ is an abstract logic.
\end{lemma}


In~\cite{CaminadaA07}, proposals for argumentation using defeasible logic were criticized for violating the postulates that they proposed for acceptable argumentation. One solution is to introduce \emph{contraposition} into the reasoning of the underlying logic. 
This solution can be seen as another representation of defeasible logic.
We introduce contraposition by defining a consequence operator as follows: 

Consider $\mL_{co}$ containing a set of literal and a set of (strict and defeasible) rules $\mR_{s}$ ($\mR_{d})$. For this case represent inference rules, namely, they are part of a consequence operator.  For $\Delta \subseteq \mL_{co}$,  $\texttt{Contrapositives}(\Delta)$ is the set of contrapositives formed from the rules in $\Delta$. For instance, a strict rule $s$ is a contraposition of the rule $\phi_1, \ldots, \phi_n \rightarrow_{s} \alpha \in \mR_s$ iff $s = \phi_1, \ldots, \phi_{i-1}, \neg \alpha, \phi_{i+1}, \ldots, \phi_n \rightarrow_s \neg \phi_i$ for $ 1 \leq i \leq n$.

\begin{definition}
\label{def:cn-contrapositive}
Define $\cn_{co} : 2^{\mL_{co}} \to 2^{\mL_{co}}$ as follows: for a set of literals $X \subseteq \mL_{co}$, a formula $x \in \mL_{co}$ satisfies $x \in \cn_{co}(X)$ iff at least of the following properties is true:
\begin{enumerate}
    \item $x$ is a literal in $X$,
    \item there is $(y_1,\ldots,y_j)\rightarrow_s x \in \mR_{s} \cup \texttt{ \textup{Contrapositives}}(\mR_s)$, or $(y_1,\ldots,y_j)\rightarrow_d x \in \mR_{d}  \cup \texttt{\textup{Contrapositives}}(\mR_d)$ such that~$\{ y_1,\ldots,y_j \} \subseteq X$.
\end{enumerate}
Define $\cnb_{co}(X) = \bigcup_{n \geq 0}\cn_{co}^{n}(X)$.
\end{definition}

\begin{remark}
Similarly, one can represent $\cnb_{co}$ as follows: $x \in \cnb_{co}(X)$ iff there exists a \emph{sequence} of literals $x_1, \ldots, x_n$ such that
\begin{enumerate}
    \item $x$ is $x_n$, and
    \item for each $x_i \in \{x_1, \ldots, x_n \}$,
    \begin{itemize}
        \item  there is $ y_1 , \ldots , y_j \rightarrow_{s} x_i \in \mR_s \cup \texttt{\textup{Contrapositives}}(\mR_s)$, or $ y_1 , \ldots , y_j \rightarrow_{d} x_i \in \mR_d \cup \texttt{\textup{Contrapositives}}(\mR_d)$, such that $\{ y_1 , \ldots , y_j \} \subseteq \{x_1, \ldots , x_{i-1} \}$,
        \item or $x_i$ is a literal in $X$.
    \end{itemize}
\end{enumerate}
\end{remark}

\begin{proposition} 
    $(\mL_{co}, \cn_{co})$ is an abstract logic. $\cnb_{co}$ satisfies $A_1 -\ A_3$.
\end{proposition}



\begin{example}
    Consider $\mK_3 = \{q, \neg r, p \wedge q \rightarrow_{d} r, \neg p \rightarrow_s u\}$, $\texttt{\textup{Contrapositives}}(\mK_3) = \{\neg r \wedge q \rightarrow_{d} \neg p, \neg r \wedge p \rightarrow_{d} \neg q, \neg u \rightarrow_s p\}$. Then $\cnb_{co}(\mK_3) = \{q, \neg r, \neg p, u\}$  where the sequence of literals in the derivation is $q, \neg r, \neg p, u$. The KB admits MCSs: $\{q, \neg r, \neg p \rightarrow_s u \}$ and $\{q, p \wedge q \rightarrow_{d} r, \neg p \rightarrow_s u\} $.
\end{example}





\subsection{\datalogPM}


%Throughout the paper, to illustrate our demonstrations, we shall use \datalogPM~\cite{CALI201257}.
%with familiar terminology such as variables, terms, atoms, formulas, etc.
We consider  \datalogPM~\cite{CALI201257}, and shall use it to illustrate our demonstrations through the paper.

%Let $(\mL_{da}, \cn_{da})$ be \datalogPM.
We assume a set \NT of \emph{terms} which contain variables, constants and function terms. An atom is of the form $P(\Vec{t})$, with $P$ a predicate name and $\Vec{t}$ a vector of terms, which is \emph{ground} if it contains no variables. 
A \emph{database} is a finite set of ground atoms (called \emph{facts}).
A \emph{tuple-generating dependency} (TGD) $\sigma$ is a first-order formula of the form $\forall \x \forall \y \phi(\x, \y) \rightarrow \exists \Vec{z} \psi(\x, \Vec{z})$, where $\phi(\x, \y)$ and $\psi(\x, \Vec{z})$ 
are non-empty conjunctions of atoms.
We leave out the universal quantification, and  refer to  $\phi(\x, \y)$ and $\psi(\x, \Vec{z})$ as the \emph{body} ad \emph{head} of $\sigma$.
A \emph{negative constraint} (NC) $\delta$ is a rule of the form $\forall \x$ $\phi(\x)\rightarrow \bot$
where $\phi(\x)$ is a conjunction of atoms. We may leave out the universal restriction.
A language for \datalogPM $\mL_{da}$ includes a set of facts and a set of TGDs and NCs. A knowledge base $\mK$ of  $\mL_{da}$ is now a tuple $(\mF, \mR, \mC)$ where a database $\mF$, a set $\mR$ of TGDs and a set $\mC$ of NCs.

Define $\cn_{da} : 2^{\mL_{da}} \to 2^{\mL_{da}}$ as follows: Let $X$ be a set of facts of $\mL_{da}$, an element $x \in \mL_{da}$ satisfies $x \in \cn_{da}(X)$ iff there are $y_1, \ldots, y_j \in X$ s.t. $x$ can be obtained from $y_1, \ldots, y_j$ by the application of a single inference rule. Note that we treat such TGDs and NCs as inference rules.

Consider $\cnb_{da}(X) = \bigcup_{n \geq 0}\cn_{da}^{n}(X)$. Similar to proposition logic, ~$x \in \cnb_{da}(X) = \{x \mid X \models x \}$ where $\models$ is the entailment of first-order formulas, i.e., $X \models x$ holds iff every model of all elements in $X$ is also a model of $x$. 
$\cnb_{da}$ satisfies the properties $A_1, A_2$.
Note that the finiteness property ($A_3$) still holds for some fragments of \datalogPM, such as \emph{guarded}, \emph{weakly guarded} \datalogPM. 

It follows immediately

\begin{lemma}
    $(\mL_{da}, \cn_{da})$ is an abstract logic.
\end{lemma}

\begin{example} [Continue Example~\ref{ex:motivation-ex}]
\label{ex:motivation} Recall $\mK_1$.
% Let $\mK_1 = (\mF_1, \mR_1, \mC_1)$ be a knowledge base  where
% \begin{align*}
% \mF_1 = & \{\teAs(\vi,\kd),\ \te(\vi, \kd),\ \uc(\kd),\ \te(\vi,\kr),\ \gc(\kr) \} \\
% \mR_1 = & \{ r_1:\ \lect(x) \rightarrow \emp(x) ,\
%   r_2:\ \rese(x) \rightarrow \emp(x),\ \\
% & r_3:\ \fp(x) \rightarrow \rese(x) ,\
%   r_4:\ \teAs(x,y) \land \uc(y)  \rightarrow \ta(x),\ \\
% & r_5:\ \te(x,y) \rightarrow \lect(x),\
%   r_6:\ \te(x,y) \land \gc(y)  \rightarrow \fp(x) \} \\
% \mC_1 = & \{ c_1:\ \ta(x) \land \rese(x) \rightarrow \bot,\
%   c_2:\ \lect(x) \land \ta(x) \rightarrow \bot\}
% %&c_2: \lect(x), \fp(x) \rightarrow \bot\\
% \end{align*}
The KB admits MSCs (called \emph{repairs} in \datalogPM):
\begin{align*}
        & \mB_1 =  \{ \teAs(\vi,\kd), \uc(\kd) \}  \quad 
          \mB_3 = \{\teAs(\vi,\kd), \te(\vi,\kr), \te(\vi, \kd), \gc(\kr) \}\\
        & \mB_2 = \{\te(\vi,\kr), \gc(\kr), \te(\vi, \kd) \}  \quad
        \mB_4 = \{\teAs(\vi,\kd), \te(\vi,\kr), \te(\vi, \kd), \uc(\kd) \} \\
       & \mB_5 = \{\gc(\kr) , \te(\vi,\kr), \te(\vi, \kd), \uc(\kd) \}
         \quad
        \mB_6 = \{\uc(\kd), \teAs(\vi, \kd), \gc(\kr) \}
    \end{align*}
Consider $q_1 = \rese(\vi)$. We have that $\vi$ is a \emph{possible answer} for $q_1$ since $q_1$ is entailed in some repairs, such as $\mB_2,\ \mB_3,\ \mB_5$.
\end{example}

\section{Proof-oriented (Logical) Argumentations}
\label{sec:proof-arg}
In this section, we present \emph{proof-oriented (logical) argumentations} (P-SAFs) and their ingredients. We also provide insights into the connections between our framework and state-of-the-art argumentation frameworks. We then show the close relations of reasoning with P-SAFs to
reasoning with MCSs. 

\subsection{Arguments, Collective Attacks and Proof-oriented Argumentations}

 \textit{Logical arguments} (\textit{arguments} for short) built from a KB may be defined in different ways. For instance, arguments are represented by the notion of \emph{sequents}~\cite{ArieliS19}, \emph{proof}~\cite{SCHULZ_TONI_2016,Dung2009}, a pair of $(\Gamma,\ \psi)$ where $\Gamma$ is the
\textit{support}, or \textit{premises}, or \textit{assumptions} of the argument, and $\psi$ is the \textit{claim}, or \textit{conclusion}, of the argument~\cite{LoanHo2022,ARIOUA2017244}. To improve explanations in terms of representation and understanding, we choose the form of \emph{proof} to represent arguments. 
The proof is in the form of a tree.
% We formalize proofs as  \emph{directed hypergraphs}, which are tuples $(V,E)$ consisting of a finite $V$ of \emph{vertices}, a finite $E$ of \emph{(hyper)edges} of the form $(S,d)$ with $S \subseteq V$ and $d \in V$. A vertex $v \in V$ is called a leaf if it has no incoming hyperedges, i.e., there is no $(S,v) \in E$, and $v$ is a sink if it has no outgoing hyperedges, i.e., there is no $(S,d) \in E$ such that $v \in S$.


% \begin{definition}[Cycle, Tree]
%  Given a (directed) hypergraph $G = (V,E)$ and $s,t \in V$, a \emph{path} $P$ of length $k \geq 0$ in H from $s$ to $t$ is a sequence of vertices and hyperedges 
%  %
% \[ P = (d_0, (S_1, d_1), d_1, (S_2, d_2), \ldots, d_{k-1}, (S_k, d_k), d_k),\]
% %
% where $d_0 = s$, $d_k = t$, and $d_{j-1} \in S_j$ for all $j, 1 \leq j \geq k$. If there is such a path of length $q > 0$ in $G$, we say that $t$ is reachable from $s$ in $G$. If $t = s$, then $P$ is called a \emph{cycle}. The hypergraph $G$ is \emph{acyclic} if it does not contain a cycle. 
% %The hypergraph $G$ is \emph{connected} if every vertex is connected to every other vertex by a series of paths and reverse paths.

% A hypergraph $G = (V, E)$ is called a tree with root $t \in V$ if $t$ is reachable from every vertex $v \in V \setminus \{t\}$ by exactly one path. The root is the only sink in a tree, and all trees are acyclic.
% \end{definition}

% \begin{definition}
% \label{def:ab-arg}
% A \emph{proof} for a formula $\phi \in \mL$ is \emph{derivable} from a set of formulas $H \subseteq \mL$ is a hypergraph $G$ such that
% \begin{itemize}
%     \item $G$ contains exactly one sink holding $\phi$;
%     \item the leaves in $G$ holds the set of formulas $H$;
%     \item for every inner node $N$, if $N$ is not a leaf and holds the formula $\beta_0$, then its successors hold $n$ formulas $\beta_1, \ldots , \beta_n$ such that $\beta_0 \in \cn(\{\beta_1, \ldots , \beta_n\})$.
% \end{itemize}
% %A tree proof is a proof that is a tree.
% If such a hypergraph exists (it might not be unique), we call $A : H \Rightarrow \phi$
% an \emph{argument} with the \emph{support set} $\Sup(A) = H$ and the \emph{conclusion} $\Con(A) = \phi$.
% %An argument $A : H \Rightarrow \phi$ is said to be \emph{finite} if there is an acyclic hypergraph (tree) for $\phi$ derived from $H$ such that $H$ contains facts in $\mK$.
% %An argument $A : H \Rightarrow \phi$ is said to be \emph{infinite} if there is a cyclic hypergraph for $\phi$ derived from $H$.
% We denote the set of arguments induced from $ \mK$ by $\Arg_{\mK}$. 
% \end{definition}




\begin{definition}
\label{def:ab-arg}
A formula $\phi \in \mL$ is \emph{tree-derivable} from a set of \emph{fact-premises} $H \subseteq \mK$
%denoted by $H \rightarrow_{d} \phi$
if there is a tree such that
\begin{itemize}
    \item the root holds $\phi$;
    \item $H$ is the set of formulas held by leaves;
    \item for every inner node $N$, if $N$ holds the formula $\beta_0$, then its successors hold $n$ formulas $\beta_1, \ldots , \beta_n$ such that $\beta_0 \in \cn(\{\beta_1, \ldots , \beta_n\})$.
    %is not a leaf and 
\end{itemize}
% If  $\phi \in \mL$ is tree-derivable from $H$,
If such a tree exists (it might not be unique), we call $A : H \Rightarrow \phi$
an \emph{argument} with the \emph{support set} $\Sup(A) = H$ and the \emph{conclusion} $\Con(A) = \phi$. We denote the set of arguments induced from $ \mK$ by $\Arg_{\mK}$.


% If such a derivation $H \rightarrow_{d} \phi$ exists (it might not be unique),
% we use the notation $H \Rightarrow \phi$.
% we call $A= H \Rightarrow \phi$
% an \emph{argument}, and define $\Con(A) = \phi$ and $\Sup(A) = H$.

% We call $A = H \Rightarrow \phi$ an \emph{argument} iff there is a tree-derivation $H \rightarrow_{d} \phi$. For such an argument, we set $\Con(A) = \phi$ and $\Sup(A) = H$. We call $\Con(A)$ the \emph{conclusion} of $A$  and $\Sup(A)$ the \emph{support set} of $A$.
\end{definition}

\begin{remark}
 By Definition~\ref{def:ab-arg} it follows that $ H \Rightarrow \phi$ is an argument iff $\phi \in \cnb(H)$.   
\end{remark}



%Intuitively, a tree represents a possible derivation of the formula at its root given the rules of the program and the assumptions made at its leaves. The formula labeled an interior node is either a logical consequence of the conjunction of formulae labeled its children (first case of Item 2) or it is the head of a ground rule whose body is the conjunction of formulae labeled its children (second case of Item 2).
Note that an individual argument can be represented by several different trees (with the same root and leaves). We assume these trees represent the same arguments; otherwise, we could have infinitely many arguments with the same support set and conclusion.

Intuitively, a tree represents a possible derivation of the formula at its root and the fact-premise made at its leaves.
The leaves of the tree, constituting the fact-premise, belong to $H = \cn^0 (H)$.
If a node $\beta$ has children nodes
$\beta_{a_1} \in \cn^{i_1} (H)$, \ldots, $\beta_{a_k} \in \cn^{i_k} (H)$,
then $\beta \in \cn^{i+1}(X)$ where $i=\max\{i_1,\ldots,i_k\}$ because by the extension property $\cn^{i_1} (H),\ldots,\cn^{i_k} (H)\subseteq \cn^{i}(H)$.
The root $\phi$, constituting the conclusion, belongs to $\cn^n(H)$,
where $n$ is the longest path from leaf to root.
Note that, by the extension property,
if $\beta \in \cn^i(H)$, then also $\beta \in \cn^{i+1}(H)$, $\beta \in \cn^{i+2}(H)$, \ldots.
The idea is to have $i$ in $\cn^i(H)$ as small as possible (we don't want to argue
longer than necessary).

%CYCLIC TREE TO USE FOR THE CONDITIONS OF THE COMPLETENESS...




Some proposals for logic-based argumentation stipulate additionally that the argument's support is consistent and/or that none of its subsets entails the argument's conclusion (see~\cite{Hunter2010}).
However, such restrictions, i.e., minimality and consistency, are not substantial (although required for some specific logics).
In some proposals, the requirement that the support of an argument is consistent may be irrelevant for some logics, especially when consistency is defined by satisfiability.
For instance, in Priest’s three-valued logic~\cite{Priest89} or Belnap’s four-valued logic~\cite{Belnap1977}, every set of formulas in the language of $\{ \neg, \vee, \wedge\}$ is satisfiable.
In frameworks in which the supports of arguments are represented only by literals (atomic formulas or their negation),  arguments like $A = \{a, b\} \Rightarrow a \vee b$ are excluded since their supports are not minimal, although one may consider$\{a, b\}$ a stronger support for $a \vee b$ than, say, $\{a\}$, 
since the set $\{a, b\}$ logically implies every minimal support of $a \vee b$.
To keep our framework as general as possible, we do not consider the extra restrictions for our definition of arguments (See~\cite{Hunter2010,ArieliS19} for further justifications of this choice).

%In the following example, we generalize Definition~\ref{def:ab-arg} into a form of \datalogPM.


We present instantiations to show the generality of Definition~\ref{def:ab-arg} for generating arguments in argumentation systems in the literature.

\begin{itemize}
\item We start with \emph{deductive argumentation} that uses classical logic. In~~\cite{BesnardH01}, arguments as pairs of premises and conclusions can be simulated in our settings, and for which $H \Rightarrow \phi$ is an argument (in the form of tree-derivations), where $H \subseteq \mL_c$ and $\phi \in \mL_c$ iff $\phi \in \cnb_{c}(H)$, $H$ is minimal (i.e., there is no $H^{\prime} \subset H$ such that $\phi \in \cnb_{c}(H^{\prime})$) and $H$ is consistent. 
For example, we use the propositional logic in Example~\ref{ex:pro-logic}, and the following is an argument in propositional logic $A : \{x, x \supset \neg y \} \Rightarrow \neg y$. Tree-representation of $A$ is shown in Figure~\ref{fig:propositional-DeLP-sequent} (left).
Similarly, since most Description Logics (DLs), such as $ALC$, DL-Lite families, Horn DL, etc.,  are decidable fragments of first-order logic, it is straightforward to apply Definition~\ref{def:ab-arg} to encode arguments of the framework using the DL $ALC$ in~\cite{ZhangL13}.

\item We consider defeasible logic approaches to argumentation, such as~\cite{Dung2009,DimopoulosD0R0W24,Rapberger2024,Lehtonen2024,Alejandro2014}. 
For \emph{defeasible logic programming}~\cite{Alejandro2014}, $H \Rightarrow \phi$ is an argument (in the form of tree-derivations) iff $\phi \in \cnb_d(H)$ and there is no $H^{\prime} \subset H$ such that $\phi \in \cnb_d(H^{\prime})$ and it is not the case that there is $\alpha$ such that $\alpha \in \cnb_d(H)$ and $\neg \alpha \in \cnb_d(H)$ (i.e. $H$ is a minimal consistent set entailing $\phi$).


For "\emph{flat}"-\emph{ABA}~\cite{Dung2009,DimopoulosD0R0W24}, assume that $\cn_d$ ignores differences between various implication symbols in the knowledge base, and for which $H \Rightarrow \phi$ is an argument iff $\phi \in \cnb_d(H)$ where $H \subseteq \mL_{d}$. In this case, the argument, from the support $H$ to the conclusion $\phi$,
can be described as tree-derivations by $\cn_d$.
%a sequence of applications of inference rules.
%Such sequence is naturally organized in the shape of a tree by $\cn_d$.
%Each step up the tree corresponds to an application of an inference rule.
Note that the minimality and consistency requirements are dropped. 
Similarly, in \emph{"non-flat"}-\emph{ABAs}~\cite{Rapberger2024,Lehtonen2024}, arguments as tree-derivations can be simulated in our setting.

Note, in~\cite{Alejandro2014} only the defeasible rules are represented in the support of the argument, and in~~\cite{Dung2009,DimopoulosD0R0W24,Rapberger2024,Lehtonen2024} only the literals are represented in the support of the argument, but in both cases it is a trivial change (as we do here) to represent both the rules and literals used in the derivation in the support of the argument.

\begin{example}
For $\mK_5 = \{a, \neg b, a \rightarrow_s \neg c ,\ \neg b \wedge \neg c \rightarrow_{d} s,\ s \rightarrow_{s} t,\ a \wedge t \rightarrow_{d} u \}$, the following is an argument in defeasible logic programming $B : \{a, \neg b, a \rightarrow_s \neg c , \neg b \wedge \neg c \rightarrow_{d} s \} \Rightarrow s$ with the sequences of literals $a, \neg c , \neg b, s$. Tree-representations of the arguments are shown in Figure~\ref{fig:propositional-DeLP-sequent} (middle).

For $\mK_6 = \{p, \neg q, s, p \rightarrow \neg r, \neg q \wedge \neg r \wedge s \rightarrow t, t \wedge p \rightarrow u, v \}$, the following is an argument in ABA $C : \{p, \neg q, s, p \rightarrow \neg r, \neg q \wedge \neg r \wedge s \rightarrow t \} \Rightarrow t$.

\end{example}

\item We translate ASPIC/ ASPIC+~\cite{Prakken2002,ModgilP14} into our work as follows:

We have considered the underlying logic of ASPIC/ ASPIC+ as being given by $\cnb_{d}$ (see Remark~\ref{re:aspic}) and $\mL_d$ including the set of literals and strict/ defeasible rules.

We recall argument of the form $A_1, \ldots, A_n \rightarrow_s / \rightarrow_d \phi$ 
in these systems as follows:
\begin{enumerate}
    \item Rules of the form $\rightarrow_s / \rightarrow_d \alpha$ , are arguments with conclusion $\alpha$.

    \item  Let $r$ be a strict/defeasible rule of the form $\beta_1, \ldots, \beta_n \rightarrow_s / \rightarrow_d \phi$, $n \geq 0$.
    Further suppose that $A_1, \ldots, A_n$, $n \geq 0$, are arguments with conclusions $\beta_1, \ldots, \beta_n$ respectively.
    Then $A_1, \ldots, A_n \rightarrow_s / \rightarrow_d \phi$ is an argument with conclusion $\phi$ and last rule $r$.
    
    \item Every argument is constructed by applying finitely many times the above two steps.
\end{enumerate}


The arguments of the form $A_1, \ldots, A_n \rightarrow_s / \rightarrow_d \phi$ can be viewed as tree-derivations in the sense of Definition~\ref{def:ab-arg}, in which the conclusion of the argument is $\phi$; 
the support $H$ of the argument is the set of leaves that are rules of the form $\rightarrow_s / \rightarrow_d \alpha_i$ such that $\alpha_i \in \cn^{0}_{d}(H)$. In this view, the root of the tree is labelled by $\phi$ such $\phi \in \cn^{n}_{d}(H)$; the children $\beta_i$, $i = 1, \ldots, n$, of the root are the roots of subtrees $A_1, \ldots, A_n$; if $\phi \in \cn^{n}_{d}(H)$, then $\beta_i \in \cn^{n-1}_{d}(H)$.
Since $\cnb_{d}(H) = \bigcup_{n}\cn^{n}_{d}(H) $, it follows that $\phi \in \cnb_{d}(H)$.
Note that if $n = 0$, the tree consists of just the root that is the rule of the form $\rightarrow_s / \rightarrow_d \phi$.


% arguments $A_1, \ldots, A_n \rightarrow_s / \rightarrow_d \phi$ are often viewed as proof trees with root labelled by $\phi$
% and the children of the root are the roots of subtrees $A_1, \ldots, A_n$.
% Note that if $n = 0$, the proof tree consists of just the root.



\item In argumentation framework for \datalogPM~\cite{ARIOUA201776,Amgoud12}, arguments, viewed as pairs of the premises $H$ (i.e., the set of facts) and the conclusion $\phi$ (i.e., the derived fact), can be represented as tree-derivations in our definitions as follows:  For a consistent set $H \subseteq \mF$ and $\phi \in \mL_{da}$, $H \Rightarrow \phi$ is an argument in the sense of Definition~\ref{def:ab-arg} iff $\phi \in \cnb_{da}(H)$, in which $\phi$ is the root of the tree; $H$ are the leaves.

\begin{example}
    Let us continue Example~\ref{ex:motivation}, the following is an argument in the framework using \datalogPM~$A_7 : \{ \teAs(\vi, \kd),\ \uc(\kd) \} \Rightarrow \ta(\vi)$. By Definition~\ref{def:ab-arg}, the argument can be viewed as a proof tree with the root labelled by $\ta(\vi)$ and the leaves labelled $\teAs(\vi, \kd),\ \uc(\kd)$.
\end{example}
\end{itemize}

\begin{figure}
\begin{tikzpicture}
    \node (dt) at (0,0) {\includegraphics[scale=0.7]{Picture/propositional_logic.pdf}};
    \node (d1) at (5, 0) {\includegraphics[scale=0.7]{Picture/DeLP.pdf}};
     \node (d1) at (10, 0) {\includegraphics[scale=0.7]{Picture/sequent.pdf}};
\end{tikzpicture}
\caption{
Tree-representation for arguments wrt logics.
}
\label{fig:propositional-DeLP-sequent}
\end{figure}







% Different attack relations have been considered in the literature for logic-based argumentation.
% However, some definitions of attack are not suitable to capture non-binary conflicts~\cite{Prakken2002,Alejandro2014,Dung2009,ZhangL13,SCHULZ_TONI_2016}. The attack definitions in~\cite{ARIOUA201776,Castagna21,ArieliS19} can capture non-binary conflicts, and these frameworks can generate a large number (See~\cite{yun2018,Yun2020SetsOA} for justifications in the case of \datalogPM).
% To overcome this, we use the notion of \emph{collective attacks}.



As shown in examples of~\cite{Yun2020SetsOA,Amgoud12,ArieliH24}, binary attacks, used in the literature~\cite{ArieliS19,ARIOUA201776,LoanHo2022,ZhangL13,Castagna21}, are not enough expressive to capture cases in which n-ary conflicts may arise.
To overcome this limit, some argumentation frameworks introduced the notion of \emph{collective attacks} to better capture non-binary conflicts, and so improve the decision making process in various conflicting situations. To ensure the generality of our framework, we introduce collective attacks.

 
\begin{definition} [Collective Attacks]
\label{def:ab-att} 
Let $A: \Gamma \Rightarrow \alpha$ be an argument and $\mX \subseteq \Arg_{\mK}$ be a set of arguments such that $\bigcup_{X \in \mX}\Sup(X)$ is consistent. We say that
    \begin{itemize}
        \item $\mX$ \emph{undercut-attacks} $A$ iff there is $\Gamma^{\prime} \subseteq \Gamma$ s.t $\bigcup_{X \in \mX} \{ \Con(X)\} \cup \Gamma^{\prime}$ is inconsistent.
        %\item \emph{direct undercut-attack} $A$ iff there is $\beta \in \Gamma$ s.t $\bigcup_{X \in \mX} \{ \Con(X)\} \cup \beta$ is inconsistent.
        \item $\mX$ \emph{rebuttal-attacks} $A$ iff $\bigcup_{X \in \mX} \{ \Con(X)\} \cup \{\alpha \}$ is inconsistent.
  
        % \item $A_1$ is an \emph{undercut-attack} of $A_2$ if there is $\Gamma^{\prime}_{2} \subseteq \Gamma_2$ st $\Gamma^{\prime}_{2} \cup \{\alpha_1 \}$ is inconsistent.
        % \item $A_1$ is a \emph{rebuttal-attack} of $A_2$ iff $\{\alpha_1, \alpha_2\}$ is inconsistent.
    \end{itemize}
%If this holds, we say that $\mS$ \emph{attacks} $A_1$.
We can say that $\mX$ \emph{attacks} $A$ for short. We use $\Att_{\mK} \subseteq  2^{\Arg_{\mK}} \times \Arg_{\mK}$ to denote \emph{the set of attacks} induced from $ \mK$.
\end{definition}

% A = ({a,b,c}, a)


% X = (***, NOT(a & b & c))

% X attacks A

% {-(a & b & c), a} is consistent
% {-(a & b & c), a,b} is consistent
% {-(a & b & c), a,b,c} is not consistent

% CN^2({a,b,c}) = {,...., a & b & c, ...}


% tree ({a,b,c},..., a&b&c) using CN (two times)


Note that deductive argumentation can capture n-ary conflicts. However, as discussed in~\cite{Yun2020SetsOA,yun2018}, it argued that the argumentation framework using \datalogPM, an instance of deductive argumentation, may generate a large number of arguments and attacks when using the definition of deductive arguments, as in~\cite{ARIOUA201776}. To address this problem, some redundant arguments are dropped, as discussed in~\cite{yun2018}, or arguments are re-defined as those in ASPIC+, as seen in~\cite{Yun2020SetsOA}. Then the attack relation must be redesigned to preserve all conflicts. In particular, n-ary attacks are allowed where arguments can jointly attack an argument. We will show this issue in the following example.  

%The proposed solution is to use collective attacks, as shown in the following example.

\begin{example}
Consider $\mK_2 = ( \mF_2, \mR_2, \mC_2)$ where
\begin{align*}
	\mR_2  = & \emptyset,\\
	\mC_2  = & \{ A(x) \land B(x) \land C(x) \rightarrow \bot \}, \\
    \mF_2 =  &\{A(a), B(a), C(a) \}.
   \end{align*} 
%
The deductive argumentation approach~\cite{ARIOUA201776} uses six arguments
%
\begin{align*}
& C_2: ( \{B(a) \}, B(a)), C_3: (\{ C(a) \}, C(a) ), C_4: ( \{A(a), B(a) \}, A(a) \land B(a) ), \\
& C_1: ( \{A(a)\}, A(a)), C_5: ( \{ A(a), C(a) \}, A(a) \land C(a)), C_6: ( \{B(a), C(a) \}, B(a) \land C(a))    
\end{align*}
%
to obtains the preferred extensions: $\{C_1, C_2, C_4\}$,
$\{C_1, C_3, C_5\}$, $\{C_2, C_3, C_6\}$.

In contrast, our approach uses three arguments $B_1 : \{ A(a)\} \Rightarrow A(a)$, $B_2 : \{ B(a)\} \Rightarrow B(a)$, $B_3 : \{ C(a)\} \Rightarrow C(a)$  with collective attacks, such as $\{B_1, B_2 \}$ attacks $B_3$, etc., to obtain extensions $\{B_1, B_2\}, \{B_1, B_3\}, \{B_2, B_3\}$.


%$\{B_1, B_3 \}$ attacks $B_2$, $\{B_2, B_3 \}$ attacks $B_1$.
\end{example}

\begin{remark}
\label{re:compare-attacks}
Similar to structured argumentation, such as deductive argumentation for propositional logic~\cite{BesnardH01}, DLs~\cite{ZhangL13}, \datalogPM~\cite{ARIOUA201776},
DeLP systems~\cite{Alejandro2014},  ASPIC systems~\cite{Prakken2002}
and sequent-based argumentation~\cite{HEYNINCK2020103,ArieliH24}, attacks in our framework are defined between individual arguments.
In contrast, in ABA systems~\cite{Dung2009,DimopoulosD0R0W24,Rapberger2024,Lehtonen2024}, attacks are defined between sets of assumptions.
However, in these ABA systems, the arguments generated from a set of assumptions are \emph{tree-derivations} (both notions are used interchangeably), which can be instantiated by Definition~\ref{def:ab-arg}, see above.
Thus, the attacks defined on assumptions are equivalent to the attacks defined on the level of arguments.
\end{remark}

\begin{remark}
    Note that the definition of collective attacks holds if we only consider ASPIC+ without preferences~\cite{ModgilP14}. We leave the case of preferences for future work.
\end{remark}

We introduce \emph{proof-oriented argumentation} (P-SAF) as an instantiation of SAFs~\cite{Nielsen2007}. Our framework is comparable to the one of~\cite{loanho_2024} in that both are applied to abstract logic. However, arguments in our setting differ from those in~\cite{loanho_2024} in that we represent arguments in the form of a tree.

\begin{definition} \label{def:ab-af} Let $ \mK$ be a KB, the corresponding \emph{proof-oriented (logical) argumentation (P-SAF)} $\mAF_{\mK}$ is the pair $(\Arg_{\mK}, \Att_{\mK})$ where $\Arg_{\mK}$ is the set of arguments induced from $ \mK$ and $\Att_{\mK}$ is the set of attacks.
\end{definition}

% \subsection{Proof-oriented argumentations (P-SAFs)}
% \label{subsec:p-saf-semantics}

In the next subsections, we show that the existing argumentation frameworks are instances of logic-associated argumentation frameworks.

\subsection{Translating the Existing Argumentation Frameworks to P-SAFs}
\label{subsec:relation-framework}

We have already shown that the existing frameworks (deductive argumentation~\cite{BesnardH01,ZhangL13,ARIOUA201776}, DeLP systems~\cite{Alejandro2014},  ASPIC systems~\cite{Prakken2002}, ASPIC+ without preferences~\cite{ModgilP14}, ABA systems~\cite{Dung2009,DimopoulosD0R0W24,Rapberger2024,Lehtonen2024}) can be seen as instances of our settings. Now we show how sequent-based argumentation~\cite{ArieliS19,BorgAS17} and contrapositive ABAs~\cite{HEYNINCK2020103,ArieliH24} fit in our framework.


%Some remarks on the relations between P-SAF frameworks and elsewhere in the literature.
\begin{itemize}



\item Sequent-based argumentation~\cite{ArieliS19}, using propositional logic, represents arguments as \emph{sequents}.
%(Here we use the term "s-arguments" to distinguish from arguments of our framework). 
The construction of arguments from simpler arguments is done by the inference rules of the \emph{sequent calculus}.
\emph{Attack rules} are represented as \emph{sequent elimination rules}. 
The ingredients of sequent-based argumentation may be simulated in our setting:

We start with a logic $(\mL_s, \cn_s)$. $\mL_s$ is a propositional language having a set of atomic formulas $\AT(\mL_s)$.  
If $\phi$ and $\alpha$ are formulas wrt.$\AT(\mL_s)$ then $\neg \phi$, $\phi \wedge \alpha$ are formulas wrt. $\AT(\mL_s)$. 
We assume that the implication $\supset$ and $\leftrightarrow$ are defined accordingly.
Propositional logic can be modelled by using sequents~\cite{ArieliS19}.
A sequent is a formula in the language $\mL_s$ of propositional logic enriched by the addition of a new symbol $\leadsto$.
We call such sequent the \emph{s-formula} of $\mL_s$ to avoid ambiguity.
In particular, for a formula $p \in \mL_s$ the \emph{axiom} $p \leadsto p$ are a s-formula in $\mL_s$. 
In general, for any set of formulas $\Psi \subseteq \mL_s$ and $\phi \in \mL_s$,  the sequents $\Psi \leadsto \phi$ are s-formulas of $\mL_s$. %For a s-formula $\Psi \leadsto \phi$, we call $\Psi$ the \emph{antecedent} and $\phi$ the \emph{consequent}.


%Note that, when $\mL$ has an implication connective $\supset$, we shall assume that it is deductive with respect to $\cn_s$.

Define $\cn_s$ as follows: 
For a set of formulas $X \subseteq \mL_s$, a formula $\phi \in \mL_s$ satisfies $\phi \in \cn_s(X)$ iff an inference rule
$\frac{\Psi_1 \leadsto \phi_1 \ldots \Psi_n \leadsto \phi_n}{\Psi \leadsto \phi}$, where the sequents $\Psi \leadsto \phi$ and $\Psi_i \leadsto \phi_i$ ($i = 1, \ldots, n$) are s-formulas of $\mL_s$, is applied to $X$ such that $\Psi_1, \ldots, \Psi_n$ are subsets of $X$.
We here consider the inference rules as \emph{structural rules} and \emph{logical rules} in~\cite{ArieliS19}.
Then we define $\cnb_s(X) = \bigcup_{n \geq 0}\cn_{s}^{n}(X)$.

%For $X \subseteq \AT(\mL_s)$, a formula $x \in \mL_s$ satisfies $x \in \cn_s(X)$ iff an inference rule
%$\frac{y}{x}$ is applied to $X$ such that $y \in X$. 


Let us define arguments in the sense of Definition~\ref{def:ab-arg}: For a set of formulas $H \subseteq \mL_s$, $H \Rightarrow \phi$ is an argument iff $\phi \in \cnb_s(H)$. In this case, the argument, from the premise $H$ to the conclusion $\phi$, can be described by a sequence of applications of inference rules.
Such sequence is naturally organized in the shape of a tree by $\cn_s$.  Each step up the tree corresponds to an application of an inference rule. The root of the tree is the final sequent (the conclusion), and the leaves are the axioms or initial sequents.

%Each node in the tree corresponds to a sequent, each step up the tree corresponds to an application of an inference rule. The root of the tree is the final sequent (the conclusion), and the leaves are the axioms or initial sequents.

We show how the attack rules can be described in terms of corresponding attack relations in Definition~\ref{def:ab-att}. The attack rule has the form of 
$\frac{\Psi_1 \leadsto \phi_1 , \ldots ,\Psi_n \leadsto \phi_n}{\Psi_n \not \leadsto \phi_n}$, in which
the first sequent in the attack rule’s prerequisites is the “attacking” sequent, the last sequent in the attack rule’s prerequisites is the “attacked” sequent, 
and the other prerequisites are the conditions for the attack. According to the discussion above, these sequents $\Psi_i \leadsto \phi_i$, ($i = 1, \ldots, n$), can be viewed as arguments $A_i : \Psi_i \Rightarrow \phi_i$ in the sense of Definition~\ref{def:ab-arg} where $\phi_i \in \cnb_s (\Psi_i)$. Then, in this view, the first sequent $\Psi_1 \leadsto \phi_1$ is the attacking argument $A_1$, the last sequent $\Psi_n \leadsto \phi_n$ is the attacked argument $A_n$, and the conclusions of the attack rule are the eliminations of the attacked arguments, meaning that $A_n$ is removed since $A_1$ attacks $A_n$ in the sense of Definition~\ref{def:ab-att}.


\begin{example} [Continue Example~\ref{ex:pro-logic}] Consider $\mK = \{x, x \supset y, \neg y \} \subseteq \mL_s$.
The following is an argument in propositional logic $A : \{x, x \supset y \} \Rightarrow  y$, $B : \{ \neg y \} \Rightarrow \neg y$. $A$ attacks $B$ since $\{ x, x \supset y, \neg y \}$ is inconsistent, i.e., $\cnb_s( \{ x, x \supset y, \neg y \}) = \mL_s$. Tree-representations of the arguments are shown in Figure~\ref{fig:propositional-DeLP-sequent}(Right), in which $[Mon]$ and $[\supset,\leadsto]$ are the names of inference rules.
\end{example}

\item  Contrapositive ABA ~\cite{HEYNINCK2020103,ArieliH24} may be based on propositional logic and \emph{strict} and \emph{candidate (defeasible) assumptions} consists of \emph{arbitrary} formulas in the language of that logic. Attacks are defined between sets of assumptions, i.e., defeasible assumptions may be attacked in the presence of a counter defeasible information.
Our P-SAF framework using logic $(\mL_{co}, \cn_{co})$ can simulate contrapositive ABAs as follows:
 
Assume that an implication connective $\supset$ is deductive (i.e., it is a $\vdash$-implication in contrapositive ABAs) and converting such implications $\supset$ (i.e., $\phi_1 \wedge \cdots \wedge \phi_n \supset \psi$) to rules of the form $\phi_1, \ldots, \phi_n \rightarrow \psi$ in $\mL_{co}$. Here we ignore the distinction between defeasible and strict rules.
With this assumption, the rules in $\mL_{co}$ can be treated as $\vdash$-\emph{implication}, i.e.,$\{ \phi_1, \ldots, \phi_n \rightarrow \psi \in \mL_{co} \mid \phi_1, \ldots, \phi_n \vdash \psi \}$; their contrapositions treated as $\vdash$-\emph{contrapositive}, i.e., $\{ \phi_1, \ldots, \phi_{i-1}, \neg \psi, \phi_{i+1}, \dots \phi_n \rightarrow \neg \phi_i \mid \phi_1, \ldots, \phi_{i-1}, \neg \psi, \phi_{i+1}, \dots \phi_n \vdash \neg \phi_i \}$ \footnote{ See definitions of $\vdash$-implication and $\vdash$-contrapositive in~~\cite{HEYNINCK2020103,ArieliH24}}.
This translation views the contrapositive ABA as a special case of the traditional definition of ABA~\cite{Dung2009}; also the traditional ABA can be simulated in our P-SAF using $(\mL_{co}, \cn_{co})$. Thus, the results and concepts of P-SAFs can apply to the contrapositive ABAs.
Indeed, first, $\mL_{co}$ includes the strict and candidate assumptions
~\footnote{We abuse the term “strict and candidate assumptions” and refer them as "literals".}
and the set of rules.
These rules as reasoning patterns are used in $\cn_{co}$ as defined in Definition~\ref{def:cn-contrapositive}.
Second, by Definition~\ref{def:ab-arg}, for $H \subseteq \mL_{co}$ be a set of assumptions and $\phi \in \mL_{co}$ , $H \Rightarrow \phi$ is an argument iff $\phi \in \cnb_{co}(H)$. Third, the attacks defined on assumptions in traditional ABA are equivalent to those in our S-PAFs (see Remark~\ref{re:compare-attacks} for further explanation).

Note that contrapositive ABAs in~\cite{ArieliH24} (with collective attacks) are analogous to those in~\cite{HEYNINCK2020103}, except they drop the requirement that any set of candidate assumptions contributing to the attacks must be \emph{close}. Similarly, our P-SAF framework, which uses $\cnb_{co}$ in the definition of inconsistency for our attacks,
does not impose this additional requirement.
\end{itemize}
%\end{remark}




\subsection{Acceptability of P-SAFs and Relations to Reasoning with MSCs}

Semantics of P-SAFs are now defined as in the definition of semantics for SAFs~\cite{Nielsen2007}. These semantics consist of \textit{admissible}, \textit{complete}, \textit{stable}, \textit{preferred} and \textit{grounded semantics}. 

Given a P-SAF $\mAF_{\mK} = (\Arg_{\mK}, \Att_{\mK})$ and $\mS\subseteq \Arg_{\mK}$. $\mS$ \emph{attacks} $\mX$ iff $ \exists A \in \mX$ s.t. $\mS$ attacks $A$.  $\mS$ \emph{defends} $A$ if for each $\mX \subseteq \Arg_{\mK}$ s.t. $\mX$ attacks $A$, some $\mS^{\prime} \subseteq \mS$ attacks $\mX$. An \textit{extension} $\mS$ is called

\begin{itemize}

    \item \emph{conflict-free} if it does not attack itself;

    \item \emph{admissible} $(\adm)$ if it is conflict-free and defends itself.

    \item \emph{complete} $(\cmp)$  if it is  admissible containing all arguments  it defends.

    \item \emph{preferred} $(\prf)$ if it is an inclusion-maximal admissible extension. %(w.r.t. set inclusion) admissible extension.

    \item \emph{stable} $(\stb)$ if it is conflict-free and attacks every argument not in it.

    \item \emph{grounded} $(\grd)$ if it is an inclusion-minimal complete extension.% (w.r.t. set inclusion) complete extension.
    
\end{itemize}
Note that this implies that each grounded or preferred extension of a P-SAF is an admissible one, the grounded extension is contained in all other extensions.

Let $\Exts_{\sem}( \mAF_{\mK})$ denote \emph{the set of all extensions} of $ \mAF_{\mK}$ under the semantics $\sem \in \{\adm,\ \stb,\ \prf,\ \grd \}$.
Let us define \emph{acceptability} in P-SAFs.
\begin{definition}
  \label{def:accept}
  Let $\mAF_{\mK}$ be the corresponding P-SAF of a KB $\mK$ and $\sem \in \{\adm, \stb, \prf \}$. A formula $\phi \in \mL$ is 
   \begin{itemize}

    \item \emph{credulously} accepted under $\sem$ iff for some~$\mE \in \Exts_{\sem}( \mAF_{\mK})$, $\phi \in \Cons(\mE)$.
    

    \item \emph{groundedly} accepted under $\grd$ iff for some $\mE \in \Exts_{\grd}( \mAF_{\mK})$, $\phi \in \Cons(\mE)$.

    \item \emph{sceptically} accepted under $\sem$ iff for all $\mE \in \Exts_{\sem}( \mAF_{\mK})$, $\phi \in \Cons(\mE)$.
  \end{itemize}
  \end{definition}

Next, we show the relation to reasoning with maximal consistent subsets in inconsistent KBs.
Proposition~\ref{pro:psaf-link} shows a relation between extensions of P-SAFs and MSCs of KBs.

\begin{proposition}
\label{pro:psaf-link}
 Let $\mAF_{\mK}$ be the corresponding P-SAF of a KB $\mK$. Then,

 \begin{itemize}
     \item the maximal consistent subset of $ \mK$ coincides with the stable/ preferred extension of $\mAF_{\mK}$;

     \item the intersection of the maximal consistent subsets of $ \mK$ coincides with the grounded extension of $\mAF_{\mK}$.
 \end{itemize}
\end{proposition}
\begin{proof} %We sketch the proof of the first statement. 
The idea of the proof is to show that every preferred extension is the set of arguments generated from a MCS, that every such set of arguments is a stable extension, and that every stable extension is preferred.
%
The proof of the second statement follows the lemma saying that if there are no rejected arguments under preferred semantics, then the grounded extension is equal to the intersection of all preferred extensions. By the proof of the first statement, every preferred extension is a maximal consistent subset. Thus the second statement is proved.
\end{proof}
\begin{remark}
In general, the grounded extension is contained in the intersection of all maximal consistent subsets.
\end{remark}
The main result of this section, Theorem \ref{thm:ab-link}, which follows from Proposition \ref{pro:psaf-link} generalises results from previous works. % Because of this similarity, they are not included in the appendix.

\begin{theorem}
\label{thm:ab-link}
Let $\mAF_{\mK}$ be the corresponding P-SAF of a KB $\mK$, $\phi \in \mL$ a formula and $\sem \in \{\adm, \stb, \prf \}$. Then, $\phi$ is entailed in
\begin{itemize}
    \item some maximal consistent subset iff $\phi$ is \emph{credulously accepted} under $\sem$.
       
    \item all maximal consistent subsets iff $\phi$ is \emph{sceptically accepted} under $\sem$.
    
    \item the intersection of all maximal consistent subsets iff $\phi$ is \emph{groundedly accepted} under $\grd$.
   
\end{itemize}
\end{theorem}
%\begin{proof} [Sketch] The proof of this theorem is proved by Proposition~\ref{pro:psaf-link}.
%\end{proof}





To argue the quality of P-SAF, it can be shown that it satisfies the rationality postulates introduced in~~\cite{DAgostinoM18,AmgoudB13}. 

\begin{definition}
Let $\mAF_{\mK}$ be the corresponding P-SAF of a KB $\mK$. Wrt. $\sem \in \{\adm, \stb, \prf, \grd\}$, $\mAF_{\mK}$ is 
    \begin{enumerate} 
	\item \emph{closed under $\cnb$} iff for all $\mE \in \Exts_{\sem}(\mAF_{\mK})$, $\Cons(\mE) = \cnb(\Cons(\mE))$;
	\item \emph{consistent} iff for all $\mE \in \Exts_{\sem}(\mAF_{\mK})$, $\Cons(\mE)$ is consistent;
    \end{enumerate}
\end{definition}

 \begin{proposition}
 \label{pro:postulate} Wrt. to any semantics in $\{\adm ,\stb$, $\prf,\grd\}$, $\mAF_{\mK}$ satisfies consistency, closure.
\end{proposition}
The proof of Proposition~\ref{pro:postulate} is analogous to those of Proposition 2 in~\cite{loanho_2024}. Because of this similarity, they are not included in the appendix.


\begin{example} [Continue Example~\ref{ex:motivation}]
\label{ex:KB-arg}
Recall $\mK_1$. Table~\ref{tab:arg} shows the supports and conclusions of all arguments induced from $\mK$. 
%
The corresponding P-SAF admits $\stb$ ($\prf$) extensions:
$\Exts_{\stb / \prf}(\mAF_1) = \{\mE_1, \ldots, \mE_6\}$, where
%
$\mE_1 = \Args(\{ \teAs(\vi,\kd), \uc(\kd)\})$ \footnote{Fix $\mF^{\prime} \subseteq \mF$, $\Args(\mF^{\prime})$ is the set of \emph{arguments generated by} $\mF^{\prime}$} $ = \{A_5, A_6, A_2\}$,
%
and $\mE_2, \ldots, \mE_6$ are obtained in an analogous way. It can be seen that the extensions correspond to the repairs of the KBs (by Theorem~\ref{thm:ab-link}). 

Reconsider $q_1 = \rese(\vi)$. We have that $q_1$ is credulously accepted under $\stb$ ($\prf$) extensions. In other words, $\vi$ is a \emph{possible answer} for $q_1$.  
\end{example}

\begin{table}\vspace{-6mm} 
\centering
  \caption{Supports and conclusions of arguments}
  \begin{tabular}{|c|l|l|}
    \hline
    \textbf{Argument} & \textbf{$\Sup(A_i)$} & \textbf{$\Con(A_i)$} \\
    \hline
   $A_0$ & $\{\te(\vi, \kr)\}$ & $\te(\vi, \kr)$ \\
   $A_9$ & $\{\gc(\kr)\}$ & $\gc(\kr)$ \\
   $A_7$ & $\{ \gc(\kr), \te(\vi, \kr) \}$ & $\fp(\vi)$ \\
   $A_1$ & $\{ \gc(\kr), \te(\vi, \kr) \}$ & $\rese(\vi)$\\
   $A_4$ & $\{\te(\vi, \kd)\}$ & $\te(\vi, \kd)$ \\
   $A_5$ & $\{\teAs(\vi, \kd)\}$ & $\teAs(\vi, \kd)$\\
   $A_6$ & $\{ \uc(\kd) \}$ & $\uc(\kd)$\\
   $A_2$ & $\{ \teAs(\vi, \kd),\ \uc(\kd) \}$ & $\ta(\vi)$\\
   $A_3$ & $\{\te(\vi, \kd)\}$ & $\lect(\vi)$ \\
   $A_{8}$ & $\{\te(\vi, \kr)\}$ & $\lect(\vi)$ \\
   $A_{10}$ & $\{\te(\vi, \kr)\}$ & $\emp(\vi)$ \\
   $A_{11}$ & $\{\te(\vi, \kd)\}$ & $\emp(\vi)$ \\
   $A_{12}$ & $\{ \gc(\kr), \te(\vi, \kr)\}$ & $\emp(\vi)$ \\
    \hline
  \end{tabular}
  \label{tab:arg} 
\end{table}   

In this section, we have translated from KBs into P-SAFs. Consequently, the acceptance of a formula $\phi$ of $\mL$ corresponds to the acceptance of a set of arguments $\mA$ for $\phi$. When we say "a set of arguments $\mA$ for $\phi$", it means simply that for each argument in $\mA$, its consequence is $\phi$.
We next introduce a novel notion of \textit{explanatory dialogue} ("\emph{dialogue}" for short) viewed as a \emph{dialectical proof procedure} in Section~\ref{sec:model-exp-dia}. Section 5 will show how to use a dialogue model to determine and explain the acceptance of $\phi$ wrt argumentation semantics.



