\section{Lessons Learned}
\label{Section:lesson}


\begin{figure*}[htbp]
\centering 
%\includegraphics[width=8cm,height=13cm,keepaspectratio]{Images/MSR-Example-v3.png}
%\includegraphics[width=16cm,height=8cm,keepaspectratio]{Images/MSR-Example-v3.png}
\includegraphics[width=1.2\textwidth]{Images/Example-type1.pdf}
%\vspace{-.5cm}
\caption{\textcolor{black}{Example of selected Type-1 code clone from kafka project.}} %\cite{kafka-type1}
\label{fig:example-casestudies-type1}
%\vspace{-.4cm}
\end{figure*}

 \begin{figure*}[htbp]
\centering 
% %\includegraphics[width=8cm,height=13cm,keepaspectratio]{Images/MSR-Example-v3.png}
% %\includegraphics[width=16cm,height=8cm,keepaspectratio]{Images/MSR-Example-v3.png}
 \includegraphics[width=1.2\textwidth]{Images/Example-type2.pdf}
% %\vspace{-.5cm}
 \caption{\textcolor{black}{Example of selected Type-2 code clone from cayenne project.}} %\cite{cayenne}
 \label{fig:example-casestudies-type2}
%\vspace{-.4cm}
\end{figure*}

\begin{figure*}[htbp]
\centering 
%\includegraphics[width=8cm,height=13cm,keepaspectratio]{Images/MSR-Example-v3.png}
%\includegraphics[width=16cm,height=8cm,keepaspectratio]{Images/MSR-Example-v3.png}
\includegraphics[width=1.3\textwidth]{Images/Example-type3.pdf}
%\vspace{-.5cm}
\caption{\textcolor{black}{Example of selected Type-3 code clone from pig project.}} %\cite{pig}
\label{fig:example-casestudies-type3}
%\vspace{-.4cm}
\end{figure*}

\noindent{\textbf{ \textcolor{black}{Lesson 1: Code clones associated with commits about duplicate removal are from different clone types.}}}  \textcolor{black}{There are various types of code clone exist in the literature (\ie Type-1, Type-2, Type-3, and Type-4) \citep{mondal2020survey}. When performing manual examination of commits associated with code clones, we realized that some commits with the explicit intention of removing duplication are associated with different clone types. Furthermore, in some commits associated with duplicate removal, developers can combine clone refactoring with other unrelated changes, such as feature updates, bug fixes, or general code cleanup. This observation is consistent with existing studies that show that developers interleave refactoring with other changes, and 11– 39\% of bug fixing commits include other changes \cite{silva2016we,alomar2021we,murphy2012we,nguyen2013filtering}.}



%As shown in previous studies (\eg \citep{pantiuchina2018improving,alomar2019impact}), this tangling can make it difficult to attribute the impact to a specific code change alone precisely. }

\noindent{\textbf{ \textcolor{black}{Lesson 2: Refactoring different types of clones can have different variations on metric values.}}}  \textcolor{black}{As illustrated in \textcolor{black}{Tables \ref{Table:Quality Metrics in Related Work} and \ref{Table:Quality Metrics in Related Work-v2}}, there have been two decades' worth of work on the relationship between refactoring and code quality. We can see that there is room for empirical investigation of the impact of clone removal refactorings on internal quality metrics. In this study, we observe that the impact of refactoring clones on software quality metrics can vary based on the type of clone being refactored. Moreover, developers may have various mechanisms that contribute to removing duplicates, and these strategies may dictate different variations on the metrics. However, locating refactored clone types for each instance presents multiple challenges: (1) a single commit can address multiple clone types simultaneously, making it difficult to attribute metric variations to a specific clone type;  (2) some clone types may occur less frequently in the dataset, further complicating efforts to draw conclusions regarding the influence of clone types on metric variations; and (3) manually determining clone types for each instance is time-consuming and prone to error, particularly when dealing with a large dataset. Although existing clone detection tools can detect the clone, they require additional configuration and setup by the users. In the following, we show an example of each type of clone and its refactoring:}
%However, it is challenging and time-consuming to determine the types of clones and manually refactor them. Although existing clone detection tools can detect the clone, they require additional configuration and setup by the users, which might make them reluctant to perform refactoring suggestions afterwords.}
\begin{itemize}
    \item \textcolor{black}{\textit{Type-1 code clone.} Figure \ref{fig:example-casestudies-type1} illustrates a Type-1 clone that has been refactored. The example demonstrates two duplicate instances, which represent a Type-1 clone (\ie identical code fragments). An `Extract Method' refactoring was applied, resulting in the extraction of the method \texttt{putNodeGroup\break Name(nodeName String, nodeGroupId int, nodeGroups Map, rootTo\break NodeGroup Map)} from \texttt{makeNodeGroups()} in the \texttt{InternalTopologyBuilder} class. For the complexity metrics, we observed varied behavior: CC remained unchanged, some metrics showed improvement (NL, NLE, HEFF, HPL, and HTRP), while others did not improve (HCPL, HDIF, HNDB, HPV, HVOL, MIMS, MI, MISEI, and MISM). Regarding the size metrics, none showed improvement. For coupling metrics, NII improved, whereas NOI did not.} %Extract Method private putNodeGroupName(nodeName String, nodeGroupId int, nodeGroups Map, rootToNodeGroup Map) : int extracted from private makeNodeGroups() : Map in class org.apache.kafka.streams.processor.internals.InternalTopologyBuilder
    \item \textcolor{black}{\textit{Type-2 code clone.} Figure \ref{fig:example-casestudies-type2} depicts a Type-2 clone that has been refactored. This example highlights two duplicate instances, categorized as a Type-2 clone (\ie syntactically identical fragments). The method \texttt{entitiesForCurrentMode()} was extracted from \texttt{generateClassPairs\_1\_1\break (classTemplate String, superTemplate String, superPrefix String)} in the \texttt{MapClassGenerator} class using the `Extract Method' refactoring operation. The complexity metrics have shown improvement, while the design size metrics have also improved, with the exception of CLOC. For coupling metrics, NOI has improved, whereas NII has not.}
    %Extract Method private entitiesForCurrentMode() : Collection extracted from private generateClassPairs_1_1(classTemplate String, superTemplate String, superPrefix String) : void in class org.apache.cayenne.gen.MapClassGenerator
    \item \textcolor{black}{\textit{Type-3 code clone.} Figure \ref{fig:example-casestudies-type3} shows a Type-3 clone that has been refactored. The example illustrates two duplicate instances, identified as a Type-3 clone (\ie copied fragments with further modifications such as changed, added, or removed statements). Through the `Extract Method' refactoring, the method \texttt{runSimpleScript(String name, String[] script)}  was extracted in the \texttt{TestScriptLanguage} class. The complexity metrics have improved overall, with the exception of HDIF, which has decreased, while NL and NLE remain unchanged. Size metrics have also improved, except for CLOC. For coupling metrics, NOI has improved, but NII has decreased. }
    %Extract Method private runPigRunner(name String, script String[]) : PigStats extracted from public pigRunnerTest() : void in class org.apache.pig.test.TestScriptLanguage
\end{itemize}








\noindent{\textbf{ \textcolor{black}{Lesson 3: Some state-of-the-art metrics can capture the developer’s intention of removing code duplication with different degrees of improvement and degradation of software quality.}}} \textcolor{black}{When removing code duplication, developers often perform `Extract Method' refactoring with the expectation of improving code quality. Yet, the state-of-the-art metrics may reflect varying levels of improvement or even degradation following these refactoring events.  For example, in Figure \ref{fig:example-casestudies-2}, we demonstrate the code snippet depicting the instances of code duplication before and after refactoring. We can see that refactoring mining tools detect `Extract Method' refactoring from project commoms-bcel\footnote{\textcolor{black}{\url{https://github.com/apache/commons-bcel/commit/67dfdf60f5f8ccb8ed910bfe9d1cdc6e84f0db36}}}  to extract \texttt{createAnnotationEntries} from \texttt{getAnnotationEntries}. This example emphasizes how refactoring can have mixed effects, positively influencing some metrics while negatively impacting others. As can be seen, its coupling metrics (NII and NOI) have been improved. However, its complexity metrics (CC, NL, NLE, HCPL, HDIF, HEFF, HNDB, HPL, HPV, HTRP, HVOL, MIMS, MI, MISEI, and MISM) and size metrics (LOC, TLOC, LLOC, TLLOC, CLOC, NOS, and TNOS) have not been improved. For metrics where the metrics do not capture the developer's intention, several possible explanations can be consideblack: }
\begin{itemize}
    \item \textcolor{black}{\textit{Inadequacy of the metrics for certain scenarios.} The metrics used to assess software quality, may not always be the most suitable for reflecting the specific intention behind a refactoring. For instance, a developer may intend to improve readability or maintainability, but standard structural metrics may not effectively quantify these aspects. This misalignment between developer goals and the measublack outcomes can lead to discrepancies in how the impact of refactoring is perceived.}
    \item \textcolor{black}{\textit{Limitations of the metrics.} The state-of-the-art metrics have inherent limitations and may not comprehensively capture the effects of refactoring. For example, metrics such as CC focus on the control flow but may overlook improvements in code modularity. This indicates a need to either refine existing metrics or introduce new ones that better align with developer goals, particularly in cases of complex refactoring.}
    \item \textcolor{black}{\textit{Deviation from developer intentions.} In some cases, developers' intentions, as stated in commit messages, may not align with the actual changes performed in the codebase. This could happen for various reasons. For example, a commit message may report the removal of duplicate code, but the implementation might only partially address the duplication or introduce new dependencies, resulting in no measurable improvement or even metric degradation.}
\end{itemize}

\begin{figure*}[htbp]
\centering 
%\includegraphics[width=8cm,height=13cm,keepaspectratio]{Images/MSR-Example-v3.png}
%\includegraphics[width=16cm,height=8cm,keepaspectratio]{Images/MSR-Example-v3.png}
\includegraphics[width=1.2\textwidth]{Images/Example2.pdf}
%\vspace{-.5cm}
%\captionsetup{justification=raggedright,singlelinecheck=false}  % Left-aligns caption

% \caption{\textcolor{black}{Example of selected commit message from commons-bcel project\textsuperscript{\ref{fig:example-casestudies-2}}.}}
 \caption{\textcolor{black}{Example of selected commit message from commons-bcel project.}}
 \label{fig:example-casestudies-2}
\end{figure*}

%https://github.com/apache/commons-bcel/commit/67dfdf60f5f8ccb8ed910bfe9d1cdc6e84f0db36
% \label{fig:example-casestudies-2}
% %\end{figure*}
% \footnotetext[\value{footnote}]{\label{fig:example-casestudies-2}\url{https://github.com/apache/commons-bcel/commit/67dfdf60f5f8ccb8ed910bfe9d1cdc6e84f0db36}.}



%\vspace{-.4cm}
%\end{figure*}
%\footnotetext{\url{https://github.com/apache/commons-bcel/commit/67dfdf60f5f8ccb8ed910bfe9d1cdc6e84f0db36}.} 
% \caption{\textcolor{black}{Example of selected commit message from commons-bcel project\footnotetext{\url{https://github.com/apache/commons-bcel/commit/67dfdf60f5f8ccb8ed910bfe9d1cdc6e84f0db36}.}}}
%%%% just an example %%%%
% \begin{figure}[h]
%     \centering
%     \includegraphics[width=0.7\textwidth]{example-image}  % Replace with actual image
%     \caption{\textcolor{black}{Example of selected commit message from commons-bcel project\textsuperscript{*}.}}
%     \label{fig:commit-example}
% \end{figure}

% \begin{center}
%     \footnotesize\textsuperscript{*}\url{https://github.com/apache/commons-bcel/commit/67dfdf60f5f8ccb8ed910bfe9d1cdc6e84f0db36}
% \end{center}


%For the cases that metrics  do not capture the intention of developer, it might be because these metrics are not the best metrics to consider on these cases, limitation of the metrics itself, or developers did not follow their intention reported in the commit messages.

%This is a thorough empirical investigation of a long standing question within the refactoring community: does refactoring improve code quality?

%There has been two decades worth of work on the relationship between refactoring and code quality but it has been nicely summarized herein. The authors indeed illustrate that there is room for an empirical investigation of the impact of clone removal refactorings on internal product metrics.

%If LCOM increases it may be correlated with removal of duplicated code but it will also be correlated with lots of other manipulations of code. And if NOC decreases it may be a symptom of clone removal but can just as well be a symptom of other code manipulations.

%One of the strengths is that the author shows anecdotal evidence (both positive and negative) of impact clone removing refactorings have on quality metrics. However, almost all positive anecdotal evidence stems from refactoring JUnit4TestCheckerTest. It has been shown that test code is sufficiently different from normal code with respect to clones. (cfr. Brent van Bladel and Serge Demeyer. A comparative study of test code clones and production code clones. Journal of Systems and Software, 176:110940