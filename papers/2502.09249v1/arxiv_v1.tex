%TEST
\documentclass[english,11pt,a4paper]{article}
\usepackage[english]{babel}
\usepackage{latexsym,amssymb,amsmath,amsfonts,amscd,epsfig,amsthm,color,mathrsfs, mathtools}
\usepackage{graphicx}
\usepackage{float}
\usepackage[left=2.3cm,right=2.3cm,top=2.3cm,bottom=2.3cm]{geometry}
\usepackage{ifthen}
\usepackage{authblk}
\usepackage{colonequals}
\usepackage{array}
\usepackage{tikz}

\usetikzlibrary{quantikz2, positioning}

\usepackage{belov_main}
\usepackage{belov_paper}
%\usepackage[draft]{belov_fancy}


\usepackage[framemethod=TikZ]{mdframed}
\usepackage{chngcntr}

\newmdenv[%
  roundcorner=5pt,
  linecolor=blue!15,
  linewidth=2pt,
  subtitlebackgroundcolor=blue!15,
  subtitleaboveskip=0pt,
  subtitlebelowskip=0pt,
  subtitleinneraboveskip=0pt,
  innerbottommargin=0pt,
  subtitlefont=\normalfont
]{mdfigure}

\counterwithin{figure}{section}
\def\myfigureInternal#1#2#3{
\refstepcounter{figure} #1
\begin{mdfigure}[
  frametitle={
    \tikz[baseline=(current bounding box.east),outer sep=0pt]
    \node[anchor=east,rectangle,fill=blue!15,rounded corners]
    {Figure~\thefigure};},
  frametitleaboveskip=-10pt
  innertopmargin=0pt,
  innerbottommargin=0pt,
  roundcorner=5pt,
  linecolor=blue!15,
  linewidth=2pt,
  subtitlebackgroundcolor=blue!15,
  subtitleaboveskip=0pt,
  subtitlebelowskip=0pt,
  subtitleinneraboveskip=0pt,
  subtitlefont=\normalfont
]
#3
\mdfsubtitle{\medskip #2}
\end{mdfigure}
}

\def\myfigure#1#2#3{
\begin{figure}[tbh]
\myfigureInternal{#1}{#2}{#3}
\negbigskip
\end{figure}
}




\counterwithin{table}{section}
\def\mytableInternal#1#2#3{
\refstepcounter{table} #1
\begin{mdfigure}[
  frametitle={
    \tikz[baseline=(current bounding box.east),outer sep=0pt]
    \node[anchor=east,rectangle,fill=blue!15,rounded corners]
    {Table~\thetable};},
  frametitleaboveskip=-10pt
  innertopmargin=0pt,
  innerbottommargin=0pt,
  roundcorner=5pt,
  linecolor=blue!15,
  linewidth=2pt,
  subtitlebackgroundcolor=blue!15,
  subtitleaboveskip=0pt,
  subtitlebelowskip=0pt,
  subtitleinneraboveskip=0pt,
  subtitlefont=\normalfont
]
{
#3
}
\mdfsubtitle{\medskip #2}
\end{mdfigure}
}

\def\mytable#1#2#3{
\begin{table}[tbh]
\mytableInternal{#1}{#2}{#3}
\end{table}
}





\newcommand{\OO}{\mathcal{O}}
\newcommand{\tOO}{\widetilde{\OO}}


\usepackage{mathabx}
\newcommand{\maps}[1]{\;\stackrel{#1}{\longmapsto}\;}
\newcommand{\transduce}[1]{\stackrel{#1}{\rightsquigarrow}}
\newcommand{\DownTransduce}{\scalebox{0.7}{\rotatebox[origin=c]{270}{$\rightsquigarrow$}}}

\usepackage{authblk}

\title{Space-Efficient Quantum Error Reduction without log Factors}
\author[*]{Aleksandrs Belovs}
\author[$\dagger$]{Stacey Jeffery}
\affil[*]{Center for Quantum Computing Science, Faculty of Science and Technology, University of Latvia}
\affil[$\dagger$]{QuSoft, CWI \& University of Amsterdam, the Netherlands}
\date{}

\newcommand{\AB}[1]{{\color{blue}(AB: #1)}}
\newcommand{\SJ}[1]{{\color{red}{[{\bf SJ:} #1]}}}

\newboolean{ElectronicVersion}
\setboolean{ElectronicVersion}{true}

%\ifthenelse{\boolean{ElectronicVersion}}{
%    \usepackage[letterpaper=true,pdftex,bookmarks,pagebackref,
%	plainpages=false, % Needed if Roman numbers in frontpages
%        pdfpagelabels=true % Adds page number as label in Acrobat's page count 
%        ]{hyperref}}{}

\usepackage{hyperref}[backref]
\hypersetup{
    bookmarksnumbered=true, % If Acrobat bookmarks are requested, include section numbers
    unicode=false, % non-Latin characters in Acrobat's bookmarks
    pdfstartview={FitH}, % fits the width of the page to the window
    pdftitle={Effective Quantum Error Reduction}, % title
    pdfauthor={Aleksandrs Belovs and Stacey Jeffery}, % author
    pdfsubject={}, % subject of the document
    pdfcreator={}, % creator of the document
    pdfproducer={}, % producer of the document
    pdfkeywords={}, % list of keywords
    pdfnewwindow=true, % links in new window
    colorlinks=true, % false: boxed links; true: colored links
    linkcolor=blue, % color of internal links
    citecolor=blue, % color of links to bibliography
    filecolor=blue, % color of file links
    urlcolor=blue % color of external links
}



\begin{document}

\maketitle




\begin{abstract}
    Given an algorithm that outputs the correct answer with bounded error, say $1/3$, it is sometimes desirable to reduce this error to some arbitrarily small $\eps$ -- for example, if one wants to call the algorithm many times as a subroutine. The usual method, for both quantum and randomized algorithms, is a procedure called majority voting, which incurs a multiplicative overhead of $\OO(\log\frac{1}{\eps})$ from calling the algorithm this many times. 

    A recent paper [Quantum 2024] introduced a model of quantum computation called \emph{transducers}, and showed how to reduce the ``error'' of a transducer arbitrarily with only constant overhead, using a construction analogous to majority voting called \emph{purification}. 
    Even error-free transducers map to bounded-error quantum algorithms, so this does not let you reduce algorithmic error for free, but it does allow bounded-error quantum algorithms to be composed without incurring log factors.

In this paper, we present a new highly simplified construction of a purifier, that can be understood as a weighted walk on a line similar to a random walk interpretation of majority voting.
In addition to providing a new perspective that is easier to contrast with majority voting, our purifier has exponentially better space complexity than the previous one, and quadratically better dependence on the soundness-completeness gap of the algorithm being purified. Our new purifier has nearly optimal query complexity, even down to the constant, which matters when one composes quantum algorithms to super-constant depth.

Purifiers can be seen as a way of turning a ``Monte Carlo'' quantum algorithm into a ``Las Vegas'' quantum algorithm -- a process for which there is no classical analogue -- leading to phenomena like the above-mentioned composition of bounded-error quantum algorithms without log factors. Conceptually, our simplified construction sheds light on this strange quantum phenomenon, and, more practically, could have implications for the time and space complexity of composed quantum algorithms.

\end{abstract}


\section{Introduction}

Error reduction
is one of the most fundamental algorithmic primitives in both the randomized and quantum settings.
It transforms a program that evaluates a function $f$ with bounded error, say $1/3$, into a program that evaluates the same function with much smaller error $\eps$.
In both the quantum and randomized cases, the conventional procedure is based on majority voting.


If we want to reduce the error of a complete quantum algorithm that ends with a measurement outputting a classical string, then we can treat it as a randomized process and apply majority voting just as we would in a randomized algorithm: execute the quantum algorithm together with the final measurement a number of times, and output the majority%
\footnote{As in the case of randomized algorithms, this only works if there is some string that occurs with higher probability than all other strings, which is the case in bounded-error algorithms computing some function, but not those computing relations, where there may be many possible correct answers. 
}.
Somewhat more interesting is error reduction of a \emph{coherent} quantum subroutine. 
If the subroutine is executed several times, such as when it is employed as an input oracle for another quantum algorithm, then its error must be driven down in order to keep the total error of the whole algorithm sufficiently small.%
\footnote{If the best upper bound we can prove on an algorithm's error probability is 1, the algorithm is widely considered to be useless.}
As quantum subroutines may be called in superposition, the error-reduced subroutine cannot use measurements, but must instead be a coherent subroutine. 
In the binary case, the subroutine can be seen as an input oracle $O$ performing the transformation
\begin{equation}
\label{eqn:InputOracle}
O\colon \ket A|0>\ket W|0> \longmapsto \ket A\reg W |\phi> = \sqrt{1-p} \ket A |0> \ket W|\phi_0> + \sqrt{p} \ket A|1>\ket W|\phi_1>,
\end{equation}
where the first register $\reg A$ is the output qubit (answer register), and the second register $\reg W$ contains some internal state of the subroutine (workspace), and both states $\phi_0$ and $\phi_1$ are normalised.
The error reduction procedure $R$, given this input oracle, must perform the transformation
\begin{equation}
\label{eqn:ErrorReduction}
R(O)\colon \ket A|0> \longmapsto
\begin{cases}
\ket A|0>, &\text{if $p\le \tfrac 12 - \delta$;}\\
\ket A|1>, &\text{if $p\ge \tfrac 12 + \delta$;}
\end{cases}
\end{equation}
with sufficiently high accuracy.
Here $2 \delta > 0$ is the gap between the accepting and the rejecting probabilities of the subroutine $O$ -- that is, the error of the subroutine is $1/2-\delta$.
The space complexity of the subroutine is the number of qubits used by $\cA$ and $\cW$.%
\footnote{
Here we are not counting what we might call the \emph{scratch space} of the subroutine: qubits that the subroutine uses but returns to the state $\ket |0>$ afterwards.
}


In the following, we briefly discuss previous approaches to this problem, starting with folklore majority voting. 

\begin{thm}[Quantum Majority Voting, folklore]
\label{thm:majorityVoting}
Let $\eps, \delta>0$ be parameters.
Quantum majority voting $\eps$-approximately performs the transformation~\rf{eqn:ErrorReduction} for any input oracle of the form~\rf{eqn:InputOracle}.
It executes the input oracle $O$ and its inverse $O^*$ each $\ell = O\sA[\frac1{\delta^2}\log \frac 1\eps]$ times.
Its space complexity is $\ell s + \OO(\log \ell)$, where $s$ is the space complexity of $O$.
Besides executions of $O$ and $O^*$, it uses $\OO(\ell\log \ell)$ other 1- or 2-qubit operations.
\end{thm}

One difference between the classical and quantum case, is that we cannot naively reuse the space used by the subroutine in the quantum case, but must instead make $\ell$ copies of the whole state $\ket{A\reg W}|\phi>$ (in contrast to classical majority voting, which can just keep track of how many 1s have been seen so far).
This gives the $\ell s$ term in the space complexity of \rf{thm:majorityVoting}.
Let us give a short proof in order to demonstrate this.

\begin{proof}
Let us assume for concreteness that $\ell$ is a power of 2.
The input oracle $O$ is executed $\ell$ times, each time on a new pair of registers $\reg A_i$, $\reg W_i$.
This gives a state of the form
\[
\sum_{b\in \bool^\ell} (1-p)^{\frac{\ell-|b|}2}p^{\frac{|b|}2} \ket A_1 |b_1>\cdots \ket A_\ell |b_\ell> \ket W_1 |\phi_{b_1}> \dots \ket W_\ell |\phi_{b_\ell}>,
\]
where $|b|$ is the Hamming weight of $b$.
Evaluation of the sum of the bits $b_1,\dots,b_\ell$ into a new register $\reg R$ gives the state 
\[
\sum_{b\in \bool^\ell} (1-p)^{\frac{\ell-|b|}2}p^{\frac{|b|}2} \ket A_1 |b_1>\cdots \ket A_\ell |b_\ell> \ket W_1 |\phi_{b_1}> \dots \ket W_\ell |\phi_{b_\ell}> \ketA R||b|>.
\]
By Hoeffding's inequality, the most significant qubit of $\cR$ contains 0 if $p\le 1/2-\delta$ and 1 if $p\ge 1/2+\delta$, except with small enough error probability.
We copy the most significant qubit of $\reg R$ into the output register $\reg A$, 
and run the whole computation in reverse.
\end{proof}

\mycutecommand{\Oref}{O_{\mathrm{ref}}}
Another approach uses quantum amplitude estimation.
For this primitive, it is sufficient to use a less powerful reflecting oracle:
\begin{equation}
\label{eqn:Oref}
\Oref = O \mathrm{Ref_{\ket|0>\ket|0>}} O^*,
\end{equation}
where $\mathrm{Ref}_{\ket|0>\ket|0>}$ is the reflection about the state $\ket A|0>\ket W|0>$ in $\reg A\otimes \reg W$.
In other words, $\Oref$ reflects about the state $\ket{}|\phi>$ in $\reg A\otimes \reg W$.
It is easy to implement $\Oref$ using two oracle calls and $s+\OO(1)$ additional operations.
The latter are usually majorized by the time complexity of implementing $O$, as a subroutine using $s$ qubits will generally have time complexity at least $s$.
On the other hand, implementing $O$ using $\Oref$ is complicated. (See~\cite{aaronson:counting, belovs:counting} for some lower bounds involving the reflecting oracle.)
In fact, it suffices for $\Oref$ to satisfy the following weaker conditions:
\begin{equation}
\label{eqn:OrefGeneral}
\Oref\colon \begin{cases}
\sqrt{1-p} \ket|0> \ket|\phi_0> + \sqrt{p} \ket|1>\ket|\phi_1>
\mapsto
\sqrt{1-p} \ket|0> \ket|\phi_0> + \sqrt{p} \ket|1>\ket|\phi_1>\\
\sqrt{p} \ket |0>\ket|\phi_0> - \sqrt{1-p} \ket|1>\ket|\phi_1>
\mapsto
-\sqrt{p} \ket |0>\ket|\phi_0> + \sqrt{1-p} \ket|1>\ket|\phi_1>.
\end{cases}
\end{equation}

\begin{thm}[Quantum Amplitude Estimation~\cite{brassard:amplification}]
Let $\eps, \delta>0$ be parameters.
There exists a quantum algorithm that, given a copy of the state $\ket|\phi>$ as in~\rf{eqn:InputOracle} and query access to an oracle $\Oref$ satisfying~\rf{eqn:OrefGeneral}, outputs 0 if $p\le \tfrac12 - \delta$ and outputs 1 if $p\ge \tfrac12 + \delta$ except with error probability $\eps$.
It makes $\ell = \OO(\frac1{\delta\eps})$ (controlled) queries to the oracle $\Oref$,  has space complexity $s + \OO(\log \ell)$, and time complexity $\OO(\ell\log \ell)$.
\end{thm}
While amplitude estimation is typically stated in terms of calls to $O$, it actually uses calls to $\Oref$ defined as in \rf{eqn:Oref}, and it is simple to show that it is in fact sufficient for $\Oref$ to satisfy \rf{eqn:OrefGeneral}. 
Majority voting has better dependence on $\eps$, and amplitude estimation on $\delta$.
It is possible to combine the two procedures obtaining the following result.

\begin{cor}[Quantum Error Reduction]\label{cor:ErrorReduction}
Let $\eps, \delta>0$ be parameters.
There exists a quantum algorithm that $\eps$-approximately performs the transformation~\rf{eqn:ErrorReduction} for any input oracle of the form~\rf{eqn:InputOracle}.
It executes the input oracle $O$ and its inverse $O^*$ both $\OO\sA[\frac1{\delta}\log \frac 1\eps]$ times.
Its space complexity is $\OO\sA[\log\frac 1\eps]\sA[s + \log \frac 1\delta]$, where $s$ is the space complexity of $O$.
Besides executions of $O$ and $O^*$, it uses $\tOO\sA[\frac1{\delta} \log\frac1\eps]$ other 1- or 2-qubit operations.
\end{cor}


The number of queries made by this algorithm has optimal dependence on $\eps$ by~\cite{buhrman:boundsForSmallError} as well as on $\delta$ by~\cite{nayak:approximatingMedian}. 
However, this algorithm is not optimal in terms of memory usage.
It is possible to reuse the memory of the subroutine $O$ as shown by Marriott and Watrous in the context of QMA~\cite{marriott:QMA} -- see also~\cite{nagaj:fastQMA} -- but this construction still uses additional qubits.
Alternatively, one can use Quantum Signal Processing for similar results~\cite{gilyen:quantumSingularValueTransformation}. 
For instance, we can get the following result, which, to the best of our knowledge, has not been previously stated explicitly. 


\begin{thm}
\label{thm:ErrorReduction}
Let $\eps, \delta>0$ be parameters.
There exists a quantum algorithm that, given query access to the oracle $\Oref$ satisfying~\rf{eqn:OrefGeneral}, $\eps$-approximately performs the following transformation
\begin{equation}
\label{eqn:ErrorReductionSign}
\ket |\phi> \longmapsto
\begin{cases}
\ket |\phi>, &\text{if $p\le \tfrac 12 - \delta$;}\\
-\ket |\phi>, &\text{if $p\ge \tfrac 12 + \delta$;}
\end{cases}
\end{equation}
for any normalised $\ket|\phi> \in \spn\sfigA{\ket|0>\ket|\phi_0>, \ket|1>\ket|\phi_1>}$ (including, but not limited to, the specific vector $\ket|\phi>$ from~\rf{eqn:InputOracle}).
The algorithm makes $\ell = \OO\sA[\frac1{\delta}\log\frac1{\eps}]$ queries to the oracle $\Oref$,  uses no additional qubits compared to $\Oref$, and has time complexity $\OO(\ell)$.
\end{thm}
We prove \rf{thm:ErrorReduction} in \rf{sec:QSP}. The proof is similar to a construction in~\cite[Section 3]{gilyen:quantumSingularValueTransformation}, used there for QMA amplification. See \rf{sec:QSP} for a more detailed comparison.




Can the query complexity be improved?
Often $\delta$ is constant, so the query complexity is only logarithmic, and it might not seem important to do better. However, imagine a setting where you want to query a subroutine (perhaps many times) and so you need to reduce its error, at the expense of querying it more often. If this subroutine also queries a subroutine, and so on, to some deep level of recursion, these query complexities multiply together, so that even constant factors may amount to something significant.
The lower bounds mentioned above make query complexity improvements seem impossible.
However, in order to get improvements, we sometimes have to change the setting.
We will show that, in some practical sense, the query complexity of these results \emph{can} be improved.

Consider (classical) Las Vegas algorithms, which have no error, so are exact in some sense, but might run forever. In practice, to get an algorithm with finite running time (a Monte Carlo algorithm), it is necessary to truncate the Las Vegas algorithm after some constant times the expected running time, which introduces some small constant error. However, Las Vegas algorithms, being perfect objects, compose without issue, unlike Monte Carlo algorithms, where in order to successfully compose them, we must first reduce the error, which incurs a $\OO(\frac{1}{\delta^2}\log\frac{1}{\eps})$ factor. 
To compose Las Vegas algorithms efficiently, one must first compose them, and then truncate to get a practical (Monte Carlo) algorithm -- if one first truncates all algorithms and subroutines, and then composes, one incurs logarithmic factors. 

In the quantum world, consider span programs~\cite{reichardt:formulae, reichardt:spanPrograms}, 
or the dual adversary bound~\cite{reichardt:formulae}, which are essentially the same thing for our purposes. Span programs are a universal model of bounded-error quantum algorithms in the sense that for any bounded-error quantum algorithm evaluating a function $f$ with query complexity $Q$, there exists a span program for the same function with \emph{witness complexity}%
\footnote{A notion of complexity for span programs that captures the query complexity of quantum algorithms.}
$\OO(Q)$, and vice versa. 
A span program for $f$ is in some sense exact: there is no notion of error.\footnote{In fact, it is possible to consider span programs that decide a function $f$ only approximately~\cite{ito2019approxSpan}, but this is just for convenience. We know by \cite{reichardt:spanPrograms} that there is always an \emph{exact} span program for $f$ with optimal witness complexity.}
But this does not mean a span program gives rise to an exact quantum algorithm: when we transform a span program into a quantum query algorithm, the resulting algorithm has bounded error.
Nevertheless, we can still make use of this exactness.
If we compose a span program for a function $f$ with complexity $Q_f$ with a span program for a function $g$ with complexity $Q_g$, we get a span program for the composed function $f\circ g$ with complexity $Q_fQ_g$.
Converting it into a quantum query algorithm, gives a bounded-error quantum query algorithm for the composed function $f\circ g$ with query complexity $\OO(Q_f Q_g)$, which is better than $\OO(Q_f Q_g \log Q_f)$, which we would get by composing the programs for $f$ and $g$ directly using \rf{thm:majorityVoting} or~\ref{thm:ErrorReduction} to reduce the error of the latter.

A purifier, first defined in~\cite{belovs:variations}, can be seen as a stand-alone error-reduction gadget for span programs.
It is a dual adversary solution (canonical span program) that takes as input an oracle of the form~\rf{eqn:InputOracle}, and performs the transformation~\rf{eqn:ErrorReduction} exactly.
Its complexity is $\OO(1/\delta^2)$, but this corresponds to query complexity, totally ignoring any notion of time complexity.

In~\cite{belovs:taming}, the quantum algorithmic model \emph{transducers} was introduced.
Informally, transducers play a role similar to span programs and the dual adversary bound (the latter is a special case thereof), but they have a natural way of capturing time and space complexity as well\footnote{Span programs also capture space rather naturally~\cite{jeffery:spanProgramsSpace}, but they only capture time complexity in the sense that it is possible to convert a quantum algorithm into an \emph{approximate} span program, and then back to an algorithm, in a way that more or less preserves time complexity -- there is no clean way to reason about the time complexity within the span program itself~\cite{cornelissen:spanProgramsTime}.}.
More formally, a transducer is a unitary $S$ acting on a direct sum of a \emph{public space} $\cH$ and \emph{private space} $\cL$.
If it performs the transformation
$
S\colon \xi \oplus v \mapsto \tau \oplus v,
$
for $\xi,\tau\in \cH$ and some $v\in\cL$
-- in fact, for any $\xi\in\cH$, there is a unique $\tau$ for which this happens --
we say it \emph{transduces} $\xi$ into $\tau$, denoted $\xi\transduce{S} \tau$. 
It is not obvious, but the map $\xi \transduce{S} \tau$ is unitary (see \rf{sec:prelim}).
A transducer has multiple associated complexities. 
The \emph{query complexity} $L$ of a transducer is its \emph{Las Vegas} query complexity~\cite{belovs:LasVegas} (see \rf{sec:prelim}), and its \emph{transduction complexity} $W$ is $ \|v\|^2$.
The \emph{iteration time}\footnote{In~\cite{belovs:taming}, iteration time was called \emph{time complexity}, but it is \emph{not} the time complexity of an algorithm $A$ corresponding to $S$ (see \rf{tab:compare}).} of $S$, $T(S)$, is defined as the time complexity of implementing the unitary $S$, and similarly the space complexity is the space complexity of $S$. 

\mytable{\label{tab:compare}}
{Transducers have some notions of complexity that correspond to time, query and space complexity, and we can map back and forth between bounded-error quantum algorithms and transducers in a way that preserves these complexities -- this is perhaps a minimum requirement for the claim that they are a reasonable model of quantum algorithms. More than that: we can compose transducers to get much better complexity than we would obtain by directly composing the algorithms, which makes them a useful model.}
{
\negmedskip
\[
\begin{tabular}{rcl}
  Transducer $S$   & &  Algorithm $A$\\
  \hline
  $\xi\transduce{S}\tau$ & & $A(\ket{}|\xi>) \approx \ket{}|\tau>$\\
   $T(S)W(S)$  & $\leftrightarrow$ & time complexity of $A$\\
   $L(S)$  & $\leftrightarrow$ & query complexity of $A$\\
   space complexity of $S$  & $\leftrightarrow$ & space complexity of $A$
\end{tabular}
\]
}


A transducer $S$ as above can be transformed into a bounded-error quantum algorithm that approximately implements the mapping $\xi\mapsto \tau$, making $\OO(L)$ queries to the input oracle, and $\OO(W)$ calls to $S$, and other basic gates (see \rf{thm:transducer-algorithm-query}).
A bounded-error quantum algorithm can be transformed into a transducer in various ways. For example, one transformation produces a transducer that can be implemented in $T(S)=O(1)$ word RAM operations and quantum random access gates, with $W$ approximately the time complexity of the algorithm, $L$ approximately its query complexity, and the space complexity of $S$ its space complexity. Other transformations yield different tradeoffs between $T(S)$ and $W(S)$, and avoid the use of quantum random access gates. 
We summarize the correspondence between the complexities of transducers and those of quantum algorithms in \rf{tab:compare}.
As with span programs, two transducers $S_1$ and $S_2$ can be composed giving a transducer for their composed functionality. The composed transducer has
iteration time $T(S_1)+T(S_2)$, query complexity $L(S_1)L(S_2)$ and transduction complexity $W(S_1) + L(S_1)W(S_2)$. 
These statements are somewhat simplistic, as they do not take into account that a transducer can have different query complexity and different transduction complexity on different inputs.  For more precise statements, refer to~\cite{belovs:taming}, or see \rf{sec:prelim}.


It is clear from these equations that query complexity is of paramount importance as it gets multiplied during composition.
In particular, its \emph{exact} value becomes important in case we compose several layers of transducers, like for iterated functions.
Iteration time is less important, as it only gets added (this is similar to standard algorithmic composition).
On the other hand, total iteration time of the composed transducer gets multiplied by its total transduction complexity, $W(S)$, leading to some peculiar results.

As with span programs (or in the randomized case, Las Vegas algorithms), even an ``exact'' transducer gets transformed into a quantum algorithm with bounded error. When we transform a bounded-error quantum algorithm to a transducer as alluded to above, the error translates into \emph{perturbation} of the transducer, which is morally equivalent to algorithmic error. As with algorithmic errors, these perturbations will add up when we compose transducers if we do not first do something to reduce the perturbations, which is where purifiers enter the picture.

In~\cite{belovs:taming}, a purifier was constructed as a transducer with query and transduction complexity $\OO(1/\delta^2)$. Note that in contrast to majority voting, this is independent of the target error $\eps$, and therefore already allowed bounded-error quantum algorithms to be composed without log factor overhead. 
However, the iteration time and space complexity of this purifier were comparable to that of majority voting from~\rf{thm:majorityVoting}.
The main contribution of this paper is a better and simpler construction of a purifier, more in spirit of \rf{thm:ErrorReduction} (see \rf{thm:mainFormal} for the proof).

\begin{thm}[Main Result, Informal]
\label{thm:main}
Let $\eps, \delta>0$ be parameters.
There exists a transducer (purifier) that, given query access to the oracle $\Oref$ satisfying~\rf{eqn:OrefGeneral}, performs the following transduction
with perturbation $\eps$:
\[
\ket |\phi> \transduce{}
\begin{cases}
\ket |\phi>, &\text{if $p\le \tfrac 12 - \delta$;}\\
-\ket |\phi>, &\text{if $p\ge \tfrac 12 + \delta$;}
\end{cases}
\]
for any normalised $\ket|\phi> \in \spn\sfigA{\ket|0>\ket|\phi_0>, \ket|1>\ket|\phi_1>}$ (including, but not limited to, the specific vector $\ket|\phi>$ from~\rf{eqn:InputOracle}).
The transducer has query complexity $1/(2\delta)$ and transduction complexity $\OO(1/\delta)$.
It uses $\OO(\ell)$ additional qubits and its iteration time is $\OO(\ell)$, where $\ell = \log \frac1\delta + \log\log \frac1{\eps}$.
\end{thm}

This statement is somewhat simplistic as it does not take into account that query and transduction complexities can depend on the input.
In fact, our purifier need not know $\delta$ in advance, and works for all values of $\delta>0$ at once.
A side-by-side comparison of the new purifier and the previous one from~\cite{belovs:taming} can be found in \rf{tab:purifier-comparison}. 

\mytable{\label{tab:purifier-comparison}}
{A side-by-side comparison of our purifier in \rf{thm:main} with the one from \cite{belovs:taming}. Iteration time is with respect to the circuit model.}
{
\negmedskip
    \[
    \def\arraystretch{1.25}
    \begin{tabular}{r|c|c}
         & Purifier from \cite{belovs:taming} & Purifier from \rf{thm:main} (new) \\
         \hline
        Space & $\OO(s\frac{1}{\delta^2}\log\frac{1}{\eps})$ & $s+\OO(\log\frac{1}{\delta} + \log\log\frac{1}{\eps})$ \\
        Iteration time & $\OO(s\frac{1}{\delta^2}\log\frac{1}{\eps})$ & $\OO(\log\frac{1}{\delta} + \log\log\frac{1}{\eps})$ \\
        Query complexity & $\OO(\frac{1}{\delta^2})$ & $\frac{1}{2\delta}$\\
        Transduction complexity & $\OO(\frac{1}{\delta^2})$ & $\OO(\frac{1}{\delta})$\\
    \end{tabular}
    \]
}



Assuming $\delta = \Omega(1)$, if we want to have perturbation $\eps$, we should allow for time and additional space complexity $\OO(\log\log \frac1{\eps})$.
The query complexity does not depend on $\eps$.
Its dependence on $\delta$ is close to optimal, as we show a lower bound of $\frac{1}{2\delta}-1$ in \rf{sec:lower-bound}.
We stress again that the constant factor in the query complexity is potentially very important. If we nest algorithms/oracles to significant depth $d$, then the $d$ query complexities multiply. 

We can also compare the new purifier in \rf{thm:main} with the error reduction procedure of \rf{thm:ErrorReduction} (although we stress that purification does not imply algorithmic error reduction). The query complexity of our new purifier has the same asymptotic dependence on $\delta$, but error reduction also has $\log\frac{1}{\eps}$ dependence on $\eps$. While the number of qubits used by the algorithm in \rf{thm:ErrorReduction} is only $s$, in order to run the algorithm, one would also require a $(\log\ell)$-bit counter to count the $\ell=\OO(\frac{1}{\delta}\log\frac{1}{\eps})$ steps of the algorithm, so the space complexity of our purifier is not asymptotically worse than the error reduction procedure in \rf{thm:ErrorReduction} if one includes both quantum and classical memory.

If we want to perform the transduction as in~\rf{eqn:ErrorReduction} using the oracle $O$ as in~\rf{eqn:InputOracle} as well as its inverse, we need query complexity $1 + 1/(2\delta)$ (see \rf{cor:InputOracleErrorReduction}). 

Our new purifier is extremely simple: besides execution of the input oracle, it uses two increment and two decrement operations.
It can be seen as implementing an electric quantum walk~\cite{belovs:electicityQuantumWalks} on the line graph corresponding, in some way, to classical majority voting.
We use the fact that a quantum walk operator is an exact transducer.

\paragraph{Discussion} A purifier can be thought of somewhat analogously to a procedure for turning a Monte Carlo algorithm into a Las Vegas algorithm, although such a construction is not possible classically. 
The consequences of our result are similar to the ones obtained in~\cite{belovs:taming}.
We will mention one simple result, \rf{thm:composition} below, restated from \cite{belovs:taming}, where it is proven using the purifier construction from \cite{belovs:taming}. Not only does our new purifier improve the space complexity of the composed quantum algorithm referred to in \rf{thm:composition}, our improved dependence on $\delta$ gives better constant-factor overhead, which could matter a lot in algorithms that are obtained from super-constant-depth composition. We have not worked out these improvements, and leave this for future work.


\begin{thm}\label{thm:composition}
Let $A$ and $B$ be quantum algorithms in the circuit model that evaluate the
functions $f$ and $g$, respectively, with bounded error.
Let $L$ be the query complexity of $A$, and $T(A)$ and $T(B)$ be the time complexities of $A$ and $B$.
Then, 
\begin{itemize}
\item[(a)]
there exists a quantum algorithm in the circuit model that evaluates the composed function $f\circ g$ with bounded error in time complexity
\begin{equation}
\label{eqn:compositionCircuit}
\OO(L)\sA[T(A) + T(B)].
\end{equation}
\item[(b)]
There exists a quantum algorithm using quantum random access memory that evaluates the composed function $f\circ g$ with bounded error in time complexity
\begin{equation}
\label{eqn:compositionQRAG}
\OO\sA[T(A) + L\cdot T(B)]
\end{equation}
assuming random access and elementary arithmetic operations on memory addresses (word RAM operations) can be done in time $\OO(1)$.
\end{itemize}
\end{thm}

While the expression in~\rf{eqn:compositionQRAG} seems very natural, the one in~\rf{eqn:compositionCircuit} is not so, which is a consequence of the way iteration time behaves under composition of transducers.
Eq.~\rf{eqn:compositionCircuit} is optimal if $T(A) \le T(B)$, though.

\begin{openproblem}
Is it possible to improve~\rf{eqn:compositionCircuit} to $\OO\sA[T(A) + L\cdot T(B)]$ in the circuit model?
\end{openproblem}

More generally, it seems quite useful to have an effectively exact representation of bounded-error quantum algorithms, and we suspect this has implications beyond composition. For a high-level didactic overview of some of the concepts of this paper, as well as previous related work, we refer the reader to~\cite{jeffery2024SIGACT}.







\paragraph{Organization} The remainder of this paper is organized as follows. In \rf{sec:prelim}, we formally define and give the necessary background on transducers. In \rf{sec:intuition}, we describe classical majority voting as a random walk on a line, and discuss how a similar quantum walk on a line can be seen as a transducer. This section is for intuition, and can be skipped without loss of technical rigor. In \rf{sec:infiniteDimensional}, we use the idea of a quantum walk on an infinite line to design a purifier that reduces the error to zero, but is impractical because it works in an infinite-dimensional space. In \rf{sec:time-efficient}, we make the infinite-dimensional purifier practical by truncating the space (which introduces a small perturbation), and in \rf{sec:query-efficient}, we discuss how, if we only care about query complexity, we can truncate the space without any perturbation. In \rf{sec:lower-bound}, we show that the query complexity of our purifier is nearly tight, and in \rf{sec:QSP}, we describe our error reduction for algorithms, proving \rf{thm:ErrorReduction}. Finally, in \rf{sec:non-Boolean}, we describe how to extend the results to non-Boolean functions.



\section{Preliminaries}\label{sec:prelim}



Let $A = A(O)$ be a quantum query algorithm with input oracle $O$, to which it can make controlled queries.
The usual definition of its query complexity is the number of queries, or executions of the input oracle.
In~\cite{belovs:LasVegas}, an alternative definition of \emph{Las Vegas query complexity} was introduced.
Assume $A(O)$ is executed on some initial state $\ket|\xi>$. 
Let $\ket |\psi_i>$ be the state of the algorithm right before the $i$-th query (it depends on both $O$ and $\ket |\xi>$), and let $\ket |\psi_i^\bullet>$ be the projection of $\ket |\psi_i>$ onto the part of the space to which $O$ is applied (since $O$ is applied with a control, it is potentially only applied to a part of the space). 
Then the Las Vegas query complexity of $A(O)$ on input $\ket |\xi>$ is
$$L(A,O,\xi) = \sum_i\normA |\psi_i^\bullet|^2.$$
That is, it is the sum, over all queries, of the squared norm of the part of the state to which the query is \emph{actually} applied.
For intuition, note that the Las Vegas (i.e. expected) query complexity of a randomized classical algorithm is the sum over all steps where a query might be made, of the probability of making a query at that step. Moreover, this notion of query complexity is meaningful in the sense that we can convert $A$ to a (bounded-error) quantum algorithm with query complexity $\OO(L)$, where $L$ is the max of $L(A,O,\xi)$ over all admissible inputs. 

Note that $L(A,O,\xi)$ only counts queries to $O$, and not its inverse $O^*$. We can easily remedy this by replacing $O$ with $O\oplus O^*$, which allows us to apply either $O$ or $O^*$ based on the value of some control register. 

\vskip10pt
In the remainder of this section, we give the necessary background on transducers. For further details, see~\cite{belovs:taming}.

\paragraph{Transducers} In the standard model of quantum algorithms, a quantum algorithm is a sequence of unitaries, some of which may be black-box calls, the rest of which are ``simple'' in some desired sense, such as being local, or low depth, or perhaps merely independent of the input. This sequence of unitaries induces some target unitary action, or some unitary action that achieves the target action up to some perturbation. In contrast, transducers are a newer paradigm for quantum algorithms whereby a single unitary -- often simple to implement in some desired sense -- gives rise to some target unitary action.

Formally, a \emph{transducer} is a unitary $S$ acting on a direct sum of vector spaces ${\cal H}\oplus {\cal L}$, called the \emph{public} space and \emph{private} space. 
As one can see from the naming, we have a case of encapsulation here: an outside algorithm has only access to the public space 
(which we can also call the \emph{boundary}), and can modify the private space \emph{only} by executions of $S$.
The transducer induces a unitary $U$ on ${\cal H}$, as follows (proven in~\cite[Theorem~5.1]{belovs:taming}).

\begin{thm}
    Let $S$ be a unitary acting on a direct sum of vector spaces ${\cal H}\oplus {\cal L}$. For any $\xi\in{\cal H}$, there exist unique $\tau = \tau(S,\xi)\in{\cal H}$ and $v=v(S,\xi)\in{\cal L}$ such that
    $$S:\xi\oplus v\maps{} \tau\oplus v.$$
    Moreover, for fixed $S$, the action $\xi\maps{} \tau(S,\xi)$ is unitary.
\end{thm}

It is the unitary action $\xi\maps{} \tau(S,\xi)$ that we think of as being induced by $S$, and formally we say $S$ \emph{transduces} $\xi$ into $\tau$, and write $\xi\transduce{S}\tau$. Note that given $\xi$, there is generally no way to obtain $\tau$ with a single use of $S$, unless $v(S,\xi)=0$. The vector $v$ is called the \emph{catalyst}, and it can be quite large. Its size $W(S,\xi)=\normA |{v(S,\xi)}|^2$ is called the \emph{transduction complexity}\footnote{Catalysts are not unique, but there is a unique smallest one, and $W(S,\xi)$ is actually the norm of this one. Thus $\normA |{v}|^2$ gives an upper bound on $W(S,\xi)$ for any catalyst $v$.}, motivated by the following (proven in~\cite[Theorem~5.5]{belovs:taming}).


\begin{thm}\label{thm:transducer-algorithm}
    Fix a positive integer $K$, and spaces ${\cal H}$ and ${\cal L}$. There is a quantum algorithm that, 
    for any transducer $S$ on ${\cal H}\oplus {\cal L}$,
    on input $\xi\in {\cal H}$, outputs a state $\tau'$ such that
    $$\normA |{\tau'-\tau(S,\xi)}|\leq 2\sqrt{\frac{W(S,\xi)}{K}}$$
    using $K$ controlled calls to $S$, and $\OO(K)$ other basic operations.
\end{thm}
The algorithm referred to in \rf{thm:transducer-algorithm} begins in the initial state $\ket|\xi>$ (in the public space -- and 0 in the private space), and makes $K$ sequential (controlled) calls to $S$, interspersed with some basic operations. 
By taking $K$ to be an upper bound on $\frac{4}{\eps^2}W(S,\xi)$, this gives an algorithm that implements the map induced by $S$ up to error $\eps$. 



As an example, if $S$ is the \emph{walk operator}, 
representing one step of an electric quantum walk, and $s$ is some starting vertex, then if there exists a marked vertex, $\ket |s>\transduce{S}\ket|s>$, and otherwise $\ket|s>\transduce{S} -\ket |s>$. For details see \cite[Section~6]{belovs:taming} or \cite{belovs:phaseHelps}.

\paragraph{Complexities} A transducer $S$ represents an algorithm on the public space $\cH$, via \rf{thm:transducer-algorithm}. However, $S$ is also a unitary on $\cH\oplus\cL$, which can be implemented by an algorithm on $\cH\oplus\cL$. We let $A_S$ denote a (usually optimal) quantum algorithm that implements $S$. 
This makes definition of the iteration time, $T(S)$, and the space complexity of $S$ very easy: just use the same definitions as for the time and space complexity of $A_S$.
Note that iteration time is precisely where we marry the model-dependent notion of ``time complexity'' with the nice clean mathematical model of transducers. The notion of time complexity we use to analyze $A_S$ might be with respect to a particular gate set; it might include random access gates (or not); it might be the depth. The time complexity of the algorithm we get in \rf{thm:transducer-algorithm} will inherit this model. 
Note that neither the iteration time nor the space complexity depend on the initial state, or the input oracle.

Speaking of the input oracle, we define the query complexity $L(S, O, \xi)$ of the transducer $S$ on the input oracle $O$ and the initial state $\xi$ as the Las Vegas quantum query complexity of $A_S$ on the initial state $\xi \oplus v$ and the input oracle $O$, where $v$ is the corresponding catalyst.
Note that the state $\xi \oplus v$ is not normalised, but the definition of the Las Vegas query complexity still makes sense.






\paragraph{Canonical transducers}
It is well known that every quantum query algorithm can be turned into a canonical form: unitaries interspersed with executions of the input oracle.
In case of transducers, the canonical form is extremely simple: it is just one(!) execution of the input oracle on a part of the private space, following by a unitary independent of the input oracle.

As usual, it is much more convenient to design a transducer without assuming the canonical form, but for its implementation, it is extremely helpful.
Luckily, it is easy to transform any transducer into a canonical form with minimal increase in complexity.

For a canonical transducer, we restrict $O$ to be applied to the private space ${\cal L}$ -- this is natural because $O$ is somehow ``internal'' to any algorithm that calls it. As usual, we let $O$ be applied controlled on being in a certain subspace, which we will denote ${\cal L}^\bullet$, and call the \emph{query part}. That is, we assume a decomposition ${\cal L}={\cal L}^\circ\oplus {\cal L}^\bullet$, where we apply $O$ controlled on being in ${\cal L}^\bullet$.

Then we say that $S(O)$ is in \emph{canonical form} if it can be written
\begin{equation}
    S(O) = S^{\circ}\widetilde{O},
\end{equation}
where $\widetilde{O}$ applies $O$ controlled on being in ${\cal L}^{\bullet}$, and $S^\circ$ is an input-independent \emph{work unitary}. 
Decomposing 
$v=v^{\bullet}\oplus v^{\circ}$  into its ${\cal L}^{\bullet}$ and ${\cal L}^\circ$ parts, the action of $S(O)$ looks like
\begin{equation}\label{eqn:canonical}
    S(O):\xi\oplus v^{\circ}\oplus v^{\bullet} \maps{\widetilde{O}}
    \xi\oplus v^{\circ}\oplus O v^{\bullet}
    \maps{S^\circ} \tau\oplus v^{\circ}\oplus v^{\bullet},
\end{equation}
Thus, for a canonical transducer, the query complexity with respect to an input $\ket |\xi>$
is simply:
\begin{equation}
    L(S,O,\xi) = \normA |v^\bullet(S,\xi)|^2.
\end{equation}

Then we have the following refinement of \rf{thm:transducer-algorithm} (from \cite[Theorem 3.3]{belovs:taming}), which justifies \rf{tab:purifier-comparison}.
\begin{thm}\label{thm:transducer-algorithm-query}
    Fix spaces ${\cal H}$ and ${\cal L}={\cal L}^{\circ}\oplus{\cal L}^\bullet$. There is a quantum algorithm that, 
    for any canonical transducer $S(O)$ on ${\cal H}\oplus {\cal L}$ and $\eps\in (0,1/2)$,
    on input $\xi\in {\cal H}$, outputs a state $\tau'$ such that
    $$\normA |{\tau'-\tau(S,\xi)}|\leq \eps,$$
    using $\OO(L(S,O,\xi)/\eps^2)$ controlled calls to $O$,
    $K=\OO(1+W(S(O),\xi)/\eps^2)$ controlled calls to $S^\circ$, and $\OO(K)$ other basic operations.
\end{thm}

Fortunately, any transducer with input oracle $O$ can be made canonical without increasing the query complexity, and increasing the transduction complexity by the query complexity, and the iteration time by a multiplicative constant (\cite[Proposition~10.4]{belovs:taming}). 

\paragraph{Perturbed transducers} Sometimes the transduction action of a transducer $\widetilde{S}$ is not exactly the desired unitary, but pretty close. A natural example is when the desired action is something like: 
\begin{equation} 
\ket|0>\transduce{S(O_x)}(-1)^{f(x)}\ket|0>
,
\end{equation}
meaning we want to implement a query to a function $f$ using queries to $x$, $O_x:\ket|i>\maps{}(-1)^{x_i}\ket|i>$ (or perhaps $S$ has some other dependence on $x$). We say $\widetilde{S}$ is a perturbed transducer for some action $S:\xi\oplus v\maps{} \tau\oplus v$ if it implements the map with some small perturbation
\begin{equation}\label{eqn:perturbation}
\delta(S,\xi)=\normA |{(\tau\oplus v)-\widetilde{S}(\xi\oplus v)}|.
\end{equation}



\paragraph{Composition of transducers} 

We can compose transducers similar to how we can compose quantum algorithms, and the complexity of these compositions follows some natural rules. We sketch two examples below that will come up in this paper. For details, refer to Section 9 of \cite{belovs:taming}. For all these compositions, it is convenient to assume the transducers are in canonical form. 

If $S_A$ and $S_B$ are transducers with transduction actions $U_A$ and $U_B$, respectively, on the same public space $\cH$, then we can compose them \emph{sequentially} to obtain a transducer $S_B * S_A$ with transduction action $U_BU_A$ on the space $\cH$.
The transduction, the query, and the iteration time complexities of $S_B * S_A$ are the sums of the corresponding complexities of $S_A$ and $S_B$.

Next, if $S_A(O')$ is a transducer with an input oracle $O'$ acting in some space $\cM$, and $S_B$ is a transducer with transduction action $U_B$ on space $\cM$, we can define their \emph{functional composition} $S_A\circ S_B$, which is a transducer whose transduction action is identical to that of $S_A(U_B)$.

We can also consider functional composition in the case where $S_A$ and $S_B$ query some ``global'' input oracle $O$, distinct from $O'$ (which $S_A$ also depends on). Letting a transducer depend on two oracles requires no extension of the model already described. Since an oracle is assumed to be called with some control, we can simply let $S_A(O\oplus O')$ depend on a single oracle $O\oplus O'$. Concretely, we can suppose there are orthogonal subspaces ${\cal L}^{(0)}$ and ${\cal L}^{(1)}$ such that $O$ is applied controlled on being in ${\cal L}^{(0)}$ and $O'$ is applied controlled on being in ${\cal L}^{(1)}$. 

To discuss the complexities of functionally composed transducers, we need the concept of a \emph{partial query state}. Consider the algorithm $A_S$ that implements the unitary $S$.
As usual, we let $\ket |\psi_i>$ denote the state of this algorithm right before the $i$-th query, on oracle $O\oplus O'$ and input $\xi$. We can decompose it into three orthogonal parts:
$$\ket |\psi_i> = \psi_i^{\circ} \oplus \psi_i^{(0)}\oplus\psi_i^{(1)},$$
where $\psi_i^{(0)}$ is its projection onto ${\cal L}^{(0)}$, the space to which $O$ is applied, and $\psi_i^{(1)}$ is its projection onto ${\cal L}^{(1)}$, the space to which $O'$ is applied. Then the \emph{partial query state} relative to $O$ is:
$$q^{(0)}(S_A,O\oplus O',\xi)=\sum_i\ket |i> \otimes \psi_i^{(0)},$$
and the partial query state relative to $O'$ is:
$$q^{(1)}(S_A,O\oplus O',\xi)=\sum_i\ket |i> \otimes \psi_i^{(1)},$$
where in both cases, $i$ runs over all queries of $A_S$. Letting $L^{(0)}$ denote the Las Vegas query complexity in terms of queries to $O$, we can see that:
$$L^{(0)}(S_A,O\oplus O',\xi) = \normA |q^{(0)}(S_A,O\oplus O',\xi)|^2.$$
The query complexity of the composed transducer is then:
        \begin{equation}\label{eqn:comp}
        L(S_A\circ S_B,O,\xi) = L^{(0)}(S_A,O\oplus O',\xi) + L(S_B,O,q^{(1)}(S_A,O\oplus O',\xi)).
        \end{equation}
To parse \rf{eqn:comp},  
note that the term $L(S_B,O,q^{(1)}(S_A,O\oplus O',\xi))$ can be rewritten:
$$\normA |q^{(1)}(S_A,O\oplus O',\xi)|^2L(S_B,O,\xi') = L^{(1)}(S_A,O\oplus O',\xi)L(S_B,O,\xi')$$
where $\xi'$ is the normalization of the partial query state $q^{(1)}(S_A,O\oplus O',\xi)$, which is the input to $S_B$, and $L^{(1)}(S_A,O\oplus O',\xi)$ is the Las Vegas query complexity of $S_B(O\oplus O')$ in terms of queries to $O'$, on input $\xi$. Thus, if $L(S,O)$ denotes an upper bound on $L(S,O,\xi)$ over some set of admissable inputs, we have, assuming $q^{(1)}(S_A,O\oplus O',\xi)$ is always an admissable input when $\xi$ is an admissable input,
$$L(S_A\circ S_B,O) = L^{(0)}(S_A,O\oplus O')+L^{(1)}(S_A,O\oplus O')L(S_B,O),$$
so the query complexity of the composed transducer is the query complexity of $S_A$ relative to $O$, plus its query complexity relative to $O'=U_B$ times the query complexity of $S_B$ relative to $O$, which is similar to what happens with functional composition of algorithms.

Similarly, the transduction complexity of the composed transducer is
    \begin{align*}
        W((S_A\circ S_B)(O),\xi) = W(S_A(O\oplus O'),\xi)+W(S_B(O),q^{(1)}(S_A,O\oplus O',\xi)),
    \end{align*} 
    and the iteration time is just the sum of the iteration times $T(S_A)+T(S_B)$. 
    


\section{Intuition}
\label{sec:intuition}

In this section, we describe some intuition behind our construction and its connection to the usual classical majority voting (see also \cite{jeffery2024SIGACT}).
The remainder of this paper does not depend on the content of this section, and the reader may skip directly to \rf{sec:infiniteDimensional} without loss of technical rigor.

Classical majority voting can be seen as follows.
You are given a biased coin that outputs $-1$ with probability $1-p$, and $+1$ with probability $p$.
You want to decide whether $p\le \tfrac12 -\delta$ (negative case), or $p\ge \tfrac12 +\delta$ (positive case).
You toss the coin a total of $K$ times.
If the total sum is positive, you accept; otherwise, you reject.
By Hoeffding's inequality, the error probability is exponentially small in $K$.

\myfigure{\label{fig:line2directions}}
{Majority voting can be seen as a random walk on the bidirectional infinite line.}
{
\[
\def\nodegap{1.5}
\begin{tikzpicture}
\foreach \x in {-4,...,4}
    \draw (\x*\nodegap, 0) node[draw,shape=circle,inner sep=7] (\x) {} node {$\x$};
\foreach \x [evaluate={\y=int(\x+1)}] in {-4,...,3}
    \draw (\x) -- (\y);
\draw (-4) -- +(-1,0) +(-\nodegap,0) node{$\cdots$};
\draw (4) -- +(1,0) +(\nodegap,0) node{$\cdots$};
\end{tikzpicture}
\]
}

This can be seen as a random walk on the infinite line (see \rf{fig:line2directions}), where you start in the vertex $0$, and, on each step, move to the left with probability $1-p$ and to the right with probability $p$.
The current vertex stores the total sum of all the outputs.
At the end, you accept if you are to the right of the vertex 0.
Using the standard convention that the probability of following an edge is proportional to its weight, this random walk is captured by assigning the weight 
\begin{equation}
\label{eqn:randomWalkWeights}
w_j = \s[\frac{p}{1-p}]^j
\end{equation}
to the edge between the vertices $j$ and $j+1$.
Indeed, the probability of going right with this assignment of weights is precisely $p/(1-p)$ times the probability of going left.

For our quantum walk, we only consider the right half of this graph, which forms an infinite ray (see \rf{fig:line}).
Let us first consider a random walk on such a graph.
We will consider the \emph{transience} properties of this graph in the sense of P{\'o}lya~\cite{polya:transience} (see also~\cite[Chapter 2]{doyle:walksElectric}).

If $p<1/2$, which is equivalent to $p/(1-p)<1$, this walk is recurrent, meaning that it returns to the vertex 0 infinitely many times with probability 1.
If $p>1/2$, which corresponds to $p/(1-p)>1$, this walk is transient, meaning that it will escape to infinity with probability 1.
Our quantum walk can be seen as deciding which is the case.

\myfigure{\label{fig:line}}
{The quantum walk used by our purifier.
The number above the edge specifies its weight as in~\rf{eqn:randomWalkWeights}, where we use the same parameter $\gamma = \sqrt{p/(1-p)}$ we will be using in \rf{sec:infiniteDimensional} and beyond.
Below each edge, the corresponding state of the quantum walk is written.
}
{
\[
\def\nodegap{1.7}
\begin{tikzpicture}
\foreach \x in {0,...,5}
    \draw (\x*\nodegap, 0) node[draw,shape=circle,inner sep=7] (\x) {} node {$\x$};
\foreach \x [evaluate={\y=int(\x+1)}, evaluate={\z=int(2*\x)}] in {1,2,3,4}
    \draw (\x) --
        node[below,blue] {$\ket|\x>$}
        node[above] {$\gamma^{\z}$}
            (\y);
\draw (0) --node[below,blue] {$\ket|0>$} node[above] {1} (1);
\draw (5) -- +(1,0) +(\nodegap,0) node{$\cdots$};
\end{tikzpicture}
\]
}

The quantum walk happens on edges.
The state $\ket |j>$ corresponds to the edge between the vertices $j$ and $j+1$.
The quantum walk is composed of local reflections.
By construction, the local reflection about the vertex $j>0$ reflects the state
\[
\sqrt{w_{j-1}} \ket|j-1> + \sqrt{w_j} \ket|j>,
\]
which is proportional to
\begin{equation}\label{eqn:walk-states}
\sqrt{1-p}\ket |j-1> + \sqrt{p} \ket|j>,
\end{equation}
and can be easily implemented given a quantum version of the biased coin.
One ``step'' of the quantum walk is given by the \emph{quantum walk operator} $R_2R_1$, where $R_1$ is the composition of all local reflections about the odd vertices, and $R_2$ about the even vertices.

To upper bound the number of times an algorithm should call $R_2R_1$ -- that is, the number of \emph{steps} -- while ensuring that the algorithm distinguishes between the transient (positive) and non-transient (negative) cases, we need to upper bound a ``complexity'' for each case (for details, see~\cite{belovs:electicityQuantumWalks}).
The complexity of the quantum walk in the negative case $p\le \tfrac12 -\delta$ is given by the total weight of the graph.
In this case, it is
\[
\sum_{j=0}^\infty \gamma^{2j} = \OO(1)
\]
since $\gamma$ is bounded below 1 in the negative case.

In the positive case, the complexity is given by the \emph{effective resistance}, which is the total energy dissipated by the unit flow from the initial vertex to the marked vertex.
The marked vertex in this case is infinity.
The flow is of value 1 along all edges, so the energy is given by
\[
\sum_e\frac{1}{w_e}=\sum_{j=0}^\infty \frac{1}{\gamma^{2j}} = \OO(1)
\]
since $\gamma$ is bounded above 1 in the positive case.

Above, we assumed that the flow is on an infinite line, which is impractical.
To get an actual algorithm, we chop the line at some vertex $\ell$.
This introduces an error that is exponentially small in $\ell$, but does not affect the above complexity estimates.


\section{Infinite-Dimensional Construction}
\label{sec:infiniteDimensional}

In this section, we describe a version of the purifier in infinite-dimensional space.
Although, this purifier cannot be implemented directly because of that, it can still be analysed and it contains all the main ideas in the most clear way.
As we described in \rf{sec:intuition}, the transducer can be seen as a quantum walk on an infinite ray.

In later sections we will modify the purifier so that it uses finite space.
There are two ways to do that.
In the time-efficient variant, described in \rf{sec:time-efficient}, we simply chop the infinite ray after a finite number of edges.
This introduces a small error.
In the query variant, described in \rf{sec:query-efficient}, it is assumed that there is only a \emph{finite} number of possible input oracles, which is consistent with the usual setting of the state conversion problem with general input oracles~\cite{lee:stateConversion, belovs:variations}.
In this case, we simply restrict the purifier to the corresponding finite subspace.
It is still exact, and it can be embedded into a finite space, but time-efficiency is lost.


\subsection{Special Case}
\label{sec:SimpleInfinite}
We first consider a special case when the generating oracle acts on one qubit and performs a transformation of the form
\begin{equation}
\label{eqn:simpleOracle}
O\colon \ket|0> \longmapsto \ket|\phi> = \sqrt{1-p} \ket|0> + \sqrt{p}\ket|1>,
\end{equation}
which is precisely the quantum version of the biased coin described in \rf{sec:intuition}.
The corresponding reflecting oracle is just
\begin{equation}
\label{eqn:simpleOref}
\Oref = O Z O^*,
\end{equation}
where $Z$ stands for the usual $Z = \begin{psmallmatrix} 1 & 0 \\ 0 & -1 \end{psmallmatrix}$ Pauli operator.
We use parameter
\begin{equation}
\label{eqn:gamma}
\gamma = \sqrt{\frac{p}{1-p}}.
\end{equation}
The two extreme cases $p=0$ and $p=1$, corresponding to $\gamma = 0$ and $\gamma=\infty$, are also covered by the analysis, where we use the usual convention that $0^{-1} = \infty$ and $\infty^{-1}=0$.

The transducer $S$ acts on one register $\reg J$ for storing an index, which is a non-negative integer, and which we will denote by $j$ in this section.
However, to make the increment and the decrement operations unitary, we have to assume that $\reg J$ can contain an arbitrary integer.

We use $\reg A$ to denote the least significant qubit of $\reg J$, and $\reg K$ the remaining qubits of $\reg J$.
Thus, $\ket K|i> \ket A |b> = \ket J |2i+b>$.
The public space $\cH$ of $S$ is spanned by $\ket J |0>$, the private space $\cL$ is spanned by $\ket J |j>$ with $j>0$.
As mentioned above, the states $\ket J|j>$ with $j<0$ are not used.
The transducer $S$ is a product of two reflections $S = R_2R_1$, defined as in \rf{fig:simple}.

\myfigure{\label{fig:simple}}
{
Two reflections comprising the transducer $S = R_2R_1$.
The $+1$ and the $-1$ operators increment and decrement the register $\cJ$, respectively.
The control for $\Oref$ is on $\cK$ being non-zero.
}
{
\[
R_1\colon \quad
\begin{quantikz}
\lstick{$\cK$}& \qw & \qw\\
\lstick{$\cA$}& \gate{\Oref} &\qw
\end{quantikz}
\qquad
R_2\colon \quad
\begin{quantikz}
\lstick{$\cK$}& \gate[2]{+1} &  \ctrl{1} & \gate[2]{-1} &\qw\\
\lstick{$\cA$}& & \gate{\Oref} & & \qw
\end{quantikz}
\]
}


As we will shortly see in \rf{clm:simpleReflections}, $R_1$ and $R_2$, restricted to the span of $\ket J |j>$ for $j\geq 0$, are essentially the reflections around the odd and even states defined in \rf{sec:intuition} under \rf{eqn:walk-states}, except that $R_2$ reflects around not only the states $\sqrt{1-p}\ket|j-1>+\sqrt{p}\ket|j>$ for even $j>0$, but also the state $\ket|0>$. The additional reflection around $\ket|0>$ is necessary to ``cut'' the line at vertex 0, so it is not infinite in both directions.


The following vectors will be important in the analysis, where $j$ is a non-negative integer:\footnote{
If $\gamma=\infty$, then $u_j = \ket|j+1>$.
Similarly, if $\gamma=0$, then $u_j^\perp = \ket |j+1>$.
}
\begin{equation}
\label{eqn:simpleStates}
\begin{split}
u_j &= \ket |j> + \gamma \ket|j+1>\\
&\;\propto \sqrt{1-p}\ket |j>+\sqrt{p}\ket |j+1>
\end{split}
\qqand
\begin{split}
u_j^\perp &= \ket |j> - \gamma^{-1} \ket|j+1>\\
&\;\propto \sqrt{p}\ket |j> -\sqrt{1-p}\ket |j+1>.
\end{split}
\end{equation}

\begin{clm}
\label{clm:simpleReflections}
For all even $j$, we have $R_1 u_j = u_j$ and $R_1 u_j^\perp = -u_j^\perp$.
Also, $R_2\ket|0> = \ket |0>$.
For all odd $j$, $R_2 u_j = u_j$ and $R_2 u_j^\perp = -u_j^\perp$.
\end{clm}

\begin{proof}
By construction, $R_1$ acts as identity on $\ket K|i> \otimes \ket A|\phi> = \sqrt{1-p} \ket|2i> + \sqrt{p}\ket|2i+1>$, and negates its orthogonal complement in the span of $\ket|2i>$ and $\ket |2i+1>$.  The state $u_{2i}$ is proportional to the former, and $u_{2i}^\perp$ to the latter.
The case of $R_2$ is proven similarly.
\end{proof}

We can now prove that $S=R_2R_1$ is an \emph{exact} transducer with the desired transduction action, and query complexity precisely $1/(2\delta) = |1-2p|^{-1}$.
\begin{thm}
\label{thm:simple}
In the above notation, $S = R_2R_1$ with input oracle $\Oref$ performs the following transduction:
\[
S \colon \ket |0> \transduce{} 
\begin{cases}
\ket |0>, &\text{if $p < \tfrac 12$;}\\
- \ket |0>, &\text{if $p > \tfrac 12$.}
\end{cases}
\]
The query complexity of the transducer is $L(S, \Oref, \ket |0>)=1/(2\delta)$, 
and the transduction complexity is $W(S(\Oref),\ket|0>) = \OO(1/\delta)$, where $\delta = |\tfrac12 - p|$.
\end{thm}


The transducer we construct in the proof below is not canonical (see \rf{sec:prelim}). It can be converted to a canonical transducer, keeping the query complexity the same, but the transduction complexity of the resulting transducer is $W(S'(O))=W(S(O))+L(S(O))\leq\frac{1}{\delta}$ (see \cite[Proposition 10.4]{belovs:taming}). In any case, constant factors on $W$ are not important, whereas constant factors on $L$ become important in composition to significant depth.

\begin{proof}
If $p < \tfrac12$, then $\gamma < 1$, and we define $\ket |v> = \sum_{j=1}^\infty\gamma^j\ket |j>$.
The action of the transducer is given by
\begin{equation}
\label{eqn:SimpleSequence1}
\begin{aligned}
\ket|0>+\ket|v>=&\sum_{j=0}^\infty \gamma^j \ket |j> = \sum_{i=0}^\infty \gamma^{2i} \sA[\ket |2i> + \gamma \ket |2i+1>]\\
\maps{R_1} & 
\sum_{j=0}^\infty \gamma^j \ket |j>
= \ket |0> + \sum_{i=0}^\infty \gamma^{2i+1} \sA[\ket |2i+1> + \gamma \ket |2i+2>]\\
\maps{R_2}&
\sum_{j=0}^\infty \gamma^j \ket |j> = \ket|0>+\ket|v>,
\end{aligned}
\end{equation}
where we used \rf{clm:simpleReflections}.
Therefore, $\ket |0> \transduce{S} \ket |0>$.
The input oracle is applied to the states in the brackets above, therefore,
the Las Vegas query complexity is given by
\[
\sum_{i=0}^\infty \normB|{\gamma^{2i} \sA[\ket |2i> + \gamma \ket |2i+1>] }|^2 + 
\sum_{i=0}^\infty \normB|{\gamma^{2i+1} \sA[\ket |2i+1> + \gamma \ket |2i+2>] }|^2 =
\sum_{j=0}^\infty \gamma^{2j} +  \sum_{j=1}^\infty \gamma^{2j} = \frac{2}{1-\gamma^2} - 1 = \frac1{2\delta}.
\]

Now, if $p > \frac 12$, then $\gamma > 1$, and we define $\ket|v>=\sum_{j=1}^\infty (-\gamma)^{-j}\ket|j>$.
The action of the transducer is given by
\begin{equation}
\label{eqn:SimpleSequence2}
\begin{aligned}
\ket|0>+\ket|v>=&\sum_{j=0}^\infty (-\gamma)^{-j} \ket |j> 
= \sum_{i=0}^\infty \gamma^{-2i} \sA[\ket |2i> - \gamma^{-1} \ket |2i+1>]\\
\maps{R_1} & 
-\sum_{j=0}^\infty (-\gamma)^{-j} \ket |j>
= -\ket |0> + \sum_{i=0}^\infty \gamma^{-2i-1} \sA[\ket |2i+1> - \gamma^{-1} \ket |2i+2>]\\
\maps{R_2}&
-\ket |0> - \sum_{i=0}^\infty \gamma^{-2i-1} \sA[\ket |2i+1> - \gamma^{-1} \ket |2i+2>] = - \ket|0> + \sum_{j=1}^\infty (-\gamma)^{-j} \ket |j>
=-\ket|0>+\ket|v>.
\end{aligned}
\end{equation}
Therefore, $\ket |0> \transduce{S} -\ket |0>$.
The Las Vegas query complexity is
\[
\sum_{j=0}^\infty \gamma^{-2j} +  \sum_{j=1}^\infty \gamma^{-2j} = \frac{2}{1-\gamma^{-2}} - 1 = \frac1{2\delta}.
\]
By a similar computation, we can show that $\normA|v|\leq \frac{1}{2\delta}$ in both cases, showing that the transduction complexity is at most $\frac{1}{2\delta}$.
\end{proof}

\begin{rem}
\label{rem:SimpleOrder}
Note that \rf{thm:simple} holds for $R_1R_2$ as well.
The sequence~\rf{eqn:SimpleSequence1} is similar with the same catalyst; in the sequence~\rf{eqn:SimpleSequence2}, the catalyst should be $- \sum_{j=1}^\infty (-\gamma)^{-j} \ket|j>$.
\end{rem}




\subsection{General Case}

In this section, we consider the general case when the reflecting oracle $\Oref$ in $\cA\otimes \cW$ satisfies~\rf{eqn:OrefGeneral}.
We first describe the transducer, and then explain its relation to the transducer in~\rf{sec:SimpleInfinite}.
The transducer uses the same register $\reg J$ as in \rf{sec:SimpleInfinite} for storing an index, which can be an arbitrary non-negative integer.
It additionally uses the registers $\reg A$ and $\reg W$ acted on by the input oracle.
When describing the states, the registers are listed in this order.
The public space of the transducer is spanned by $\ket J|0>\otimes \cA\otimes \cW$.
The transducer is given by $S' = R_2'R_1'$ for reflections $R_1'$ and $R_2'$ defined as in \rf{fig:general}.

\myfigure{\label{fig:general}}
{
Two reflections that give the transducer $S' = R_2'R_1'$.
Closed controls ($\bullet$), including the one from the register $\reg J$, are controlled on the wire being non-zero, whereas open controls ($\circ$) are controlled on the wire being 0. The gates $+1$ and $-1$ denote increment and decrement in $\reg J$, respectively.
}
{
\[
R_1'\colon \quad
\begin{quantikz}
\lstick{$\cJ$}& \gate{+1}  & \ctrl{1} &  \gate{-1} & \qw\\
\lstick{$\cA$}& \ctrl[open]{-1} & \gate[2]{\Oref} & \ctrl[open]{-1} & \qw\\
\lstick{$\cW$}& \qw &  & \qw & \qw
\end{quantikz}
\qquad\qquad
R_2'\colon \quad
\begin{quantikz}
\lstick{$\cJ$}& \gate{+1}  & \ctrl{1} &  \gate{-1} & \qw\\
\lstick{$\cA$}& \ctrl{-1} & \gate[2]{-\Oref} & \ctrl{-1} & \qw\\
\lstick{$\cW$}& \qw &  & \qw & \qw
\end{quantikz}
\]
}

The following claim is similar to \rf{clm:simpleReflections}.

\begin{clm}
The operator $R_1'$ acts as identity on the states
\begin{equation}
\label{eqn:States1 NonReflected}
\ket |0>\ket|1>\ket|\phi_1>
\qqand 
\ket |j>\ket |0> \ket |\phi_0> + \gamma \ket |j+1>\ket |1> \ket |\phi_1>
\end{equation}
for all $j$.
The following states get reflected for all $j$:
\begin{equation}
\label{eqn:States1 Reflected}
\ket |j>\ket |0> \ket |\phi_0> - \gamma^{-1} \ket |j+1>\ket |1> \ket |\phi_1>.
\end{equation}

The operator $R_2'$ acts as identity on the states
\begin{equation}
\label{eqn:States2 NonReflected}
\ket |0>\ket|0>\ket|\phi_0>
\qqand
\ket |j>\ket |1> \ket |\phi_1> - \gamma \ket |j+1>\ket |0> \ket |\phi_0>
\end{equation}
for all $j$. 
It reflects the following states for all $j$:
\begin{equation}
\label{eqn:States2 Reflected}
\ket |j>\ket |1> \ket |\phi_1> + \gamma^{-1} \ket |j+1>\ket |0> \ket |\phi_0>.
\end{equation}
\end{clm}
\begin{proof}
We prove the statements for $R_1'$, as those for $R_2'$ are virtually identical. Since $\ket|0>\ket|1>\ket|\phi_1>$ has $\ket|0>\ket|1>$ in the first two registers, none of the controls is activated, and so all gates act as the identity. For any $j$, using $\gamma=\sqrt{p/(1-p)}$, and the fact that $\Oref$ fixes $\sqrt{1-p}\ket|0>\ket|\phi_0>+\sqrt{p}\ket|1>\ket|\phi_1>$,
\begin{align*}
    \ket|j>\ket|0>\ket|\phi_0>+\gamma\ket|j+1>\ket|1>\ket|\phi_1> &\overset{+1}{\longmapsto} \frac{\ket|j+1>}{\sqrt{1-p}}\left(\sqrt{1-p}\ket|0>\ket|\phi_0>+\sqrt{p}\ket|1>\ket|\phi_1>\right)\\
    &\overset{\Oref}{\longmapsto} \frac{\ket|j+1>}{\sqrt{1-p}}\left(\sqrt{1-p}\ket|0>\ket|\phi_0>+\sqrt{p}\ket|1>\ket|\phi_1>\right)\\
    &\overset{-1}{\longmapsto} \ket|j>\ket|0>\ket|\phi_0>+\gamma\ket|j+1>\ket|1>\ket|\phi_1>.
\end{align*}
Similarly, using the fact that $\Oref$ reflects $\sqrt{p}\ket|0>\ket|\phi_0>-\sqrt{1-p}\ket|1>\ket|\phi_1>$, 
\begin{align*}
    \ket|j>\ket|0>\ket|\phi_0>-\gamma^{-1}\ket|j+1>\ket|1>\ket|\phi_1> &\overset{+1}{\longmapsto} \frac{\ket|j+1>}{\sqrt{p}}\left(\sqrt{p}\ket|0>\ket|\phi_0>-\sqrt{1-p}\ket|1>\ket|\phi_1>\right)\\
    &\overset{\Oref}{\longmapsto} -\frac{\ket|j+1>}{\sqrt{p}}\left(\sqrt{p}\ket|0>\ket|\phi_0>-\sqrt{1-p}\ket|1>\ket|\phi_1>\right)\\
    &\overset{-1}{\longmapsto} -\left(\ket|j>\ket|0>\ket|\phi_0>-\gamma^{-1}\ket|j+1>\ket|1>\ket|\phi_1>\right).\qedhere
\end{align*}
\end{proof}

\myfigure{\label{fig:walkGeneral}}
{
As shown in Lemmata~\ref{lem:one} and~\ref{lem:two}, the purifier in this section can be seen as a quantum walk on two copies of the line in \rf{fig:line}. Just as in \rf{fig:line}, the weight of the edge between vertex $j$ and $j+1$, in either copy, is $\gamma^{2j}$ (not pictured).
The top line represents \rf{lem:one}, and the bottom one~\rf{lem:two}.
Below each edge, the state that encodes it in the quantum walk is written.
The pattern repeats with period 4.
Above the edge, the corresponding state of the register $\cH_0$ or $\cH_1$ from the proof of the corresponding lemma is given.
}
{
\negmedskip
\[
\def\nodegap{2.3}
\begin{tikzpicture}
\foreach \i in {0,1}
    \foreach \x in {0,...,5}
        \draw (\x*\nodegap, -\i*1.5) node[draw,shape=circle,inner sep=5] (\i\x) {} node {$\x$};
\draw (00) --node[below,blue] {$\ket|0>\ket|0>\ket|\phi_0>$} (01);
\draw (01) --node[below,blue] {$\ket|1>\ket|1>\ket|\phi_1>$} (02);
\draw (02) --node[below,blue] {$-\ket|2>\ket|0>\ket|\phi_0>$} (03);
\draw (03) --node[below,blue] {$-\ket|3>\ket|0>\ket|\phi_1>$} (04);
\draw (04) --node[below,blue] {$\ket|4>\ket|0>\ket|\phi_0>$} (05);
\draw (05) --node[below,blue] {$\ket|5>\ket|1>\ket|\phi_1>$} ++(\nodegap,0) node (06) {} +(0.5,0) node{$\cdots$};
\draw (10) --node[below,blue] {$\ket|0>\ket|1>\ket|\phi_1>$} (11);
\draw (11) --node[below,blue] {$-\ket|1>\ket|0>\ket|\phi_0>$} (12);
\draw (12) --node[below,blue] {$-\ket|2>\ket|1>\ket|\phi_1>$} (13);
\draw (13) --node[below,blue] {$\ket|3>\ket|0>\ket|\phi_0>$} (14);
\draw (14) --node[below,blue] {$\ket|4>\ket|1>\ket|\phi_1>$} (15);
\draw (15) --node[below,blue] {$-\ket|5>\ket|0>\ket|\phi_0>$} ++(\nodegap,0) node (16) {}+(0.5,0) node{$\cdots$};
\foreach \i in {0,1}
    \foreach \x [evaluate={\y=int(\x+1)}] in {0,...,5}
        \draw (\i\x) --node[red, above]{$\ket H_\i|\x>$} (\i\y);
\end{tikzpicture}
\]
}

The purifier $S'=R_2'R_1'$ can be understood as a quantum walk on a graph consisting of two (disjoint) lines, as described in \rf{fig:walkGeneral}. Concretely, in \rf{lem:one}, we show $\ket|0>\ket|0>\ket|\phi_0>\transduce{S}(-1)^b\ket|0>\ket|0>\ket|\phi_0>$, where $b=0$ of $p<1/2$ and $b=1$ if $p>1/2$; and a similar statement for $\ket|0>\ket|0>\ket|\phi_1>$ in \rf{lem:two}; and finally, in \rf{thm:mainInfinite}, we combine these to show that $\ket|0>\ket|\phi>\transduce{S}(-1)^b\ket|0>\ket|\phi>$, proving the main theorem of this section.

\begin{lem}
\label{lem:one}
In the above notation, the transducer $S'$, given an input oracle $\Oref$ satisfying~\rf{eqn:OrefGeneral}, has the following transduction action:
\begin{equation}
\label{eqn:1 transduction}
S'\colon \ket |0>\ket|0>\ket|\phi_0> \transduce{} 
\begin{cases}
\ket |0>\ket|0>\ket|\phi_0>, &\text{if $p < \tfrac 12$;}\\
- \ket |0>\ket|0>\ket|\phi_0>, &\text{if $p > \tfrac 12$;}
\end{cases}
\end{equation}
and the query complexity and transduction complexity of $S'$ are $L(S', \Oref, \ket |0>\ket |0> \ket |\phi_0>)=1/(2\delta)$ and $W(S'(\Oref),\ket |0>\ket |0> \ket |\phi_0>)\leq 1/(2\delta)$, where $\delta = |\frac12 - p|$.
\end{lem}
\begin{proof}
Define the following conceptual register $\reg H_0$ spanned by the states
\begin{align*}
\ket H_0|4i> &= \ket|4i>\ket|0>\ket|\phi_0>,\\
\ket H_0|4i+1> &= \ket|4i+1>\ket|1>\ket|\phi_1>,\\
\ket H_0|4i+2> &= -\ket|4i+2>\ket|0>\ket|\phi_0>,\\
\ket H_0|4i+3> &= -\ket|4i+3>\ket|1>\ket|\phi_1>,
\end{align*}
as $i$ ranges over non-negative integers (see \rf{fig:walkGeneral}).
It is easy to check, using~\rf{eqn:States1 NonReflected} and~\rf{eqn:States1 Reflected}, that $R_1'$ acts as identity on the states
\begin{equation}
\label{eqn:1 NonReflected}
\ket H_0 |j> + \gamma \ket H_0 |j+1>
\end{equation}
for even values of $j$,
and it reflects the states
\begin{equation}
\label{eqn:1 Reflected}
\ket H_0 |j> - \gamma^{-1} \ket H_0|j+1>
\end{equation}
for even values of $j$.
Similarly, using~\rf{eqn:States2 NonReflected} and~\rf{eqn:States2 Reflected}, we get that $R_2'$ acts as identity on $\ket H_0|0>$ and on the states in~\rf{eqn:1 NonReflected} for odd values of $j$, and reflects the states in~\rf{eqn:1 NonReflected} for odd values of $j$.

Comparing this with \rf{clm:simpleReflections}, we get that the action of $R_2'R_1'$ on $\cH_0$ is identical to that of $R_2R_1$ from \rf{sec:SimpleInfinite}, which proves the lemma.
\end{proof}


\begin{lem}
\label{lem:two}
In the above notation, the transducer $S'$, given an input oracle $\Oref$ satisfying~\rf{eqn:OrefGeneral}, has the following transduction action: 
\begin{equation}
\label{eqn:2 transduction}
S'\colon \ket |0>\ket|1>\ket|\phi_1> \transduce{} 
\begin{cases}
 \ket |0>\ket|1>\ket|\phi_1>, &\text{if $p < \tfrac 12$;}\\
-\ket |0>\ket|1>\ket|\phi_1>, &\text{if $p > \tfrac 12$;}
\end{cases}
\end{equation}
and the query complexity and transduction complexity of $S'$ are $L(S', \Oref, \ket |0>\ket |1> \ket |\phi_1>)=1/(2\delta)$ and $W(S'(\Oref), \ket |0>\ket |1> \ket |\phi_1>)\leq 1/(2\delta)$, where $\delta = |\frac12 - p|$.
\end{lem}

\begin{proof}
This time, define the following conceptual register $\reg H_1$ spanned by the states
\begin{align*}
\ket H_1|4i> &= \ket|4i>\ket|1>\ket|\phi_1>,\\
\ket H_1|4i+1> &= -\ket|4i+1>\ket|0>\ket|\phi_0>,\\
\ket H_1|4i+2> &= -\ket|4i+2>\ket|1>\ket|\phi_1>,\\
\ket H_1|4i+3> &= \ket|4i+3>\ket|0>\ket|\phi_0>,
\end{align*}
as $i$ ranges over non-negative integers (see \rf{fig:walkGeneral}).
Using~\rf{eqn:States2 NonReflected} and~\rf{eqn:States2 Reflected}, 
it is not hard to check that $R_2'$ acts as identity on the states
\begin{equation}
\label{eqn:2 NonReflected}
\ket H_1 |j> + \gamma \ket H_1 |j+1>
\end{equation}
for even values of $j$,
and it reflects the states
\begin{equation}
\label{eqn:2 Reflected}
\ket H_1 |j> - \gamma^{-1} \ket H_1|j+1>
\end{equation}
for even values of $j$.
Similarly, we get that $R_1'$ acts as identity on $\ket H_1|0>$ and on the states in~\rf{eqn:1 NonReflected} for odd values of $j$, and reflects the states in~\rf{eqn:1 NonReflected} for odd values of $j$.

Comparing this with \rf{clm:simpleReflections}, we get that the action of $R_2'R_1'$ on $\cH_1$ is identical to that of $R_1R_2$ from \rf{sec:SimpleInfinite}.
The lemma follows by \rf{rem:SimpleOrder}.
\end{proof}


\begin{thm}
\label{thm:mainInfinite}
The transducer $S'$ defined above, given an input oracle $\Oref$ satisfying~\rf{eqn:OrefGeneral}, has the following transduction action:
\begin{equation}
\label{eqn:mainInfinite}
S' \colon \ket |\phi> \transduce{} 
\begin{cases}
\ket |\phi>, &\text{if $p < \tfrac 12$;}\\
- \ket |\phi>, &\text{if $p > \tfrac 12$;}
\end{cases}
\end{equation}
for any normalised $\ket|\phi> \in \spn\sfigA{\ket|0>\ket|\phi_0>, \ket|1>\ket|\phi_1>}$ (including the original vector $\ket|\phi>$ from~\rf{eqn:InputOracle}).
The query complexity of the transducer is $L(S',\Oref,\ket |\phi>)=1/(2\delta)$, and the transduction complexity is $W(S'(\Oref),\ket |\phi>) = \OO(1/\delta)$, where $\delta = |\tfrac12 - p|$.

The transducer can be put in canonical form so that its query complexity stays the same, and its transduction complexity remains $\OO(1/\delta)$. \end{thm}

\begin{proof}
We identify $\ket|0>\otimes \cA\otimes \cW$, which is the public space of the transducer $S'$, with $\cA\otimes \cW$.
Let $r = 0$ if $p<1/2$; and $r=1$ if $p>1/2$.
By \rf{lem:one}, we have $\ket|0>\ket|\phi_0>\transduce{S'} (-1)^r \ket|0>\ket|\phi_0>$ with some query state $\ket|q_0>$ that is supported only on $\cH_0$.
Similarly, by \rf{lem:two}, we have $\ket|1>\ket|\phi_1>\transduce{S'} (-1)^r \ket|1>\ket|\phi_1>$ with some query state $\ket|q_1>$ that is supported only on $\cH_1$.
The norms squared of both $\ket|q_0>$ and $\ket|q_1>$ are $1/(2\delta)$.

By linearity, for all $\alpha, \beta$ we have that
\[
\alpha \ket|0> \ket|\phi_0> + \beta \ket|1> \ket|\phi_1> 
\transduce{S'} 
(-1)^r\sA[\alpha \ket|0> \ket|\phi_0> + \beta \ket|1> \ket|\phi_1>] 
\]
with the query state $\alpha \ket|q_0> + \beta \ket|q_1>$.
Since $q_0$ and $q_1$ are supported on orthogonal subspaces, we have that the query complexity of the transducer is
\[
\normA |{\alpha \ket|q_0> + \beta \ket|q_1>}|^2 = |\alpha|^2 \|q_0\|^2 + |\beta|^2 \|q_1\|^2 = 1/(2\delta)
\]
assuming $|\alpha|^2 + |\beta|^2 = 1$. 

By \cite[Proposition 10.4]{belovs:taming}, we can transform $S'$ into a canonical transducer $S''$ while keeping the query complexity the same. The iteration time goes up by at most a constant factor, and the transduction complexity increases slightly to 
\begin{equation*} W(S''(\Oref),\ket |\phi>)=W(S'(\Oref),\ket |\phi>)+L(S',\Oref,\ket |\phi>) = \OO(1/\delta).\qedhere\end{equation*}
\end{proof}

It is straightforward to obtain the purifier in the usual form similar to the one stated in  Eqs.~\rf{eqn:InputOracle} and~\rf{eqn:ErrorReduction}.

\mycutecommand{\purifier}{S_{\mathrm{pur}}}
\mycutecommand{\Sref}{S_{\mathrm{ref}}}
\begin{cor}\label{cor:InputOracleErrorReduction}
There exists a transducer $\purifier$ with bidirectional access to an input oracle as in~\rf{eqn:InputOracle}, which performs the following transduction exactly:
\[
\purifier(O)\colon \ket A|0> \transduce{}
\begin{cases}
\ket A|0>, &\text{if $p < \tfrac 12$;}\\
\ket A|1>, &\text{if $p > \tfrac 12$.}
\end{cases}
\]
The query complexity $L\sA[\purifier, O, \ket|0>]$ of the transducer and is $1 + 1/(2\delta)$, where $\delta = \absA|\tfrac12 - p|$, and its transduction complexity is $\OO(1/\delta)$.
\end{cor}
\begin{proof}
The corollary is proven in the same way one would convert an algorithm with the action of $S'$ in \rf{eqn:mainInfinite} to an algorithm with the action of $\purifier$.

First, it is straightforward to implement the reflecting oracle $\Oref$ using 2 queries to $O$.
Hence, there exists a canonical transducer $\Sref$ -- just take $\Oref$ itself, and convert it into canonical form using \cite[Proposition~10.4]{belovs:taming} -- that implements $\Oref$ with query complexity $L(\Sref,O,\xi)=2$ on any normalized initial state $\xi$, and $W(\Sref,O,\xi) = \OO(1)$. 
Let $S'$ be the canonical purifier from \rf{thm:mainInfinite}. By \cite[Proposition 9.11]{belovs:taming} (see also the discussion in~\rf{sec:prelim})
there is a canonical purifier $\purifier'=S'\circ\Sref$ with the action 
$$\ket |\phi>\transduce{\purifier'} (-1)^r\ket |\phi>,$$
where $r=0$ if $p<1/2$ and $r=1$ if $p>1/2$, and with query and transduction complexities 
$$L(\purifier',O,\ket |\phi>)=2/(2\delta)=1/\delta
\quad\mbox{and}\quad
W(\purifier'(O),\ket |\phi>)=\OO(1/\delta).$$

We will construct $\purifier$ by composing a purifier $S_A$ with $\purifier'$, again using \cite[Proposition 9.11]{belovs:taming}.
The transducer $S_A$ first applies a Hadamard to a fresh qubit to get $\ket |0>\mapsto \ket |0>\ket |+>$, and then proceeds as follows:
\[
\frac1{\sqrt 2} \sA[\ket|0>\ket|0> + \ket|0>\ket|1>]
\mapsto
\frac1{\sqrt 2} \sA[\ket|0>\ket|0> + \ket|\phi>\ket|1>]
\mapsto{}
\frac1{\sqrt 2} \sA[\ket|0>\ket|0> +(-1)^r \ket|\phi>\ket|1>]
\mapsto
\frac1{\sqrt 2} \sA[\ket|0>\ket|0> +(-1)^r \ket|0>\ket|1>].
\]
In the first step, we execute $O$ controlled by the second register.
In the second step, we apply an oracle $O'$, implemented by the transducer $\purifier'$, controlled by the second register.
In the third step, we execute $O^*$ controlled by the second register.
After that, we apply another Hadamard, resulting in $\ket|r>$. Then the query complexity of $S_A$ in terms of calls to $O$ and $O^*$ (which we can combine into a single oracle $O\oplus O^*$) is:
$$L^{(0)}(S_A,(O\oplus O^*)\oplus O',\ket |0>) = \frac{1}{2}+\frac{1}{2}=1,$$
since $O\oplus O^*$ is called twice, and each time, the query part has size ${1}/{2}$. 
Similarly, the query complexity of $S_A$ in terms of calls to $O'$ is:
$$L^{(1)}(S_A,(O\oplus O^*)\oplus O',\ket |0>) = \frac{1}{2},$$
since $O'$ is applied once, and the query part of the state it's applied to has size $1/2$. By \cite[Proposition 10.4]{belovs:taming}, we can put $S_A$ in canonical form without changing these query complexities, and such that the transduction complexity is $\OO(1)$. 
Thus, by \cite[Proposition~9.11]{belovs:taming}, $\purifier=S_A\circ \purifier'$ has query and transduction complexities:
\begin{equation*}
L(\purifier,O,\ket |0>) = 1+\frac{1}{2}L(\purifier',O,\ket |\phi>) = 1+\frac{1}{2\delta}
\quad\mbox{and}\quad
W(\purifier(O),\ket |0>) = \OO(1/\delta).\qedhere
\end{equation*}
\end{proof}



\section{Time-Efficient Implementation}
\label{sec:time-efficient}
The transducers of {\rf{thm:simple}} and~\rf{thm:mainInfinite} cannot be implemented directly because they use a register $\reg J$ of infinite size. This is conceptually not that different from a (classical) Las Vegas algorithm that has unbounded running time, and so to run it, you theoretically need an infinite register to count its steps. 

One approach to obtaining a practical implementation is to replace the register $\reg J$ with a $D$-dimensional register, for some finite $D$, and it makes sense to take $D$ to be a power of two.
We will call it the truncated version (at depth $D$) of the purifier.
The truncated version of the purifier $S$ from \rf{thm:simple} is the same as \rf{fig:simple}, but now $\reg J$ stores an integer between $0$ and $D-1$ and the operations are performed modulo $D$. 
Similarly, the truncated version of the purifier $S'$ is as in \rf{fig:general}, with the same replacement for the register $\reg J$.

The following claim is obvious.
\begin{clm}
The truncated versions of both purifiers $S$ and $S'$ use $\log D$ qubits besides the space used by the input oracle $\Oref$.
Iteration times $T(S)$ and $T(S')$ are $\OO(\log D)$.
\end{clm}

There are two ways to show that the truncated purifiers still work if $D$ is large enough.
For the first one, recall that an algorithm obtained by compiling a transducer $S$ makes $K$ calls to $S$, starting with the public space containing the initial vector and the private space containing the zero vector (see \rf{thm:transducer-algorithm}).

\begin{prp}
Assume a purifier  
is executed $K$ times during its implementation.
Then, if $D > K$, the actions of the truncated and the original versions of the purifier are identical.
\end{prp}




\begin{proof}
The public space of the purifier is spanned by $\ket J|0>$.
It is easy to see that after $\ell$ executions of the purifier, its state only uses states spanned by $\ket J|0>, \ket J|1>, \dots, \ket J|\ell>$.
Therefore, the truncated and the original purifiers perform in exactly the same way for all $\ell < D$.
\end{proof}

The following version uses the notion of a perturbation and is slightly more precise.
\rf{thm:main} from the introduction is a corollary of this result.

\begin{thm}
\label{thm:mainFormal}
The statements of Theorems \ref{thm:simple} and \ref{thm:mainInfinite} hold after replacing $S$ and $S'$ by their versions truncated at depth $D$, if we allow for a perturbation of size $2(1-\delta)^{D-1}$ in the transducer, and claim that the query and transduction complexities are smaller than $1/(2\delta)$ (instead of being exactly equal).
\end{thm}

\begin{proof}
We assume that $D\ge 4$ is a power of 2.

For \rf{thm:simple}, it is easy to get the following variant of \rf{clm:simpleReflections} for the truncated transducer, whose proof we omit.

\begin{clm}
For all even $j=0,2,\dots, D-2$, we have $R_1 u_j = u_j$ and $R_1 u_j^\perp = -u_j^\perp$.
Also, $R_2\ket|0> = \ket |0>$, and $R_2\ket |D-1> = \ket |D-1>$.
For all odd $j=1,2,\dots, D-3$, $R_2 u_j = u_j$ and $R_2 u_j^\perp = -u_j^\perp$.
\end{clm}

For $p<\frac12$, we have the following version of~\rf{eqn:SimpleSequence1}, with no perturbations
\[
\begin{aligned}
&\sum_{j=0}^{D-1} \gamma^j \ket |j> = \sum_{i=0}^{D/2-1} \gamma^{2i} \sA[\ket |2i> + \gamma \ket |2i+1>]\\
\maps{R_1} & 
\sum_{j=0}^{D-1} \gamma^j \ket |j>
= \ket |0> + \sum_{i=0}^{D/2-2} \gamma^{2i+1} \sA[\ket |2i+1> + \gamma \ket |2i+2>] + \gamma^{D-1}\ket |D-1>\\
\maps{R_2}&
\sum_{j=0}^{D-1} \gamma^j \ket |j>.
\end{aligned}
\]

For $p > \frac 12$, we have the following version of~\rf{eqn:SimpleSequence2}:
\[
\begin{aligned}
&\sum_{j=0}^{D-1} (-\gamma)^{-j} \ket |j> 
= \sum_{i=0}^{D/2-1} \gamma^{-2i} \sA[\ket |2i> - \gamma^{-1} \ket |2i+1>]\\
\maps{R_1} & 
-\sum_{j=0}^{D-1} (-\gamma)^{-j} \ket |j>
= -\ket |0> + \sum_{i=0}^{D/2-2} \gamma^{-2i-1} \sA[\ket |2i+1> - \gamma^{-1} \ket |2i+2>] + \gamma^{-D+1} \ket|D-1>\\
\maps{R_2}&
-\ket |0> - \sum_{i=0}^{D/2-2} \gamma^{-2i-1} \sA[\ket |2i+1> - \gamma^{-1} \ket |2i+2>] + \gamma^{-D+1} \ket|D-1>\\
\approx&
-\ket |0> - \sum_{i=0}^{D/2-2} \gamma^{-2i-1} \sA[\ket |2i+1> - \gamma^{-1} \ket |2i+2>] - \gamma^{-D+1} \ket|D-1>
= - \ket|0> + \sum_{j=1}^{D-1} (-\gamma)^{-j} \ket |j>,
\end{aligned}
\]
where the ``$\approx$'' represents a perturbation (as in \rf{eqn:perturbation}) of size $2\gamma^{-D+1} \le 2(1-\delta)^{D-1}$.
The rest of the proof of \rf{thm:simple} stays the same except that the query complexity in both cases becomes slightly smaller.

The proof of \rf{thm:mainInfinite} is modified in a similar way via a reduction to the truncated version of the purifier $S$.
\end{proof}


\section{Query-Efficient Implementation}
\label{sec:query-efficient}

A well-studied and very general type of problem in quantum query complexity is that of state conversion~\cite{lee:stateConversion, belovs:variations}.
There it is assumed that a \emph{finite} set $X$ and two Hilbert spaces $\cM$ and $\cH$ are fixed. 
For each $x\in X$, the input oracle $O_x\colon \cM\to\cM$ and a pair of states $\xi_x, \tau_x\in \cH$ are given.
The task is to construct an algorithm $A$ that satisfies $A(O_x) \xi_x = \tau_x$ for all $x \in X$.

The query complexity of this problem is captured by the corresponding adversary bound.
As shown in~\cite{belovs:LasVegas, belovs:taming}, the adversary bound is identical to a transducer in canonical form.
Let us briefly repeat the argument here.
Let $\cL = \cL^\circ \oplus \cL^\bullet$ be the decomposition of the private space into the non-query and the query parts, where $\cL^\bullet = \cM\otimes \cW$ for some space $\cW$.
By the definition of canonical form, $v_x = v_x^\circ \oplus v_x^\bullet$ is a valid catalyst for $\xi_x$ if there exists a unitary $S^\circ$ such that
\begin{equation}
\label{eqn:query1}
S^\circ \colon \xi_x \oplus v_x^\circ \oplus (O_x\otimes I_\cW) v_x^\bullet
\maps{}
\tau_x \oplus v_x^\circ \oplus v_x^\bullet
\end{equation}
for all $x\in X$ (see \rf{eqn:canonical}).
Moreover, the states $v_x^\bullet$ are the corresponding query states, and $\|v_x^\bullet\|^2$ are the corresponding query complexities.

It is easy to see that the existence of the unitary $S^\circ$ is equivalent to the following condition
\begin{equation}
\label{eqn:query2}
\ip<\xi_x, \xi_y> - \ip<\tau_x, \tau_y> = \ip<v_x^\bullet, v_y^\bullet> - \ipA<(O_x\otimes I_\cW)v_x^\bullet, (O_y\otimes I_\cW) v_y^\bullet>
\end{equation}
for all $x,y\in X$.
In particular, the non-query parts $v_x^\circ$ of the catalyst are irrelevant and can be removed 
if one only cares about query complexity.  This means that any non-query parts of the catalyst are purely for keeping the overall time complexity small.

Thus, the transducers from Theorems~\ref{thm:simple} and \ref{thm:mainInfinite} and \rf{cor:InputOracleErrorReduction} give rise to solutions to equation~\rf{eqn:query2} for the corresponding state conversion problems.
In all these cases, the space $\cW$ is infinite by construction.
However, \emph{assuming that $X$ is finite}, which is a common assumption in the state conversion problem, we can restrict the space $\cW$ to have dimension at most $|X|$, which is finite.
This gives the corresponding query-efficient transducer that performs the required transformation exactly and only uses finite space.
It also gives a solution to the corresponding adversary bound.

In~\cite{belovs:variations}, purifiers were used to show that the adversary bound for bounded-error function evaluation is equal (up to a constant factor) to the adversary bound for exact function evaluation.
This demonstrated that the usual adversary bound for function evaluation (which works assuming bounded error) is a special case of that for the state conversion problem.
The transducers obtained in this section can be used instead of the purifiers of~\cite{belovs:variations}, and they give a better dependence on $\delta$.



\section{Lower Bound}
\label{sec:lower-bound}

In this section, we will give an almost tight lower bound on the query complexity of a purifier, showing that \rf{thm:mainFormal} (the formal version of \rf{thm:main}) is nearly optimal. 

Consider the following input oracles in $\bC$:
\[
O_x\colon \ket |0> \mapsto (-1)^x \ket|0>,
\]
where $x\in\bool$.
The oracle $O_x$ is inverse to itself, so there is no difference between direct and reverse executions of $O_x$ in this case.

Trivially, the Las Vegas query complexity of implementing $O_x$ given the input oracle $O_x$ is at most 1.
This is also a lower bound.
This can be proven using the adversary lower bound from~\cite{belovs:taming}.
However, this can also be seen directly using the following simple argument.
If the complexity were $c<1$, we could compose the corresponding procedure with itself $n$ times, obtaining implementation of $O_x$ in query complexity $c^n\to 0$ as $n\to\infty$, which is absurd.

Consider the following state:
\[
\ket |\varphi_x> = \sqrt{\frac12 - \delta} \ket |00> + \sqrt{\frac 12 - \delta} \ket |10> + \sqrt{2\delta} \ket|x>\ket |1>,
\]
which has amplitude $\sqrt{1/2+\delta}$ on $x$ in the first qubit.
It can be generated in Las Vegas query complexity $\delta$ as follows. Beginning from the state $\ket |\psi_1>=\sqrt{1-2\delta}\ket |0>\ket |0>+\sqrt{2\delta}\ket |+>\ket |1>$, 
perform a query controlled on $\ket |1>\ket |1>$, on which the state has squared norm $\delta$, to get:
\begin{equation*}
    \sqrt{1-2\delta}\ket{}|0>\ket{}|0>+\sqrt{2\delta}\left(\frac{1}{\sqrt{2}}\ket |0> + (-1)^x\frac{1}{\sqrt{2}}\ket |1>\right)\ket |1>.
\end{equation*}
Applying $H$ to the first register then gives $\ket |\varphi_x>$. Since the only query was applied to $\ket |\psi_1>$, and its projection onto $\ket |1>\ket |1>$, the query part of the space, has squared norm $\delta$, the total Las Vegas query complexity of this procedure is $\delta$. 

Therefore, the oracle $\Oref$ reflecting about $\ket |\varphi_x>$ can be implemented in Las Vegas query complexity $2\delta$.
Let $Q_p$ be the query complexity of the transformation $\ket |\varphi_x> \mapsto (-1)^x \ket |\varphi_x>$, in terms of queries to $\Oref$, with parameter $\delta$.
We can implement $O_x$ as follows.
Generate the state $\ket |\varphi_x>$ in query complexity $\delta$.  
Map it to $(-1)^x \ket |\varphi_x>$ in $Q_p$ queries to $\Oref$, each costing $2\delta$ query complexity.
Map it back to $(-1)^x\ket |0>$ in query complexity $\delta$.
The query complexity of this procedure is
\[
2\delta + Q_p 2\delta.
\]
It is at least 1 by our above discussion, so we obtain the following result.
\begin{thm}
The query complexity of any transducer performing the task in \rf{thm:mainFormal} is at least
\[
\frac{1}{2\delta} - 1.
\]
\end{thm}
For small $\delta$, this is close to the query complexity $1/(2\delta)$ obtained in \rf{thm:mainFormal}.




\section{Error Reduction using Quantum Signal Processing}
\label{sec:QSP}

In this section, we describe an error reduction algorithm using quantum signal processing.
To the best of our knowledge, this particular version has not been previously stated explicitly, however, very similar constructions have been considered in previous work -- see \cite[Section 3]{gilyen:quantumSingularValueTransformation}.
We were particularly inspired by the discussion in~\cite{rall:phaseEstimation}.
Note that we are using usual Quantum Signal Processing~\cite{low:quantumSignalProcessing} directly here like in~\cite{low:HamiltinianBySpectralAmplification}, and not the more elaborate framework of Quantum Singular Value Transformation~\cite{gilyen:quantumSingularValueTransformation} here. 
This streamlined construction uses no additional ancillary qubits, whereas \cite{gilyen:quantumSingularValueTransformation} require a small number, and our construction works with oracles of the form in \rf{eqn:OrefGeneral}, whereas \cite{gilyen:quantumSingularValueTransformation} requires oracles of the form~\rf{eqn:InputOracle}.

\subsection{Quantum Signal Processing Preliminaries}

Let $x$ and $y$ be real numbers satisfying
\[
-1 \le x,y \le 1
\qqand
x^2 + y^2 = 1.
\]
Define the following unitary transformation%
\footnote{Traditionally, a more complex matrix
$\begin{psmallmatrix} x & \ii y \\ \ii y & x \end{psmallmatrix}$ is used.
The two are equivalent up to a simple change of basis.
We implicitly use this basis further in the text.
}
\begin{equation}
\label{eqn:QSP Signal}
W = W(x,y) = \begin{pmatrix}
x & y \\ y & -x
\end{pmatrix}.
\end{equation}

Let $\alpha = (\alpha_0, \alpha_1, \dots, \alpha_k)$ be a sequence of unimodular complex numbers: $|\alpha_j| = 1$ for all $j$.
Then, the \emph{quantum signal processing} algorithm (QSP) corresponding to $\alpha$ is the following $k$-query quantum algorithm $ U_\alpha = 
U_\alpha(W) $ with an input oracle $W\colon \bC^2\to\bC^2$:
\begin{equation}
\label{eqn:QSP}
U_\alpha (W) = 
\begin{pmatrix}
\alpha_k \\ & -\alpha_k^*
\end{pmatrix}
W
\begin{pmatrix}
\alpha_{k-1} \\ & -\alpha_{k-1}^*
\end{pmatrix}
W
\cdots
W
\begin{pmatrix}
\alpha_{1} \\ & -\alpha_{1}^*
\end{pmatrix}
W
\begin{pmatrix}
\alpha_{0} \\ & -\alpha_{0}^*
\end{pmatrix}.
\end{equation}
Here $\alpha^*$ stands for the complex conjugate of a complex number $\alpha$.

\begin{thm}[\cite{gilyen:quantumSingularValueTransformation}]
\label{thm:QSP}
For any sequence $\alpha = (\alpha_0, \alpha_1, \dots, \alpha_k)$ of unimodular complex numbers, there exist complex polynomials $P(x)$ and $Q(x)$ satisfying the following conditions:
\begin{align}
\deg P &\le k,&  \deg Q &\le k-1, \label{eqn:QSP degree}\\
P(-x) &= (-1)^k P(x),& Q(-x) &= (-1)^{k-1} Q(x), \label{eqn:QSP parity}
\end{align}
%and
\begin{equation}
\label{eqn:QSP condition}
P(x) P^*(x) + Q(x) Q^*(x) (1-x^2) = 1
\end{equation}
and such that
\begin{equation}
\label{eqn:QSP main}
U_\alpha \sA[W(x,y)] = 
\begin{pmatrix}
P(x) & y Q^*(x) \\
y Q(x) & - P^*(x)
\end{pmatrix}.
\end{equation}
And vice versa: for every complex polynomials $P(x)$ and $Q(x)$ and a non-negative integer $k$ satisfying~\rf{eqn:QSP degree},~\rf{eqn:QSP parity} and~\rf{eqn:QSP condition}, there exists a sequence $\alpha = (\alpha_0, \alpha_1, \dots, \alpha_k)$ of unimodular complex numbers such that~\rf{eqn:QSP main} holds.
\end{thm}

\begin{thm}[\cite{gilyen:quantumSingularValueTransformation}]
\label{thm:ABC}
Let $R$ be a real polynomial and $k$ a positive integer satisfying
\[
\deg R \le k
,\qquad
R(-x) = (-1)^k R(x),
\]
and
\[
|R(x)| \le 1 \qquad \text{for all\quad $-1\le x\le 1$.}
\]
Then, there exist complex polynomials $P$ and $Q$ satisfying~\rf{eqn:QSP degree}--\rf{eqn:QSP condition} and such that $R(x) = \Re (P(x))$, where $\Re$ stands for the real part.
\end{thm}

\begin{thm}[\cite{low:HamiltinianBySpectralAmplification}]
\label{thm:polynomials}
Let $0 < \eps', \delta' < 1$ be parameters.
There exists an odd real polynomial $R(x)$ of degree $\OO\sA[\frac 1{\delta'} \log \frac 1{\eps'}]$ such that
\begin{alignat}{3}
|R(x)| &\le 1  &&\text{for all}\qquad&  -1 &\le x \le 1; \notag\\ 
R(x) &\ge 1-\eps' &&\text{for all}&  \delta' &\le x \le 1 ;\quad \text{and} \label{eqn:polynomials condition}\\
R(x) &\le -1+\eps'\qquad &&\text{for all}& -1 &\le x \le -\delta' \label{eqn:polynomials condition2} .
\end{alignat}
\end{thm}


\subsection{Proof of \rf{thm:ErrorReduction}}
We will work in the two-dimensional subspace $\cH$ given by the basis vectors $\ket H|0> = \ket A|0>\ket W|\phi_0>$ and $\ket H|1> = \ket A|1> \ket W|\phi_1>$.
By~\rf{eqn:OrefGeneral}, the operator $\Oref$ performs reflection about $\sqrt{1-p} \ket |0> + \sqrt{p}\ket|1>$ in this space.
Hence, in $\cH$, the operator $\Oref$ is given by the matrix
\[
\begin{pmatrix}
1-2p & 2\sqrt{p(1-p)} \\
2\sqrt{p(1-p)} & 2p-1
\end{pmatrix}.
\]
Comparing with~\rf{eqn:QSP Signal}, we have $x = 1-2p$ and $y = 2\sqrt{p(1-p)}$.
Thus, $x\ge 2\delta$ if $p\le \frac12-\delta$ and $x \le -2\delta$ if $p\ge \frac12 + \delta$.

Take the real polynomial $R$ of \rf{thm:polynomials} with $\delta' = 2\delta$ and $\eps'$ to be fixed later.
Find the complex polynomials $P$ and $Q$ by \rf{thm:ABC} applied to $R$ and $k=\deg R$.
Plug them into \rf{thm:QSP} to get a sequence $\alpha = (\alpha_0,\dots,\alpha_k)$ such that~\rf{eqn:QSP main} holds.
We apply the Quantum Signal Processing algorithm $U_\alpha$ from~\rf{eqn:QSP} in $\cH$ by replacing $W$ with $\Oref$ and applying the intermediate operations 
$\begin{psmallmatrix} \alpha_{j} \\ & -\alpha_{j}^* \end{psmallmatrix}$ 
to the register $\cA$.
After that, we apply the $Z$ operator to $\cA$.
By \rf{thm:QSP}, the resulting action of this algorithm on $\cH$ is
\[
U(p) = \begin{pmatrix}
P(x) & y Q^*(x) \\
-y Q(x) & P^*(x)
\end{pmatrix}.
\]
Let $P(x) = R(x) + \ii S(x)$ for a real polynomial $S$.
Note that if $p \le \tfrac12 -\delta$, then
\[
\norm |U(p) - I| = 
\norm|\begin{pmatrix}
R(x)-1 + \ii S(x) & y Q^*(x) \\
-y Q(x) & R(x)-1 -\ii S(x)
\end{pmatrix}| \le \sqrt{6\eps'},
\]
since $|1-R(x)|^2 \le (\eps')^2$ by~\rf{eqn:polynomials condition} and $|S(x)|^2 + |yQ(x)|^2 \le 2\eps'$ by~\rf{eqn:QSP condition}.
Similarly, using~\rf{eqn:polynomials condition2}, we have that if $p\ge \frac12 + \delta$, then
\[
\norm |U(p) + I| \le \sqrt{6\eps'}.
\]
Letting $r=0$ if $p\le \frac12-\delta$ and $r=1$ if $p\le \frac12+\delta$, we obtain
\[
\norm |{ U(p)\ket|\phi> - (-1)^r\ket|\phi> }|\le \sqrt{6\eps'}.
\]
Therefore, we can take $\eps' = \eps^2/6$ to obtain the required precision of the algorithm.

The number of queries and time complexity of the algorithm is $\OO(\deg R)$, which is
$O\sA[\frac1{\delta'} \log \frac1{\eps'}]=
O\sA[\frac1{\delta} \log \frac1{\eps}]$
as required.


\section{Non-Boolean Case}\label{sec:non-Boolean}

In this section, we briefly describe the non-Boolean error reduction case, which can be reduced to the Boolean case using the ``Bernstein-Vazirani'' trick from~\cite[Section~4]{jeffery:kDist}.
In the non-Boolean case, the output register $\cA$ is a tensor product of $m$ qubits.
We write $\cA = \bC^q$ for some $q = 2^m$.
For $a,b\in \{0,\dots,q-1\}$, we denote by $a\odot b\in\{0,1\}$ their inner product when considered as elements of $\bF_2^m$.
The work register $\reg W$ is still arbitrary.

We assume the input oracle $\Oref$ reflects about the state
\begin{equation}
\label{eqn:NB phi}
\ket|\phi> = \sum_{a=0}^{q-1} \sqrt{p_a} \ket A|a> \ket W|\phi_a>
\end{equation}
for normalised $\phi_a$.
Moreover, there exists a (unique) $r$ such that $p_r \ge \frac12 + \delta$.
The task is to perform the transformation
\begin{equation}
\label{eqn:NB ErrorReduction}
\ket |\phi> \ket B|0> \maps{} \ket |\phi>\ket B|r>,
\end{equation}
where $\reg B$ is a register isomorphic to $\reg A$. The idea is that, using a Boolean error reduction procedure, we can error reduce with respect to the state
\begin{equation*}
\ket C|0>\sum_{a:a\odot b=0}\sqrt{p_a}\ket A|a>\ket W|\phi_a>
+\ket C|1>\sum_{a:a\odot b=1}\sqrt{p_a}\ket A|a>\ket W|\phi_a>
\end{equation*}
for any $b\in\{0,1\}$, which gives us a reflection oracle for the function $b \maps{} b\odot r$, as needed by the Bernstein-Vazirani algorithm~\cite{bernstein:quantumComplexity},
from which we can recover $r$ with a single query (see \rf{fig:BV-circuit}).

\begin{thm}
\label{thm:NB}
Let $R$ be a Boolean error reduction subroutine that, given the oracle as in~\rf{eqn:Oref}, performs the transformation in~\rf{eqn:ErrorReductionSign} (possibly with imprecision $\eps$). 
Then, there exists an algorithm that, given an input oracle $\Oref$ reflecting about the state~\rf{eqn:NB phi}, implements the transformation in~\rf{eqn:NB ErrorReduction} (with imprecision $\eps$).
The algorithm makes one execution of $R$, uses one additional qubit and $\OO(m)$ additional elementary operations.
\end{thm}

\myfigure{\label{fig:BV-circuit}}
{
Assuming $R(T\Oref'T^*)$ has no error, the operations in the dashed box effectively implement the Bernstein-Vazirani oracle for $r$ the hidden string: $\ket B|b>\ket C|0> \ket AW|\phi> \maps{} (-1)^{r\odot b}\ket B|b>\ket C|0> \ket AW|\phi>$.
}
{
\[
\begin{quantikz}
\lstick{$\cB$}& \gate{H^{\otimes m}}  & \gate[3]{T}\gategroup[4,steps=3,style={dashed}]{} &  \qw & \gate[3]{T^*} & \gate{H^{\otimes m}} & \qw\\
\lstick{$\cC$}& \qw &  & \gate[3]{R(T\Oref'T^*)} & & \qw & \qw\\
\lstick{$\cA$} & \qw &  & & & & \qw\\
\lstick{$\cW$}& \qw & \qw &  & \qw & \qw &\qw
\end{quantikz}
\]
}

\begin{proof}
We attach a fresh qubit $\reg C$ originally in the state $\ket |0>$.
Let $T$ be the transformation 
\[
T\colon \ket A|a>\ket B|b> \ket C|c> \mapsto \ket A|a> \ket B|b> \ketA C|c\oplus (a\odot b)>.
\]

The algorithm is as follows (see also \rf{fig:BV-circuit}).
First apply $H^{\otimes m}$ to the register $\reg B$, and the operation $T$.
This gives the state
\[
\frac1{\sqrt{q}} \sum_{b = 0}^{q-1} \ket B|b> \sum_{a=0}^{q-1} \sqrt{p_a} \ket C|a\odot b> \ket A|a> \ket W|\phi_a>
=
\frac1{\sqrt{q}} \sum_{b = 0}^{q-1} \ket B|b> \ket C\reg A \reg W|\phi_b'>
\]
with
\[
\ket |\phi_b'> 
= \sum_{a=0}^{q-1} \sqrt{p_a} \ket C|a\odot b> \ket A|a> \ket W|\phi_a>
=  \sqrt{1 - p'_b} \ket C|0>\ket A\reg W |\phi'_{b,0}> + \sqrt{p'_b} \ket C|1> \ket A\reg W |\phi'_{b,1}>,
\]
where all $\phi'_b$ and $\phi'_{b,i}$ are normalised.
Note that $p'_b \ge \frac 12+ \delta$ if and only if $r\odot b = 1$.

\mycutecommand{\Orefb}{O_{\mathrm{ref}, b}}
Let $\Oref'$ denote the operator $\Oref$ applied to $\mathcal{AW}$ controlled by $\ket C|0>$.
We have
\[
T \Oref' T^* = \bigoplus_{b = 0}^{q-1} \Orefb,
\]
where $\Orefb$ reflects about $\phi'_b$ in $\mathcal{CAW}$.
Therefore, applying the Boolean error reduction subroutine $R$ on $\mathcal{CAW}$ with the input oracle $T\Oref'T^*$ gives the state (assuming exact implementation):
\[
\frac1{\sqrt{q}} \sum_{b = 0}^{q-1} (-1)^{r\odot b}\ket B|b> \sum_{a=0}^{q-1} \sqrt{p_a} \ket C|a\odot b> \ket A|a> \ket W|\phi_a>.
\]
We apply $T^*$ to $\mathcal{ABC}$ and then $H^{\otimes m}$ to $\reg B$.
Using the same analysis as in the Bernstein-Vazirani algorithm, we get the state
\[
\ket |\phi> \ket B|r>.
\]
If $R$ has imprecision $\eps$, then this subroutine has imprecision $\eps$ as well.
\end{proof}

This result can be combined with any Boolean error reduction or purification procedure.
Combining with \rf{thm:ErrorReduction}, we obtain the following result.
\begin{cor}
\label{cor:NB ErrorReduction}
Let $\eps, \delta>0$ be parameters.
There exists a quantum algorithm that, given query access to the oracle $\Oref$ reflecting about the state~\rf{eqn:NB phi}, $\eps$-approximately performs the transformation in~\rf{eqn:NB ErrorReduction}.
The algorithm makes $\ell = \OO\sA[\frac1{\delta}\log\frac1{\eps}]$ queries to the oracle $\Oref$, where $\delta = p_r-1/2$, uses one additional qubit, and has time complexity $\OO(\ell + m)$.
\end{cor}

Similarly, we can combine this result with a purifier $S'$ from \rf{thm:mainInfinite} to get the following result improving on Theorem 13.3 of~\cite{belovs:taming}.

\begin{cor}
Let the register $\cA$ and $\cW$ be fixed as at the beginning of this section.
There exists a transducer $S(\Oref)$ with the following properties.
If the input oracle $\Oref$ reflects about the state $\ket|\phi>$ as in~\rf{eqn:NB phi}, it performs the transduction
\[
\ket |\phi> \ket B|0> \transduce{} \ket |\phi>\ket B|r>.
\]
The query complexity of the transduction is less than $1/(2\delta)$, where $\delta = p_r-1/2$, and its transduction complexity is $\OO(1/\delta))$.
\end{cor}

Time- and query-efficient implementations from Sections~\ref{sec:time-efficient} and~\ref{sec:query-efficient} are applicable here as well.

\paragraph{Acknowledgements} AB is supported by the Latvian Quantum Initiative under European Union Recovery and Resilience Facility project no. 2.3.1.1.i.0/1/22/I/CFLA/001.

SJ is supported by NWO Klein project number OCENW.Klein.061;
the project Divide \& Quantum  (with project number 1389.20.241) of the research programme NWA-ORC, which is (partly) financed by the Dutch Research Council (NWO);
and by the European Union (ERC, ASC-Q, 101040624). SJ is a CIFAR Fellow in the Quantum Information Science Program. 


\bibliographystyle{habbrvM}
{
\small
\bibliography{belov,refs}
}



\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
